<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - lyer's blog</title><link>/posts/</link><description>所有文章 | lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Sun, 18 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="/posts/" rel="self" type="application/rss+xml"/><item><title>密码加盐和彩虹表攻击</title><link>/2021/04/18/%E5%AF%86%E7%A0%81%E5%8A%A0%E7%9B%90%E5%92%8C%E5%BD%A9%E8%99%B9%E8%A1%A8%E6%94%BB%E5%87%BB/</link><pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/18/%E5%AF%86%E7%A0%81%E5%8A%A0%E7%9B%90%E5%92%8C%E5%BD%A9%E8%99%B9%E8%A1%A8%E6%94%BB%E5%87%BB/</guid><description>密码明文存储 这种密码存储方式直接将用户密码明文存储在数据库中，一旦数据库被黑客获取，那么所有信息都泄露，有些用户的密码可能在好几个账户上都是相同的，这是一种最不完全的方式
​
密码hash加密存储 这种方式比上一种略微安全，用户注册时将用户的密码使用指定的hash算法进行加密，然后存储在数据库中，当用户登录的时候将登录的密码使用相同的hash算法进行计算hash值然后与数据库存储的hash值进行比较即可
这种方式可能造成 彩虹表攻击 ，攻击者建立一个 明文-&amp;gt;密文 的一个巨大的映射表，如果凑巧你的密码密文被包含在了这个表中，那么黑客就可以知道你的密码明文了
这个数据字典很容易收集，CSDN 泄露的那 600w 个密码，就是很好的原始素材
如果用户密码很复杂那么被包含到彩虹表里面的可能性越小
​
密码加盐进行hash 这种方式会在用户注册的时候给用户随机上次一个salt值，然后再和用户的密码进行计算hash值
salt 可以是任意字母、数字、或是字母或数字的组合，但必须是随机产生的，每个用户的 Salt 都不一样，用户注册的时候，数据库中存入的不是明文密码，也不是简单的对明文密码进行散列，而是 hash( 明文密码 + Salt)，
密码加盐之后还是无法保证100%的安全，如果数据库泄露了，黑客还是可以在他们原来的数据字典中的密码，加上我们泄露数据库中的 Salt，然后散列，然后再匹配，但是由于salt是随机产生的，假如我们的用户数据表中有 30w 条数据，数据字典中有 600w 条数据，那么需要获取30w的salt然后分别对600w的数据字典中的明文密码都加上一个salt计算hash，那最终加盐的彩虹表大小就是30w*600w的条目，这个计算量是巨大的，然后再根据用户数据表的hash值遍历这个彩虹表，这个遍历耗时也是巨大的
并且salt插入的地方也无法知道，可能插入在头、尾、中间任意位置都有可能，这就加大了破解的难度，所以密码加盐还是能够保证安全性的
​
参考 CSDN600万账户密码泄露事件
为什么要在密码里加点“盐”</description></item><item><title>常见的Hash算法</title><link>/2021/04/17/%E5%B8%B8%E8%A7%81%E7%9A%84hash%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/17/%E5%B8%B8%E8%A7%81%E7%9A%84hash%E7%AE%97%E6%B3%95/</guid><description><![CDATA[什么是Hash算法 Hash表这种数据结构中就是使用了Hash算法，其将值进行Hash转化为表数组对应的下标，这种Hash算法的目的就是将其他数据比如 字符串、int、bool 转化为数组下标(正整数)
下面来看看JDK11里面HashMap的hash函数
static final int hash(Object key) { int h; return key == null ? 0 : (h = key.hashCode()) ^ h &gt;&gt;&gt; 16; } 主要通过key的hashCode函数来计算hash值，并且还进行了二次hash来减少碰撞
用户实现的这个hashCode有如下几个规定:
 如果 key1 = key2，那 hash(key1) == hash(key2) 如果 key1 != key2，那 hash(key1) != hash(key2) 如果不同的key产生了相同的hash值那么就代表产生了hash碰撞 hashCode必须返回一个非负整数  我们再来看一看String的hashCode的实现，下面是英文的拉丁字母的hashCode函数
至于为什么31这是为什么减少hash碰撞，因为31是一个不大不小的质数
public static int hashCode(byte[] value) { int h = 0; byte[] var2 = value; int var3 = value.length; for(int var4 = 0; var4 &lt; var3; ++var4) { byte v = var2[var4]; h = 31 * h + (v &amp; 255); //字母会转化为对应的ASCII码值然后计算hash  } return h; }  Java中Integer类型的hashCode是它本身]]></description></item><item><title>Cache高速缓存</title><link>/2021/04/07/cache%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/</link><pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/07/cache%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98/</guid><description>Cache和内存地址映射 1、直接相联映射 内存指定的块只能缓存到指定的Cache行中，采用mod的方式，并且块号用中间的位数，这样主要是为了能利用局部性原理将附近的几个块都能够有机会同时缓存起来
缺点是缓存利用率底，指定的块只能对应指定的行，如果对应的缓存行慢了，即时其他缓存行空着也无法缓存，需要将自己对应的缓存行的数据置换出去
2、全相联映射 内存每块都可以映射到Cache的每一行，优点是缓存利用率高，缺点是查找缓存效率低，需要遍历查找是否存在与缓存中
3、组相联映射 直接映射+全相联映射的结合，将多块分为一组，同时将缓存行里面的多行分为一组，每组内采用全相联映射，组间采用直接相联映射
​
Cache数据读取和写入 读命中和读不命中 CPU拿到真实的内存地址之后需要先检查Cache是否命中，如果命中则直接返回否则需要向下一级Cache加载数据，如果下一级也没有命中则需要直接访问内存，访问内存的时候通常会根据局部性原理预读一些数据到各级缓存中
写命中 写数据的时候如果Cache命中了，则我们需要考虑多级缓存以及和内存同步问题，因为L3缓存、内存等都是多核共享的，如果不能及时将脏数据更新回L3或则内存则会造成数据不一致问题，通常有下面两种处理方式:
Write Through 直写
如果写命中，则直接同时跟新当前Cache以及下一级Cache、内存等，这种方式能很好的保障数据一致性，但是会引起总线流量过大，每次写都需要立即更新
Write Back 写回
如果写命中则不会立即更新下一级缓存或则内存，而是标记位dirty ，等到此缓存行被替换的时候再写回，此策略的缺点就是无法保障数据一致性，优点就是可以减少总线流量
写不命中 写数据如果没有命中Cache，则也会有如下几个策略:
Write Allocate 写分配
首先加载对应的数据到缓存行中，然后往缓存里面写入，此策略通常和 Write Back 配套
Not Write Allocate 非写分配
避开高速缓存，直接操作内存，此策略通常是与 Write Through 配套
综上: 我们得出，Cache一致性问题有两种策略解决 (命中和不命中两种情况对应的策略)
Write Through+Not Write Allocate Write Back + Write Allocate ​
Cache分级 L1缓存分为两种: 指令缓存和数据缓存</description></item><item><title>原型模式</title><link>/2021/04/07/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/07/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>为什么要使用原型模式 原型模式又叫 克隆模式，是对一个对象的拷贝，当一个对象的创建比较复杂的时候就可以使用原型模式进行拷贝然后再修改需要修改的部分
​
代码实现 public class EnglishBook extends Book{ public EnglishBook(String title,Author author) { super(title,author); } @Override public String toString() { return String.format(&amp;#34;%s:《%s》&amp;#34;,this.author.getName(),this.title); } @Override protected Book clone() { return new EnglishBook(this.title,this.author); } } ​
原型模式在Spring中的应用 Spring的Bean通常是单例的，如果我们显式需要多个对象则会使用原型模式创建多个对象</description></item><item><title>建造者模式</title><link>/2021/04/07/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/07/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description>为什么要使用建造者模式 建造者模式将对象本身和对象的创建进行解耦，用户不需要知道对象创建的细节和流程
建造者模式解决了对象的创建过程和流程，这些都不需要用户关心
建造者和工厂模式不同的是建造者更加关系构建对象的流程，各个部件的构建顺序，而工厂模式更加关心的是对象的整体，工厂模式创建的对象比较单一，没有很复杂的组件，而如果对象由好几个对象组成，并且对象属性比较多，构建顺序有一定的要求则需要使用建造者模式
​
实现 创建一个电脑
public class Computer { private String brand; private String cpu; private String mainBoard; private String hardDisk; private String displayCard; private String power; private String memory; // 省略 getter, setter, toString } Builder抽象类
public abstract class Builder { protected Computer computer = new Computer(); public abstract void buildBrand(); public abstract void buildCPU(); public abstract void buildMainBoard(); public abstract void buildHardDisk(); public abstract void buildDisplayCard(); public abstract void buildPower(); public abstract void buildMemory(); public Computer createComputer() { return computer; } } 具体的实现</description></item><item><title>工厂模式</title><link>/2021/04/05/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/05/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid><description><![CDATA[为什么要使用工厂模式 工厂模式是一种创建型的设计模式，专门用于创建对象，通过工厂模式创建对象我们就不需要手动创建对象了，直接重工厂类里面获取即可。
工厂方法主要有如下几个优点:
 隐藏了创建对象的复杂度，用户不需要知道如何创建对象，只需要调用相关的方法API即可创建对象， 降低了代码耦合，一旦我们需要修改创建对象的方式或则参数，如果不使用工厂模式直接new的话那么我们需要手动查找并且修改所有new的代码，而如果使用了工厂模式因为我们获取对象都是通过工厂获取的，我们只需要修改工厂类的相关代码即可  ​
工厂模式实现方法  简单工厂 工厂方法模式 抽象工厂  ​
简单工厂 简单工厂模式就是只有一个工厂，然后用户通过传入不同的名字或则参数，此工厂类再根据用户传入的参数进行判断需要创建哪个对象(被创建的实例具有相同的接口或则父亲，当然了，返回值直接设置成Object也是可以的)
简单工厂模式有如下几个缺点:
 违背开闭原则(对扩展开放，对修改关闭)，如果需要增加一个类则需要修改工厂类 工厂类只有一个，职责过重，逻辑复杂  interface Computer { String Brand(); //品牌 } public class MacComputer implements Computer { public static final String BrandName = &#34;Mac&#34;; @Override public String Brand() { return BrandName; } } public class LenovoComputer implements Computer { public static final String BrandName = &#34;Lenovo&#34;; @Override public String Brand() { return BrandName; } } public enum ComputerBrand { Mac, Lenovo } 创建计算机的简单工厂，根据传入的Type不同分别创建不同品牌的计算机，如果需要增加一种品牌则需要改动此部分代码，所以违背了 开闭原则]]></description></item><item><title>Java枚举</title><link>/2021/04/04/java%E6%9E%9A%E4%B8%BE/</link><pubDate>Sun, 04 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/04/java%E6%9E%9A%E4%B8%BE/</guid><description>Java枚举的简单使用 public enum HttpStatus { OK, NoContent, NotFound, InternalServerError, BadGateway } 可以使用如下几个常见的枚举方法
public static void main(String[] args) { HttpStatus ok = HttpStatus.OK; String okStr = ok.name(); //OK Integer okIndex = ok.ordinal(); //0 HttpStatus notFound = HttpStatus.valueOf(&amp;#34;NotFound&amp;#34;); //str-&amp;gt;enum HttpStatus[] values = HttpStatus.values(); //string values } ​
枚举实现原理 枚举是Java的一种语法糖，内部通过继承 Enum抽象类来实现，下面我写了一个类来说明枚举类实现原理，就是通过 static变量+static初始代码块 来实现的，这就是为什么枚举非常适合作单例的原因
public final class WeekDay { private final String name; private final Integer ordinal; private WeekDay(String name, Integer ordinal) { this.</description></item><item><title>单例模式</title><link>/2021/04/03/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 03 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/03/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid><description><![CDATA[为什么要使用单例模式 有时候系统只需要一个对象，比如 数据库连接对象、线程池对象 等
线程池这种对象如果建立多个就会失去它的意义，因为线程池本来就是用来管理多个线程的只需要一个即可
数据库连接对象使用单例并不是指只有一个数据库连接，数据库连接对象里面保存的只是数据库连接相关的信息，比如数据库类型、用户名、密码、URL、字符集等
实际创建个多少TCP连接和实际的并发量有关，因此数据库连接对象也不必每次查询SQL的时候去创建对象，这样就显得多余和麻烦了
这种为了让系统中只存在一个对象的模式就叫 单例模式
​
单例模式实现方法  饿汉式 方法级别锁、双重检查锁 静态内部类 枚举  ​
饿汉式单例 饿汉式单例指的就是在系统初始化的时候就创建对象
优点是无需考虑多线程问题
缺点是无法懒加载，万一对象始终用不到那就白加载了
Java类成员变量初始化实现 public class DataBaseManager { //初始化时就创建  private final static DataBaseManager db = new DataBaseManager(&#34;lyer&#34;,&#34;55555&#34;); private String username; private String password; //必须隐藏构造方法 外界无法创建  private DataBaseManager(String username,String password){ this.username = username; this.password = password; } public static DataBaseManager getInstance(){ return db; } } Go全局变量实现 go中可以通过 全局变量 或则init函数实现，不过这不是最佳实现方式
var database1 = &amp;DataBase{} func main() { database1.]]></description></item><item><title>操作系统中的各种栈</title><link>/2021/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%88/</link><pubDate>Sat, 03 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%88/</guid><description>栈的作用 程序中栈的作用主要有如下:
局部变量的空间快速分配和释放 函数调用与返回 保存状态，以便恢复 在函数里面的变量都属于局部变量，函数调用结束，出了函数这个局部遍历就没有用了，那么其空间也不需要保留了
所以栈可以在函数调用时快速分配局部变量的内存地址，而在函数调用结束之后可以立即销毁，所以在C语言中不能在函数中返回局部变量的指针，这样会造成 悬挂指针 问题，因为在函数返回时其地址就已经被回收了
栈还有另外的作用就是嵌套函数调用，比如 递归，其实就是一层层的函数调用栈，所以所有的递归代码都可以用 迭代 来改写
栈还在 中断处理 中发挥着中断恢复的作用，进程在发生中断的时候会将进程当前的寄存器状态和当前的PC指针都压入内核栈然后开始执行中断处理代码，中断处理也是使用这个内核栈的，等中断处理完毕之后就弹出内核栈恢复寄存器继续回到之前的代码中执行
​
线程栈和进程栈 Linux的进程和线程其实都是同一个结构体task_struct来表示，Linux并没有线程的概念，只是Linux的进程有父进程子进程的概念，有一颗进程树
Linux的线程也叫轻量级进程，Linux通过多个进程共享内存空间来实现进程中的多线程
主线程就是创建进程的那个执行流，而子线程都从主线程也就是进程中fork出来，只是fork之后相当于copy，所以他们能共享内存空间等其他资源(包括文件描述符等)这样就可以实现线程的效果了
虽然他们内存空间都一样，很多资源都是一样的，但是各个线程之间的stack还是需要fork之后重新改变的，多个线程之间必须使用独立的栈，因为他们都是不同的执行流，是并行执行的，而不是向函数一样一层层嵌套的
如果线程栈都使用同一个的话那么如果发生线程切换调度，原来线程的执行过程中保存在栈中的数据就会被破坏掉，或则不是他想要的数据了
线程的stack大小是固定的，是从父进程的堆空间映射过来的，也就是说线程的栈开辟在父进程的堆中
linux创建线程都是使用fork，必须要有一个父进程(第一个用户进程init进程1号进程是由操作系统在初始化时创建的，第一个内核级进程是2号进程)，如果是创建线程则直接共享内存空间改变stack和PID、PPID等一些主要的信息即可，如果是创建进程则需要重写进程映象，加载可执行文件重新建立属于自己的内存地址空间，重新建立页表映射
​
进程内核栈 操作系统会为每个进程都创建内核栈，此栈用于系统调用、中断等发生特权级转换执行内核代码使用，在发生中断引发特权级别转化时，操作系统会将进程触发中断时的上下文都压入内核栈以便能继续回到用户态，然后在执行内核代码
注意内核栈是和PCB一起管理的，也就是说一个PCB包含了内核栈，内核栈大小是固定的
内核栈也是必须要独立的，为什么内核栈不能使用进程的栈呢?
这主要是为了保护内核，内核级的数据不允许出现在用户级空间上
哪为什么要为每个进程都建立一个内核栈呢?
这主要是为了防止进程调度之后导致的问题，就像每个线程不能共享进程栈一样，一个进程即使陷入内核了还是会发生进程调度，因为进程陷入内核还是在这个进程范围内为这个进程服务
为什么进程和子线程需要独立的内核栈?
这个问题其实和上面那个重复了，进程(也就是主线程)和子线程的内核栈也必须在独立的，同样为了防止线程调度引发的数据破坏问题 ，这个很好理解，因为Linux线程其实就是进程模拟出来的，那么自然在陷入内核时必须为其创建独立的内核栈
​
参考 Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈</description></item><item><title>进程状态恢复</title><link>/2021/04/03/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D/</link><pubDate>Sat, 03 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/03/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D/</guid><description>系统调用和中断时的状态恢复 发生系统调用的时候，需要发生 特权级转化 ，这样才可以指向内核代码执行系统调用代码等，这时候也需要保存进程的状态，因为系统调用或则中断处理完毕之后需要回到之前的用户进程继续执行
操作系统会为每个进程分配一个 内核栈，此栈每个进程都有并且内核栈大小是固定的，其地址空间保存在PCB中，也就是 task_struct中，方便和PCB一起管理
内核栈用于存放一些系统调用执行的数据等，因为系统调用执行的代码也需要用到栈，因此为了在系统调用结束之后还可以继续回到之前的位置执行于是在发生系统调用之前需要将进程相关的上下文信息都压入内核栈中，比如 PC指针、各个寄存器值、堆栈指针等 因为进入内核态之后堆栈也会发生变化，所以这里需要保存进程之前的堆栈信息
**注意，发生中断时进程的 **CR3 寄存器是不会改变的也不需要保存，此寄存器保存了用户进程的页表，因此操作系统可以根据这个页表将内核空间的数据copy到用户空间(内核态和用户态的数据有两个系统调用函数: copy_to_user和copy_from_user)
因为用户的页表永远都有操作系统的地址映射，所以不影响内核代码的执行
上下文信息保存完毕之后，就可以执行内核代码了，内核代码指向完毕之后栈相关数据也空了，然后继续恢复之前在栈底保存的进程上下文信息即可，这样就可以继续回到进程中断前的代码去执行了
​
进程调度时的状态恢复 发生进程调度时需要将进程当前的所有信息都保存在task_struct中，以便下次被调度之后可以继续恢复之前的状态，比如恢复 页表、PC指针、栈指针、各个寄存器值、进程页表 等
进程调度发生的上下文切换是比 中断 引发的上下文切换代价要大的，因为进程调度还需要切换页表加载页表清空TLB缓存等操作，而中断是在一个进程内引发并且中断完毕之后需要继续回到之前的进程，相当于在进程中调用了系统内核函数一样只不过调用系统函数执行内核代码需要转化特权级和内核堆栈等，还有很多进程的信息是不需要切换的
​
参考 进程切换与系统调用(中断和异常)切换哪个耗时耗资源多
Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈</description></item></channel></rss>