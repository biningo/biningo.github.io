---
title: 容器导论
date: 2021-01-07
categories: [Docker和容器]
tags: [docker,容器,Linux]
---



## 云计算和docker容器历史

### PaaS云计算初期

云计算其实就是将主机和一些服务由大的厂商运维，用户只需要付费即可获得服务，`PaaS`就是用户只需要开发自己的应用程序。部署应用程序的相关基础设施和软件等都由提供服务器厂商安装配置好了，用户只需要上传自己的应用程序即可部署到服务器

初期，如日中天 `AWS` 和盛极一时的 `OpenStack`，以 `Cloud Foundry 为代表的开源 PaaS 项目`，却成为了当时云计算技术中的一股清流

<br>

### docker开源

当时还名叫 `dotCloud` 的 `Docker` 公司，也是这股 PaaS 热潮中的一份子

相比于 Heroku、Pivotal、Red Hat 等 PaaS 弄潮儿们，dotCloud 公司实在是太微不足道了

当`dotCloud`公司快被时代抛弃的时候，决定将自己的容器产品`docker`开源，这个决定在当时根本没人在乎

“容器”这个概念从来就不是什么新鲜的东西，也不是 Docker 公司发明的。即使在当时最热门的 PaaS 项目 Cloud Foundry 中，容器也只是其最底层、最没人关注的那一部分

由于 `PaaS`厂商需要部署不同用户的多个程序，需要在一个虚拟机上启动很多个来自不同用户的应用，Cloud Foundry 会调用操作系统的 `Cgroups 和 Namespace` 机制为每一个应用单独创建一个称作“沙盒”的隔离环境，然后在“沙盒”中启动这些应用进程。这样，就实现了把多个用户的应用互不干涉地在虚拟机里批量地、自动地运行起来的目的

<br>

### docker崛起

 Docker 实际上只是一个同样使用 Cgroups 和 Namespace 实现的“沙盒”而已

然而，短短几个月，Docker 项目就迅速崛起了。它的崛起速度如此之快，以至于 Cloud Foundry 以及所有的 PaaS 社区还没来得及成为它的竞争对手，就直接被宣告出局了

Docker 项目确实与 Cloud Foundry 的容器在大部分功能和实现原理上都是一样的，可偏偏就是这剩下的一小部分不一样的功能，成了 Docker 项目接下来“呼风唤雨”的不二法宝： **Docker 镜像**

**Docker 镜像解决的，恰恰就是PaaS平台打包部署困难的这个根本性的问题**

一旦镜像制作完成，用户就可以让 Docker 创建一个“沙盒”来解压这个镜像，然后在“沙盒”中运行自己的应用

docker崛起的原因：

1. Docker 镜像通过技术手段解决了 PaaS 的根本性问题
2. Docker 容器同开发者之间有着与生俱来的密切关系
3. PaaS 概念已经深入人心的完美契机

**docker崛起之后，`dotCloud`公司也改名为`Docker`**

<br>

### 容器技术群雄并起

Docker 和CoreOS公司合作

由于各种原因：Docker与CoreOS决裂

2014，docker发布`Dcoerk Swarm` 

2014，docker收购  `Fig`改名 `compose`

Docker生态建立

2014，`Apache Mesos` 调度系统转型为容器调度系统

2014，google的k8s宣布开源

<br>

### 容器技术尘埃落定

- google和docker公司合作，提议和 Docker 公司共同推进一个中立的容器运行时（container runtime）库作为 Docker 项目的核心依赖

    但是Docker拒绝了，认为这会削弱其地位，在不久后，自己发布了一个容器运行时库 `Libcontainer`。这次匆忙的、由一家主导的、并带有战略性考量的重构，成了 Libcontainer 被社区长期诟病代码可读性差、可维护性不强的一个重要原因

- 2015，各大公司为了切割docker的话语权，建议成立基金会，于是2015 年 6 月 22 日，由 Docker 公司牵头，CoreOS、Google、RedHat 等公司共同宣布，Docker 公司将 Libcontainer 捐出，并改名为 **`RunC` **项目，交由一个完全中立的基金会管理，然后以 RunC 为依据，大家共同制定一套容器和镜像的标准和规范  **`OCI`（ `Open Container Initiative` ）**

- Google、RedHat 等开源基础设施领域玩家们，共同牵头发起了一个名为 **`CNCF（Cloud Native Computing Foundation）`**的基金会。这个基金会的目的其实很容易理解：它希望，以 Kubernetes 项目为基础，建立一个由开源基础设施领域厂商主导的、按照独立基金会方式运营的平台级社区，来对抗以 Docker 公司为核心的容器商业生态

    CNCF目标：

    1. Kubernetes 项目必须能够在容器编排领域取得足够大的竞争优势；
    2. CNCF 社区必须以 Kubernetes 项目为核心，覆盖足够多的场景

- k8s不断壮大流行，Docker妥协，于是将 Docker 项目的容器运行时部分 **`Containerd`** 捐赠给 CNCF 社区，紧接着，Docker 公司宣布将 Docker 项目改名为 `Moby`，然后交给社区自行维护，而 Docker 公司的商业产品将占有 Docker 这个注册商标，**docker放弃了和k8s的竞争，专注于自己的商业产品**

<br>

<br>

## OCI

**开放容器标准 `Open Container Initiative`** 是由多家公司共同成立的项目，并由linux基金会进行管理，致力于container runtime的标准的制定和runc的开发等工作。所谓container runtime，主要负责的是容器的生命周期的管理

目前主要有两个标准文档：容器运行时标准 （`runtime spec`）和容器镜像标准（`image spec`）oci的runtime spec标准中对于容器的状态描述，以及对于容器的创建、删除、查看等操作进行了定义，image spec描述了镜像的规范

<br>

## runc

https://segmentfault.com/a/1190000017543294

是对于OCI标准的一个参考实现，最初由docker贡献给开源基金会，然后基金会根据runc制定OCI标准，是一个可以用于创建和运行容器的CLI(command-line interface)工具。runc直接与容器所依赖的cgroup/linux kernel等进行交互，负责为容器配置cgroup/namespace等启动容器所需的环境，创建启动容器的相关进程。runC基本上就是一个命令行小工具，它可以不用通过Docker引擎，直接就可以创建容器。这是一个独立的二进制文件，它可以直接运行符合 `oci`标准的容器

![runc](https://segmentfault.com/img/bVblHSQ?w=599&h=517)

<br>

## containerd

containerd docker组件中的一个容器运行时，是一个守护进程，它可以使用`runc`管理容器，并使用gRPC暴露容器的其他功能。containerd暴露出针对容器的增删改查的接口，Docker engine调用这些接口完成对于容器的操作

![img](https://upload-images.jianshu.io/upload_images/14871146-5c9740d16fb124a3.png?imageMogr2/auto-orient/strip|imageView2/2/w/639/format/webp)

<br>

<br>

## ORI

`Container Runtime Interface` k8s规定的容器运行时接口

<br>

## ORI-O

https://www.cnblogs.com/xuxinkun/p/8036832.html

为了进一步与oci进行兼容，kubernetes还孵化了**cri-o**，成为了架设在cri和oci之间的一座桥梁。通过这种方式，可以方便更多符合oci标准的容器运行时，接入kubernetes进行集成使用。可以预见到，通过cri-o，kubernetes在使用的兼容性和广泛性上将会得到进一步加强 **ORI-O和ORI属于k8s和CNCF，而OCI属于linux基金会**

<br>

## CNI

**`Container Network Interface`**是 CNCF 旗下的一个项目，由一组用于配置 Linux 容器的网络接口的规范和库组成，同时还包含了一些插件。**CNI 仅关心容器创建时的网络分配，和当容器被删除时释放网络资源**

<br>

<br>

## 容器FQA

### 1、为什么ubuntu镜像能跑在centos的宿主机下

https://www.cnblogs.com/lxgbky/p/12973931.html

- docker是用namespace和cgroup来进行虚拟化的，所有容器都是共享内核的，发行版的linux比如 `ubuntu、centos`等他们的内核都是一样的

- Linux发行版是在Linux内核的基础上添加了一些工具软件,比如图形界面、函数库、**软件包管理系统**等等

- Docker容器技术是基于Linux内核实现的， 它主要用到了两个内核模块:

    - `Namespace`： 用于容器的隔离， 例如PID Namespace使得容器中的进程无法感知宿主机以及其他容器中的进程。
    - `Cgroups`: 用于容器的资源控制， 比如限制容器所使用的内存大小或者CPU个数

    在CentOS上运行基于Ubuntu镜像的容器时, 容器使用了CentOS主机的内核以及Ubuntu镜像, Ubuntu镜像中安装了Ubuntu的各种软件(apt-get)，于是就可以在centos的宿主机下使用ubuntu镜像了

<br>

### 2、容器的缺点

由于docker容器都是基于同一个内核的，所以会带来问题：

- **隔离得不彻底**
- **如果你要在 Windows 宿主机上运行 Linux 容器，或者在低版本的 Linux 宿主机上运行高版本的 Linux 容器，都是行不通**
- 设置系统时间问题：如果你的容器中的程序使用 `settimeofday(2) 系统调用`修改了时间，整个宿主机的时间都会被随之修改
- 容器安全问题对宿主机威胁大，一个容器如果安全不到位，那么整个宿主机可能都会被攻击



<br>



