---
title: 操作系统中的各种栈
date: 2021-04-03
categories: [操作系统]
tags: [Linux,OS]
---

## 栈的作用

程序中栈的作用主要有如下:

- 局部变量的空间快速分配和释放
- 函数调用与返回
- 保存状态，以便恢复

在函数里面的变量都属于局部变量，函数调用结束，出了函数这个局部遍历就没有用了，那么其空间也不需要保留了

所以栈可以在函数调用时快速分配局部变量的内存地址，而在函数调用结束之后可以立即销毁，所以在C语言中不能在函数中返回局部变量的指针，这样会造成 **悬挂指针** 问题，因为在函数返回时其地址就已经被回收了

栈还有另外的作用就是嵌套函数调用，比如 **递归**，其实就是一层层的函数调用栈，所以所有的递归代码都可以用 **迭代** 来改写

栈还在 **中断处理** 中发挥着中断恢复的作用，进程在发生中断的时候会将进程当前的寄存器状态和当前的PC指针都压入内核栈然后开始执行中断处理代码，中断处理也是使用这个内核栈的，等中断处理完毕之后就弹出内核栈恢复寄存器继续回到之前的代码中执行

​    

## 线程栈和进程栈

Linux的进程和线程其实都是同一个结构体`task_struct`来表示，Linux并没有线程的概念，只是Linux的进程有父进程子进程的概念，有一颗进程树

Linux的线程也叫轻量级进程，Linux通过多个进程共享内存空间来实现进程中的多线程

主线程就是创建进程的那个执行流，而子线程都从主线程也就是进程中`fork`出来，只是`fork`之后相当于copy，所以他们能共享内存空间等其他资源(包括文件描述符等)这样就可以实现线程的效果了

虽然他们内存空间都一样，很多资源都是一样的，但是各个线程之间的`stack`还是需要fork之后重新改变的，多个线程之间必须使用独立的栈，因为他们都是不同的执行流，是并行执行的，而不是向函数一样一层层嵌套的

如果线程栈都使用同一个的话那么如果发生线程切换调度，原来线程的执行过程中保存在栈中的数据就会被破坏掉，或则不是他想要的数据了

线程的stack大小是固定的，是从父进程的堆空间映射过来的，也就是说线程的栈开辟在父进程的堆中

> linux创建线程都是使用fork，必须要有一个父进程(第一个用户进程init进程1号进程是由操作系统在初始化时创建的，第一个内核级进程是2号进程)，如果是创建线程则直接共享内存空间改变stack和PID、PPID等一些主要的信息即可，如果是创建进程则需要重写进程映象，加载可执行文件重新建立属于自己的内存地址空间，重新建立页表映射

​    

## 进程内核栈

操作系统会为每个进程都创建内核栈，此栈用于系统调用、中断等发生特权级转换执行内核代码使用，在发生中断引发特权级别转化时，操作系统会将进程触发中断时的上下文都压入内核栈以便能继续回到用户态，然后在执行内核代码

> 内核栈也是必须要独立的，为什么内核栈不能使用进程的栈呢?

**这主要是为了保护内核，内核级的数据不允许出现在用户级空间上**

> 哪为什么要为每个进程都建立一个内核栈呢?

这主要是为了**防止进程调度之后导致的问题**，就像每个线程不能共享进程栈一样，一个进程即使陷入内核了还是会发生进程调度，因为进程陷入内核还是在这个进程范围内为这个进程服务

> 为什么进程和子线程需要独立的内核栈?

这个问题其实和上面那个重复了，**进程(也就是主线程)和子线程的内核栈也必须在独立的，同样为了防止线程调度引发的数据破坏问题** ，这个很好理解，因为Linux线程其实就是进程模拟出来的，那么自然在陷入内核时必须为其创建独立的内核栈

​    

## 参考

[Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈](https://blog.csdn.net/yangkuanqaz85988/article/details/52403726)