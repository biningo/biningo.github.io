---
title: 进程状态恢复
date: 2021-04-03
categories: [操作系统]
tags: [Linux,OS]
---

## 系统调用和中断时的状态恢复

发生系统调用的时候，需要发生 **特权级转化** ，这样才可以指向内核代码执行系统调用代码等，这时候也需要保存进程的状态，因为系统调用或则中断处理完毕之后需要回到之前的用户进程继续执行

操作系统会为每个进程分配一个 **内核栈**，此栈每个进程都有并且内核栈大小是固定的，其地址空间保存在PCB中，也就是 `task_struct`中方便和PCB一起管理

内核栈用于存放一些系统调用执行的数据等，因为系统调用执行的代码也需要用到栈，因此为了在系统调用结束之后还可以继续回到之前的位置执行于是在发生系统调用之前需要将进程相关的上下文信息都压入内核栈中，比如 **PC指针、各个寄存器值、堆栈指针等** 因为进入内核态之后堆栈也会发生变化，所以这里需要保存进程之前的堆栈信息

**注意，发生中断时进程的 **`CR3` **寄存器是不会改变的也不需要保存，此寄存器保存了用户进程的页表，因此操作系统可以根据这个页表将内核空间的数据copy到用户空间**(内核态和用户态的数据有两个系统调用函数: `copy_to_user和copy_from_user`)

因为用户的页表永远都有操作系统的地址映射，所以不影响内核代码的执行

上下文信息保存完毕之后，就可以执行内核代码了，内核代码指向完毕之后栈相关数据也空了，然后继续恢复之前在栈底保存的进程上下文信息即可，这样就可以继续回到进程中断前的代码去执行了

​    

## 进程调度时的状态恢复

发生进程调度时需要将进程当前的所有信息都保存在`task_struct`中，以便下次被调度之后可以继续恢复之前的状态，比如恢复 **页表、PC指针、栈指针、各个寄存器值、进程页表** 等

进程调度发生的上下文切换是比 **中断** 引发的上下文切换代价要大的，因为进程调度还需要切换页表加载页表清空TLB缓存等操作，而中断是在一个进程内引发并且中断完毕之后需要继续回到之前的进程，相当于在进程中调用了系统内核函数一样只不过调用系统函数执行内核代码需要转化特权级和内核堆栈等，还有很多进程的信息是不需要切换的

​    

## 参考

[进程切换与系统调用(中断和异常)切换哪个耗时耗资源多](https://blog.csdn.net/taugast/article/details/112562771)

[Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈](https://blog.csdn.net/yangkuanqaz85988/article/details/52403726)