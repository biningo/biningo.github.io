---
title: Linux进程和线程
date: 2021-04-01
categories: [操作系统]
tags: [Linux,OS,进程,线程]
---

## CopyOnWrite

由于操作系统创建进程必须通过`fork`来创建，fork创建的子进程和父进程一模一样只是`task_struct`不一样，其虚拟地址空间底层的物理地址指向的都是同一个页面，只有在子进程需要修改的时候才会重新分配一个物理然后将原来的内容copy过去，最后再修改子进程的物理页，这样子进程的修改就不会影响到父进程了，这个就是 **Copy On Write技术**

操作系统主要是为了减少物理页的分配和copy的消耗，因为创建子进程之后一般子进程会通过`exec`系统调用重写自己的进程映象，所以就没有必要copy一份了，而且Linux线程是通过进程实现了，这样就可以实现多个线程共享主线程也就是父进程的内存地址空间了

![](https://raw.githubusercontent.com/biningo/cdn/master/2021-04/copyonwrite1.png)

![](https://raw.githubusercontent.com/biningo/cdn/master/2021-04/copyonwrite2.png)

​    

## Linux线程的实现

Linux中没有线程这一个单独的概念，Linux中所有的执行流所有的线程进程都通过一个`task_struct`来进行标识，Linux就是通过`task_struct`来感知线程和进程，也是通过`task_struct`中的信息来进行线程进程调度的

所以在C下创建线程都是能被Linux的内核感知到的，也就是说Linux的线程模型是 **一对一模型** ，当然其他高级语言可以自己实现自己的用户线程库来实现 **一对多、多对多线程模型**，比如Go就通过自己goroutinue来实现了 **多对多模型** ，所以goroutinue是比较轻量并且高效的，这也是为什么go的并发这么优秀的原因

Linux下每个进程都有自己的父亲，一个进程如果没有其它子线程那么就只有一个主线程，也就是进程，如果该进程创建了多个线程，那么这多个线程的父亲也就是`PPID`都指向同一个: 主线程，主线程的`PPID`指向fork它的那个进程，这两个进程是独立的不同的进程。然后每个`task_struct`中都有一个`gid`，用来标识多个`task_struct`属于同一个 **进程组**，子线程的`gid`指向主线程的`pid`，主线程的`gid`指向自己，这样就将进程和线程区别开来了，只要是属于同一个`gid`的`task_struct`就属于同一个进程，只要是`gid=pid`的则这个就是主线程也就是进程本身

另外还需要注意的就是每个`task_struct`的虚拟地址空间中都有一个栈区，这个栈每个线程进程都必须是独立的，主线程的栈空间就是创建进程时的那个栈空间，而子线程的栈空间是从主线程也就是进程的堆空间中map出来的，这个堆空间每个线程都是共享的，fork之后如果是线程则不会重写重写自己的进程映象，也就是意味着可以和主线程共享内存空间，而如果是进程则会立即重写自己的进程映象，属于独立与父进程的一个进程

​    

## 进程的虚拟地址空间





## 一些特殊的进程

操作系统进程: `idle`[0] 唯一一个没有通过fork创建的进程，也就是内核代码的main执行流

第一个用户进程: `init`[1]

第一个内核进程: `kthreadd`[2]

## 参考

[虚拟内存[01] 用户内存空间的各个段分布](https://durant35.github.io/2017/10/29/VM1_UserSpaceSegments/)

[写时复制技术](http://c.biancheng.net/view/1272.html)

