---
title: 文件系统
date: 2021-01-28
categories: [操作系统]
tags: [Linux,OS]
---

​    

​    

## VFS虚拟文件系统 

虚拟文件系统就是给文件系统的实现提供一个接口，好处有下面几个：

- **为用户进程提供一组操作文件/目录/其他对象的统一方法，方便操作**
- **为下层文件系统的具体实现提供统一的接口，让操作系统能适配多个文件系统**

![image-20181020173556821](https://raw.githubusercontent.com/biningo/cdn/master/img/KVrP0Yk.png)

在每个分区上必须安装文件系统，这样操作系统才可以操作磁盘和文件，不然操作系统是无法使用磁盘的，在分区上安装文件系统其实就是增加一些文件系统对磁盘的管理数据，同时将分区划分为一个个数据块，安装文件系统的过程就叫 **分区格式化** 格式化之后分区的主要结构如下：

![img](https://mianbaoban-assets.oss-cn-shenzhen.aliyuncs.com/2021/1/JV73ii.png)

​    

​        

### 1、super block 超级块 

`super block`在索引导块后面，主要包含整个文件系统的一些基本元数据：

- 文件系统中的数据块数
- 文件系统设置的数据块大小（一个数据块通常占据整数个扇区比如：`8个扇区`  `4k`大小）
- 空闲块数
- 空闲的inode节点数
- .......

​    

​    

### 2、inode节点区块

是一个数组结构，每个文件都有一个`inode`，linux用inode号来标识不同的文件，而不是通过文件名

```bash
stat a.html #查看文件的inode信息
ls -i a.html #查看文件的inode ID
df -i #查看各个分区的inode总数和使用量 -hi
```

**inode 节点主要包括了以下信息：**

- 文件的inode ID

- 模式/权限（保护）

- 所有者 ID、组 ID

- 文件大小（字节数）、文件类型

- 文件的硬链接数

- 上次访问时间、最后修改时间、inode 上次修改时间

- 文件的数据块block映射表（0-n逻辑数据块号分别映射到实际的数据块号）**所以同一个文件的数据可以不连续的存放在不同的数据块中** 单个inode结构图如下：

    <img src="https://user-gold-cdn.xitu.io/2020/3/25/1711022488af2cbd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:50%;" />

**打开文件的过程如下：**

- 找到文件名对应的`inode ID`
- 通过`inode ID`获取该文件`inode`节点信息
- 根据文件的`inode`信息获取数据块block然后就可以读取磁盘数据了

**目录其实也是一种文件：**

目录文件包含一系列的 **目录项** ，每个目录项由 **文件名、文件对应的inode ID**组成。目录也有自己的`inode`

目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和inode号码，所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）

**硬链接：**

一般情况一个`inode`对应一个文件名，但是也可以多个文件名同时指向一个`inode`，对文件的修改都会生效，这就是 **硬链接**

删除文其中一个文件名则不会删除文件，直到删除最后一个硬链接，也就是硬连接数变为0才会真正删除文件

```bash
ln 源文件 目标文件 #创建硬链接
```

**软链接：**

软链与硬链接最大的不同就是：软连接指向原文件的**路径+文件名**，依赖于原文件，原文件删除之后软链接也无效了

```bash
ln -s 源文文件或目录 目标文件或目录
```

​    

​        

### 3、空闲块位图和inode位图

**空闲区块位图** 管理整个分区中空闲的数据块

**inode位图** 管理整个分区中`inode`的使用和分配

​    

​    

## VFS四大对象

- super block
- inode
- dentry
- file

### 1、super block超级块

保存文件系统的所有元数据

- 块大小
- inode/block的总量、使用量、剩余量
- 指向空间 inode 和数据块的指针等相关信息

通常是常驻内存的，`super_block`表示该对象,相关操作由结构体`super_operations`表示,定义在`linux/fs.h`

```c
struct super_block {
    struct list_head      s_list;          // 指向所有超级块的链表 
    const struct super_operations  *s_op;  // 超级块方法
    struct dentry         *s_root;         // 目录挂载点 
    struct mutex          s_lock;    	   // 超级块信号量
    int                   s_count;         // 超级块引用计数
    
	......
        
    struct list_head      s_inodes;        // inode链表
    struct mtd_info       *s_mtd;          // 存储磁盘信息
    fmode_t               s_mode;          // 安装权限
};
```

​    

### 2、innode

索引节点，唯一标识一个文件，保存文件相关信息，看上文

```c    
struct inode {
    struct hlist_node i_hash;          			// 散列表，用于快速查找inode
    struct list_head  i_list;    				// 索引节点链表 
    struct list_head  i_sb_list; 				// 超级块链表超级块 
    struct list_head  i_dentry;  				// 目录项链表 
	
    ......

    uid_t             i_uid;     				// 使用者id 
    gid_t              i_gid;     				// 使用组id 
    struct timespec   i_atime;   				// 最后访问时间 
    struct timespec   i_mtime;   				// 最后修改时间 
    struct timespec   i_ctime;    				// 最后改变时间 

    const struct inode_operations  *i_op;       // 索引节点操作函数 
    const struct file_operations   *i_fop;      // 缺省的索引节点操作 
    struct super_block            *i_sb;        // 相关的超级块 
    struct address_space          *i_mapping;   // 相关的地址映射 
    struct address_space          i_data;       // 设备地址映射 
    unsigned int                  i_flags;      // 文件系统标志 
    void                          *i_private;   // fs 私有指针 
};
```

​    

### 3、dentry

- 在文件路径中，每个部分都是**目录项对象**.比如`/bin/cp`中的`/`,`bin`,`cp`都属于目录项对象
- 文件系统的目录树结构就是通过一个个下目录项对象构建的

- 目录项对象不需要在磁盘中存储，没有对应的磁盘数据结构，VFS根据字符串形式的路径名现场创建它，并且保存在内存中

```c
struct dentry {
    atomic_t      d_count;         						// 使用计数 
    unsigned int  d_flags;         						// 目录项标识 
    spinlock_t    d_lock;          						// 单目录项锁 
    struct inode  *d_inode;        						// 相关联的索引节点 
    struct hlist_node  d_hash;     						// 散列表 
    struct dentry      *d_parent;  						// 父目录的目录项对象 
    struct qstr        d_name;     						// 目录项名称 
    struct list_head   d_lru;      						// 未使用的链表

    struct list_head   d_subdirs;  						// 子目录链表 
    struct list_head   d_alias;    						// 索引节点别名链表
    unsigned long       d_time;    						// 重置时间 
    const struct dentry_operations *d_op; 				// 目录项操作相关函数 
    
    ......
};
```

​    

### 4、file

- **文件对象**表示进程已经打开的文件

- 是已打开的文件在内存中的表示

- 由相应的`open()`系统调用创建

- 由`close()`系统调用撤销
- 多个进程可以同时打开和操作同一个文件，同一个文件也可能存在多个对应的文件对象，由于是同一个文件，其索引节点对象是唯一的,这样就实现了共享同一个磁盘文件

在内核中,该对象由`file`结构体表示,其操作由结构体`file_operator`表示,定义在`linux/fs.h`中.

```c
struct file {
    union {
        struct llist_node  fu_llist;      // 文件对象链表
        struct rcu_head    fu_rcuhead;    // 释放之后的RCU链表
    } f_u;
    struct path            f_path;        // 包含的目录项
    struct inode           *f_inode;      // 缓存值
    const struct file_operations  *f_op;  // 文件操作函数
    spinlock_t		f_lock;               // 锁

    atomic_long_t          f_count;       // 文件对象引用计数
    
    ......
        
    struct address_space   *f_mapping;
};
```

​    

​    

## 缓存

![](https://raw.githubusercontent.com/biningo/cdn/master/img/1557481253963880.png)

TODO

​    

## 参考

https://www.eet-china.com/mp/a38145.html

https://www.ruanyifeng.com/blog/2011/12/inode.html

[http://lionoggo.com](http://lionoggo.com/2015/12/05/从VFS看文件读写/#超级块对象)