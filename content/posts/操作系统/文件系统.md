---
title: 文件系统
date: 2021-01-28
categories: [操作系统]
tags: [Linux,OS]    
---

## VFS虚拟文件系统

虚拟文件系统就是给文件系统的实现提供一个接口，好处有下面几个：

- **为用户进程提供一组操作文件/目录/其他对象的统一方法，方便操作**
- **为下层文件系统的具体实现提供统一的接口，让操作系统能适配多个文件系统**

![image-20181020173556821](https://raw.githubusercontent.com/biningo/cdn/master/img/KVrP0Yk.png)

在每个分区上必须安装文件系统，这样操作系统才可以操作磁盘和文件，不然操作系统是无法使用磁盘的，在分区上安装文件系统其实就是增加一些文件系统对磁盘的管理数据，同时将分区划分为一个个数据块，安装文件系统的过程就叫 **分区格式化** 格式化之后分区的主要结构如下：

![img](https://raw.githubusercontent.com/biningo/cdn/master/img/JV73ii.png)  

1、引导块

存放引导操作系统启动的代码程序，每个分区都有一个引导块，这样可以实现多系统，只需要在**MBR**或**EFI系统**上放置一个`bootloader`，该`bootloader`就会确定**活动分区**（通常由用户在启动界面选择启动哪个系统），然后就会跳转到响应的 活动分区中的引导块中加载引导块中的代码到内存进行执行，然后就会加载该活动分区中的操作系统

2、super block 超级块

`super block`在索引导块后面，主要包含整个文件系统的一些基本元数据：

- 文件系统设置的数据块大小（一个数据块通常占据整数个扇区比如：`8个扇区`  `4k`大小）
- 文件系统中的数据块数
- 空闲块数
- 空闲的inode节点数
- .......

操作系统在启动之后就会将`super block`从磁盘加载到内存，然后建立 **super_block对象**，该对象是常驻内存的

3、空闲块位图和inode位图

**空闲区块位图**： 管理整个分区中空闲的数据块，占用多个数据块`block`

**inode位图** ：管理整个分区中`inode`的使用和分配，占用多个数据块`block`   

4、inode节点区块

是一个数组结构，存放整个文件系统的`inode`信息，每个`inode`就代表一个文件，**inode节点个数**代表该文件系统最多能创建多少个文件，`inode`节点存放的具体内容在下文**inode对象** 中说明

​    

​    

## VFS四大对象

- super_block
- inode
- dentry
- file

### 1、super_block

- 包含了整个文件系统的重要信息：inode个数、数据块大小、数据块个数
- 常驻内存
- 每个分区都有一个`super_block`，多个`super_block`对象用链表链接，`df`命令读取的就是所有的`super_block`，因为常驻内存所以读取数度非常快，所有对文件系统的修改都要修改`super_block`
- 每个`super_block`都有对应自己的操作函数

```c
struct super_block {
    struct list_head      s_list;          // 指向所有超级块的链表 
    const struct super_operations  *s_op;  // 超级块相关操作的方法
    struct dentry         *s_root;         // 目录挂载点
    struct mutex          s_lock;    	   // 超级块信号量
    int                   s_count;         // 超级块引用计数
    
	......
        
    struct list_head      s_inodes;        // inode链表
    struct mtd_info       *s_mtd;          // 存储磁盘信息
    fmode_t               s_mode;          // 安装权限
};
```

### 2、inode

每个文件都有一个`inode`，linux用inode号来标识一个文件，而不是通过文件名

```bash
stat a.html #查看文件的inode信息
ls -i a.html #查看文件的inode ID
df -i #查看各个分区的inode总数和使用量 -hi
```

**inode 节点主要包括了以下信息：**

- 文件的`inode ID`

- 文件权限信息

- 所有者 ID、组 ID

- 文件大小（字节数）、文件类型

- 文件的硬链接数

- 上次访问时间、最后修改时间、inode 上次修改时间

- 文件的数据块block映射表（0-n逻辑数据块号分别映射到实际的数据块号）**所以同一个文件的数据可以不连续的存放在不同的物理数据块中** 单个inode结构图如下：

    ![](https://raw.githubusercontent.com/biningo/cdn/master/img/640.png)

小文件直接映射到对应的数据块，大文件则可以使用二级、三级索引

**打开文件的过程如下：**

- 找到文件名对应的`inode ID`
- 通过`inode ID`获取该文件`inode`节点信息
- 根据文件的`inode`信息获取逻辑数据块号和实际物理数据块block号的映射表，然后就可以读取磁盘数据了

**目录(文件夹)其实也是一种文件：**

目录文件的数据块存储的是 **一项一项的文件信息** ，每个项由 **文件名、文件对应的inode ID**组成，目录也有自己的`inode`

如果目录文件没有`r`或则`x`权限，也就是说无法读取目录文件的数据，也就无法读取目录下面的文件的`inode`信息了

```c
struct inode {
    struct hlist_node i_hash;          			// 散列表，用于快速查找inode
    struct list_head  i_list;    				// 索引节点链表 
    struct list_head  i_sb_list; 				// 超级块链表超级块 
    struct list_head  i_dentry;  				// 目录项链表 
	
    ......

    uid_t             i_uid;     				// 使用者id 
    gid_t              i_gid;     				// 使用组id 
    struct timespec   i_atime;   				// 最后访问时间 
    struct timespec   i_mtime;   				// 最后修改时间 
    struct timespec   i_ctime;    				// 最后改变时间 

    const struct inode_operations  *i_op;       // 索引节点操作函数 
    const struct file_operations   *i_fop;      // 缺省的索引节点操作 
    struct super_block            *i_sb;        // 相关的超级块 
    struct address_space          *i_mapping;   // 相关的地址映射 
    struct address_space          i_data;       // 设备地址映射 
    unsigned int                  i_flags;      // 文件系统标志 
    void                          *i_private;   // fs 私有指针 
};
```

### 3、dentry

`dentry`不会持久化到磁盘，是内核在内存中建立的，描述文件的逻辑属性，更确切的说是**存在于内存的目录文件的缓存**，为了提高查找性能而设计

**不管是文件夹还是文件，都是属于目录项**，所有的目录项在一起构成一颗庞大的目录树

例如：要`open`一个文件`/home/lyer/tmp/a.txt`，那么`/`、`home`、`lyer`、`a.txt`都是一个目录项，VFS在查找的时候，根据一层一层的目录项找到对应的每个目录项的`inode`，那么沿着目录项进行操作就可以找到最终的文件。`/`根目录项对象会在内核启动之后创建，然后文件系统就会被自动挂载到`/`目录，然后就可以进行访问文件系统了，其他的文件系统想要被使用，也必须要挂载到其中一个目录下才可以被访问

**如果没有目录项建立在内存中，那么每次查询路径都需要读取磁盘的数据，那么性能就会很低**



![](https://raw.githubusercontent.com/biningo/cdn/master/img/640.webp)

```c
struct dentry {
    atomic_t      d_count;         						// 使用计数 
    unsigned int  d_flags;         						// 目录项标识 
    spinlock_t    d_lock;          						// 单目录项锁 
    struct inode  *d_inode;        						// 相关联的索引节点 
    struct hlist_node  d_hash;     						// 散列表 
    struct dentry      *d_parent;  						// 父目录的目录项对象 
    struct qstr        d_name;     						// 目录项名称 我也就是文件或则目录的名字 
    struct list_head   d_lru;      						// 未使用的链表

    struct list_head   d_subdirs;  						// 子目录链表 
    struct list_head   d_alias;    						// 索引节点别名链表
    unsigned long       d_time;    						// 重置时间 
    const struct dentry_operations *d_op; 				// 目录项操作相关函数 
    
    ......
};
```

### 4、file

每个文件对象包含对应的`innode`和`dentry`对象

- 调用`open`就是在内存中创建一个**file对象**
- `close`就是销毁内存中的 **file对象**
- 一个文件可能会被多个进程打开，于是就会有多个文件对象对应同一个文件
- 文件对象之间通过链表链接
- 进程会维护一个数组结构的文件打开表，数组下标就是`fd`文件描述符，每个数组元素指向一个`file`对象

```c
struct file {
    union {
        struct llist_node  fu_llist;      // 文件对象链表
        struct rcu_head    fu_rcuhead;    // 释放之后的RCU链表
    } f_u;
    struct path            f_path;        // 包含的目录项
    struct inode           *f_inode;      // 缓存值
    const struct file_operations  *f_op;  // 文件操作函数
    spinlock_t		f_lock;               // 锁

    atomic_long_t          f_count;       // 文件对象引用计数
    
    ......
        
    struct address_space   *f_mapping;
```

​    

​    

## 硬链接和软链接

**硬链接：**

一般情况一个`inode`对应一个文件名，但是也可以多个文件名同时指向一个`inode`，对文件的修改都会生效，这就是 **硬链接** 

硬链接直接在目录文件下增加一个目录项，然后将`inode ID`就是原文件的`inode ID`，只是目录项的文件名不一样。多个硬链接其实都是修改的同一个`inode`对应的文件，只有当`inode`表示的硬链接数变为0才会真正的删除文件

```bash
ln 源文件 目标文件 #创建硬链接
```

![图片](https://raw.githubusercontent.com/biningo/cdn/master/img/666.webp)

**软链接：**

软链与硬链接最大的不同就是：软连接相当于创建一个新文件，然后文件的数据块内容保存的就是原文件的**路径+文件名**，依赖于原文件，原文件删除之后软链接也无效了

```bash
ln -s 源文文件或目录 目标文件或目录
```

![](https://raw.githubusercontent.com/biningo/cdn/master/img/700.webp)

​        

## 参考

[http://lionoggo.com](http://lionoggo.com/2015/12/05/从VFS看文件读写/#超级块对象)

https://www.eet-china.com/mp/a38145.html

https://mp.weixin.qq.com/s/qJdoXTv_XS_4ts9YuzMNIw