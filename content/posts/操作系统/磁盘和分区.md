---
title: 磁盘和分区
date: 2021-01-23
categories: [操作系统]
tags: [Linux,OS]
---

​    

## 磁盘物理结构

![img](http://c.biancheng.net/uploads/allimg/181012/2-1Q01215492WL.jpg)

- **盘面**：一个机械磁盘有好几个盘面组成，中间有转轴

- **磁头**：盘面正反两面都可以使用，每个盘面都有一个磁头，用来读写这个盘面的数据
- **磁道**：盘面被物理划分为多个磁道

- **扇区**：每个磁道会被划分为多个固定`512byte`大小的扇区（现在也有`4k`扇区），扇区是磁盘数据存储的最小单位。**整个磁盘`0盘面0磁道第一个1扇区`最重要，记录了整个磁盘的分区信息和操作系统启动程序，计算机启动之后首先加载第一个扇区的信息到内存**
- **柱面**：每个盘面的同一个磁道组成柱面，磁盘的读写顺序就是按照柱面来的，写入时按顺序先写满一个柱面（一个盘面的磁道数据写满后再激活下一个盘面的磁头）然后再移动磁头臂写另外一个柱面，读数据也是按照这个顺序读

磁盘在出厂前需要进行**低级格式化**：就是给磁盘划分磁道、扇区。这些属于硬件层面，OS无法控制

​    

​        

## 磁盘寻址方式

早期所有磁道的扇区个数一样，采用`CHS`方式寻址，这种划分方式外磁道颗粒稀疏，存储密度小，造成空间浪费

现在的磁盘外磁道的扇区个数大于内道，存储密度都一样了，采用`LBA`寻址

### 1、CHS寻址

CHS寻址方式的容量由CHS三个参数决定：`(柱面,磁头,扇区)` 

早期磁盘的每个磁道的扇区数一样多 ，整体磁盘大小也很小。所以在设计时用了`24`位地址来确定一个扇区：`10+8+6`

- 柱面数最大为`1024`(用 10 个二进制位存储)。从0开始编号（一个盘面最多能划1024个磁道）

- 磁头数最大为`256` (用 8 个二进制位存储)。从0开始编号，(最多有256个盘面)

- 一个盘面中的扇区数最大数 `64`(用 6个二进制位存储) 

> **最大寻址空间：`1024*256*64*512byte=8414461440 byte = 8G+`**

### 2、LBA寻址

现代机械磁盘容量变大，主要有如下几个改变：

- 磁盘面的磁颗粒更高密+磁头更稳定更细(影响C柱面数)       
- 磁盘面的磁颗粒均匀分布（影响S扇区数）
- 磁盘增加磁盘盘面（影响H盘面数）

同时采用 `LBA`逻辑块地址寻址，线性地址，给每个扇区一个编号(0-最后一个扇区号)

`LBA`将`CHS`这种三维寻址方式转变为一维的线性寻址，它把硬盘所有的物理扇区`(柱面号/盘面号/扇区号)` 编号通过一定的规则转变为**一维线性的编号**，系统效率得到大大提高，避免了 烦琐的`(磁头/柱面/扇区)`的寻址方式。在访问硬盘时，由**硬盘控制器**再这种逻辑地址转换为实际硬盘的物理扇区地址

​    

​    

## 磁盘分区

### 1、什么是磁盘分区

磁盘分区就是把一整块磁盘切割为几个部分，相当于 win的 C、E、D盘，Linux的/dev/sda1、/dev/sda2...  可以把磁盘看做一块原木，分区就是在原木上做一个桌子、椅子

**进行磁盘分区主要有如下几个原因：**

- **方便数据管理**
- **保证数据安全**，不同分区之间数据互不干扰
- **加快数据查找**，比如找E盘的文件，磁头臂只需要在指定的柱面范围内寻找即可

每个分区都可以安装不同的文件系统来单独管理这个分区的文件，也可以安装相同的文件系统来管理所有分区的文件

### 2、MBR分区表

**`Master Boot Record 主要开机记录区`：MBR**

主要用于早期磁盘容量还很小的时代和`32`位机器时代

由于单个扇区大小只有 `512b`，所以第一个扇区主要保存如下几个内容：

- 操作系统的`bootloader`程序（机器码程序）：`446byte`
- 分区表：`64byte`，每个分区表项大小为`16byte`，有`4`个分区表项
- 结束标识`55 AA`：`2byte`  如果**BIOS**检测到以此标识结尾，则表明此磁盘是启动磁盘，如果检测不到，则将跳过此设备，转向下一个设备

为了设置更多的分区，于是就有了 **主分区和扩展分区** 的概念

- 扩展分区最多`1`个（历史前人规定，没有原因）觉得想要更多的分区，就必须将其中一个分区表项设置为扩展分区
- 在这个扩展分区指定的磁盘空间中的扇区中再设置分区表，借此来划分跟多的分区，这些分区就叫 **逻辑分区**

关于主分区和扩展分区网上找了一张自认为比较好的图：

![MBR拓展分区](https://img2020.cnblogs.com/blog/2084106/202007/2084106-20200705233500139-1171448891.png)

![img](https://note.yuchaoshui.com/api/file/getImage?fileId=5e07583ea2f92c0d38000092)

操作系统启动程序`bootloader`可以直接安装到`MBR`中，也可以安装到某个分区中的**引导扇区** ，通过引导扇区可以实现 **多系统**，比如将选择启动系统的程序安装到`MBR`中，然后将操作系统各自的`bootloader`程序安装到自己的分区中的引导扇区中

Window安装时默认会自动将MBR和windows所在分区的引导扇区都装上引导程序，而不会提供任何选项给用户选择，因此如果之前装过其他操作系统，然后再另外装一个windows时，会把公用的MBR覆盖掉，如此，原来的操作系统就无法启动了。

如果先装windows，然后装linux，linux 会覆盖MBR，然后让用户选择是否将windows等其他操作系统的启动项添加进来，如果你选择了添加进来，那么你在开机时就会有两个选项让用户进行选择了。

**MBR分区主要有如下几个缺点：**

- 第一个扇区毁坏，整个磁盘不可用
- MBR内操作系统的启动程序`bootloader`大小有限，无法做更多的操作
- 分区表大小有限，主分区数量有限
- 磁盘大小有限，磁盘最大有 `2T`（这个限制需要是由于MBR分区表项字段限制的）原因可以参考如下文章https://www.cnblogs.com/harrymore/p/13782261.html，也就是说如果有一个`4T、3T`或则更大的磁盘额外的空间就无法被识别，分区大小最大也只能有`2T` 也就是只划分一个区的情况

**MBR分区表项结构：**（活动分区指操作系统安装的分区）

![img](https://img2020.cnblogs.com/blog/741682/202010/741682-20201008184307747-1604693136.gif)

### 3、GPT分区表

**`GUID Partition Table 全局唯一标识码分区表`：GPT ，又称`GUID`分区表**

 由于现代磁盘容量不断扩大，现在扇区大小已经是`4k`，早期的MBR分区的各种缺点已经不适应现代磁盘了，所以就有GPT分区方式，采用 `LBA`线性寻址方式，从0开始给每个扇区一个编号

`LBA0`仍然为`MBR`，但是这个扇区是被保护的，没有引导代码，仅仅被标识为**未知分区**，并且加上`GPT`类型分区的标识。当支持`GPT`的计算机引导启动序比`UEFI`检测到这个第一个扇区就会忽略此扇区，然后跳到`LBA1`读取`GPT`分区表信息

![gpt](https://segmentfault.com/img/remote/1460000020850914)

如果不能识别`GPT`，则分下面两种情况讨论：

- 采用兼容模式，则继续按照传统的`BIOS`方式读取第一个`MBR`扇区也就是`LBA0`扇区，然后通过`bootloador`启动操作系统
- 直接报错表示无法识别，保护磁盘数据，防止被老的系统格式化磁盘数据

`LBA2-LBA33`每个`LAB`扇区都可以记录`4`个分区表项，每个 `LBA`扇区大小为`512b`，所以每个表项大小为`128b`，一共可以记录`4*32=128`条表项目，也就是说最多可以设置128个分区，`LBA`采用`64bits`来记录扇区号，所以一个分区的容量最大可以达到`2^64*512b=233TB`，所以整块磁盘大小可以是 `128*233TB=1024PB`  ，GPT没有所谓的主分区和逻辑分区，全部都是主分区

> **分区表扇区只是记录分区信息，其他扇区才是分区具体存放数据的扇区**

​        

​    

## BIOS和UEFI

### 1、BIOS

**`Basic Input/Output System`基本输入输出系统：BIOS** 

BIOS启动的时候按照固件中设置的设备启动顺序启动，挨个查看存储设备的前`512`字节是不是以`0x55 0xAA`结尾，如果不是，那就跳过找下一个设备；如果是的话，则表示这个磁盘可以启动，加载这`512`字节里的代码，然后执行里面的 `bootloader`程序，`bootloader`程序是在安装系统的时候写进去的，比如安装`Windows`，这里面就变成了`Windows`的启动代码；安装了`Linux`，这里面就会变成`Grub`的启动代码

比如用U盘安装Linux，那么Linux安装程序就会在安装系统时在第一个扇区写入`bootloader`程序，同时将系统安装到某个分区中（存放要启动操作系统的分区称为活动分区，一张磁盘只能有一个活动分区，比如装了双系统win和linux，要启动linux则linux系统安装的分区称为活动分区），以便`bootloader`查找并加载系统到内存进行执行

所以 BIOS启动流程主要是：

- `ROM`中的`BIOS`程序被加载到内存执行
- `BIOS`开机自检
- `BIOS`读取固件中设置的启动设备信息，加载启动设备的第一个`MBR`扇区到内存
- 执行`MBR`中的`bootloader`程序（由于第一块分区中的`bootloader`存储空间有限，则可以继续跳转到其他分区中存储的`bootloader`进行执行，Linux就是采用这种方式----链式启动）

### 2、UEFI

**`Unified Extensible Firmware Interface`统一的可扩展固件接口：UEFI**

目的是代替`BIOS`，UEFI程序只能识别 `FAT32`类型的文件系统，UEFI规定UEFI系统分区`EFI system partition (ESP)`系统启动分区必须采用`FAT32`文件系统，`ESP`分区通常为`128M`，主要用来存放引导操作系统启动的`.efi`启动文件

所以UEFI启动流程如下：

- 开机后，固化在`ROM`里的`UEFI BIOS`就会被加载到内存运行
- `UEFI BIOS`能够通过程序识别`GPT`分区表和`FAT32`文件系统
- `UEFI BIOS`识别出`ESP`分区（ESP在GPT分区表中有一个GUID），读取`FAT32`文件系统中的各种启动文件启动操作系统内核，比如`.efi`
- `EFI`运行之后控制权就全部交给`EFI`系统了

> **BIOS+MBR已经趋于淘汰，UEFI+GPT是大势所趋**

​    

​    

## 文件系统

对磁盘进行分区之后，还需要对分区进行格式化，也就是在分区上面安装文件系统，这样操作系统才可以操作磁盘，**所以说文件系统是对磁盘的抽象，方便用户和操作系统操作磁盘**

文件系统安装完毕之后，就可以将操作系统内核保存在磁盘上了，然后就可以等待启动程序来识别文件系统找到操作系统内核代码保存的位置然后加载到内存进行执行了

### 1、块和扇区

- **扇区**是磁盘读取的基本单位，**块（block）**是文件系统读取数据的基本单位：因为一个扇区太小了，如果一个扇区一个扇区读写，会造成IO次数太多，效率低下，所以文件系统将多个扇区组成一个block，一个block大小通常为`4k`，如果一个文件不足一个block大小，也必须要占一个block，加载数据到内存时会加载数据所在的整个block到内存
- 操作系统将内存大小抽象为页，将磁盘抽象为block，和内存页一样，block的大小不能设置太大或太小

### 2、VFS虚拟文件系统

虚拟文件系统就是给文件系统的实现提供一个接口，好处有下面几个：

- **为用户进程提供一组操作文件/目录/其他对象的统一方法，方便操作**
- **为下层文件系统的具体实现提供统一的接口，让操作系统能适配多个文件系统**

![image-20181020173556821](https://i.imgur.com/KVrP0Yk.png)

​    

​    

## 参考博客和相关优质博客文章

https://cloud.tencent.com/developer/article/1383160

https://www.cnblogs.com/cxuanBlog/p/13156493.html

https://segmentfault.com/a/1190000020850901

https://www.i3geek.com/archives/1275

https://www.junmajinlong.com/linux/systemd/systemd_bootup/

https://zhuanlan.zhihu.com/p/26098509

https://zhuanlan.zhihu.com/p/25992179

https://segmentfault.com/a/1190000006872609

https://juejin.cn/post/6844904102258819080#heading-13

[http://lionoggo.com](http://lionoggo.com/2015/12/05/从VFS看文件读写/#)

https://juejin.cn/post/6912354117306286087#heading-2

https://www.ruanyifeng.com/blog/2011/12/inode.html

鸟哥的Linux私房菜