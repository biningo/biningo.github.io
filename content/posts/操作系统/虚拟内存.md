---
title: 虚拟内存
date: 2021-03-52
categories: [操作系统]
tags: [Linux,OS]
draft: true
---

## 操作系统内存管理FAQ

> 为什么需要将内核的页目录表底地址和高地址都设置页表指向？

内核的初始页表是内核的`loader`汇编程序进行设置的，会建立内核的基本页表，为了将内核地址映射到高地址处，则只需要将页目录表的最后几个表项指向一级页表即可，一级页表则记录的是虚拟逻辑地址对应的物理地址，内核在编译的时候使用的就是逻辑的高地址进行开始编译编址的，运行时将此虚拟地址通过内核页表进行转化为实际的物理底地址处，`loader`程序建立初始页表，然后加载内核到内存中后（内核程序也是ELF格式的，loader也是程序员写的，loader需要分析内核的ELF信息然后将相关的数据段分别加载到指定的内存区域），然后就跳到了内核代码段处，然后内核就开始执行自己的代码了

前面初始页表的开始底地址处也是需要指向内核页表的，底地址处的虚拟地址映射是需要和物理地址一一映射的，为了就是让之前实模式下的代码填的实际物理地址能在保护模式下通过虚拟地址能转换到同一个物理地址，能让实模式的代码继续运行，比如各个基础外设的驱动代码等，之前实模式的程序的地址都是实际的物理地址

以及后来的OS内核需要打印字符的话都是要操作屏幕外设，而屏幕外设的显存地址映射都是映射在实模式的底地址处，只有操作这个显存地址才能打印字符，os写打印库的时候需要指定这个底地址的实际地址，但是需要进过虚拟地址转化，因为之前在页目录表的底地址处也设置了和高地址目录项一样的页表，所以能将虚拟地址转化为相同的物理地址，**让实模式下的程序能在保护模式下正常运行** 还有如果执行BIOS中断的话中断程序也是实模式的地址，所以能继续让BIOS中断工作

​    

## 参考

- https://m.xp.cn/b.php/77856.html 【Linux绕过GDT，直接采用分页】
- https://cloud.tencent.com/developer/ask/217577 【Linux绕过GDT，直接采用分页】