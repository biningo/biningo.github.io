---
title: Linux进程调度
date: 2021-04-30
categories: [操作系统]
tags: [Linux,OS]  
draft: true
---

## 实时进程和普通进程

Linux将进程分为: **实时进程和普通进程**

实时进程必须快速响应，比如一些前台进程需要和用户进行交互的进程，所以实时进程的优先级比较高，否则就会造成用户体验不好，并且实时进程是允许抢占的，普通进程则优先级没有那么高

实时进程的优先级是静态的，在创建的时候就确定了，运行时不会再改变。而普通进程的优先级Linux内核可以根据实际情况进行动态的修改

​        

## 进程优先级

每个进程都有一个优先级，在`task_struct`中保存，是一个数值类型，优先级数字越低代表优先级越高

对于实时进程，优先级的范围是 `0～99`，对于普通进程，优先级的范围是 `100～139`

**所以所有的实时进程的优先级都比普通进程要高**

​    

## Linux进程调度算法

首先来看为什么需要进程调度以及有哪些进程调度算法

因为Linux是有多进程的，进程数量肯定是大于CPU核心数量的，一个CPU需要执行多个进程，所以CPU需要选择合适的算法调度这些进程来达到多进程并发运行的效果

每个CPU都有一个属于自己的 **进程就绪队列**，每次触发进程调度条件的时候，比如发生时钟中断之后，Linux内核的调度器察觉到当前运行的进程已经达到调度条件了(比如正在运行的进程分配的时间片用完了)，那么就需要将这个进程改为就绪态，再根据合适的算法从就绪队列里选择合适的进程进行调度运行

### 实时进程调度

Linux实时进程调度算法和普通进程调度是不一样的，可选`SCHED_FIFO`或`SCHED_RR`调度策略

实时进程的调度算法主要有如下几个:

- `FIFO` **先来先服务**

    由于实时进程是可抢占的，此刻来了个高优先级的实时进程，那么这个进程就会抢占CPU进行运行，如果是优先级相同的则按照先来先服务进行运行

- `RR` **时间片轮询**

    相同优先级的任务分配的CPU执行的时间片一样，用完时间片就加入等待队列的尾部，然后CPU从队首拿进程再运行相同的时间片以此往复下去....

- `DEADLINE `  **deadline调度**  

    选择其 deadline 距离当前时间点最近的那个任务，并调度它执行，由于此调度算法是抢占式的，所以缺点就是长进程的响应时间会变长，因为长进程往往会被短进程打断，越短的进程就越先被执行

### 普通进程调度

Linux中大部分都是普通进程，采用`SCHED_NORMAL`调度策略，普通进程的调度算法为: **CFS完全公平调度算法** 和实时进程调度算法不同的是，两个不同的优先级也能进行调度

而实时调度算法只能在优先级相同的情况下才能发挥调度算法的作用，一个低优先级的进程必须等待高优先级执行完毕之后才能执行，CFS调度就不一定了

​    

## CFS完全公平调度

> **越执行时间越少则优先级越高越容易被调度**

每个进程都有个`vruntime`，这个`vruntime`并不是仅仅根据实际的运行时间来计算的，而是会结合实际运行时间和`nice`值进行一个计算，这个`nice`值可以根据实际情况进行动态的修改，下面给出vruntime的一个计算公式

```bash
vruntime += (实际运行时间*nice)/权重
```

权重直接由`nice`值决定，内核有个数组，里面记录了每个`nice`值对应的`widget`值

```c
const int sched_prio_to_weight[40] = {
 /* -20 */     88761,     71755,     56483,     46273,     36291,
 /* -15 */     29154,     23254,     18705,     14949,     11916,
 /* -10 */      9548,      7620,      6100,      4904,      3906,
 /*  -5 */      3121,      2501,      1991,      1586,      1277,
 /*   0 */      1024,       820,       655,       526,       423,
 /*   5 */       335,       272,       215,       172,       137,
 /*  10 */       110,        87,        70,        56,        45,
 /*  15 */        36,        29,        23,        18,        15,
};
```

可以看到，如果`nice`值越大，则`widget`也越大

综上的计算公式，我们得出如果普通进程的实际运行时间越长则分子越小，`vruntime`值就会变大

同样的实际运行时间，高权重的进程计算出的`vruntime`值就会小，低权重就会算的大

所以高权重的进程能更容易被调度，增加相同的`vruntime`下，高权重的进程能运行更多时间

**核心数据结构: 红黑树**

红黑树的key保存的是进程的`vruntime`，vruntime最小的在树的最左边，最大的在最右边（红黑树是一个高度自平衡的搜索树）每个CPU都有自己的就绪队列，也就是自己的待调度进程的红黑树，**在调度时，调度器首先会先去实时进程队列找是否有实时进程需要运行，如果没有才会去 CFS 运行队列找是否有进行需要运行**

每次CPU都是从树的最左边获取`vruntime`最小的进程进行调度，当进程执行时他的`vruntime`就会增大，所以调度执行次数越多那么就会到树的右边，此时就更不容易被调度

​    

## CFS算法的几个问题

### 新进程的vruntime值是0吗?

一个新进程如果`vruntime`值是0的话，那么他已创建就比所有老进程的优先级都高，就会被立即执行并且会执行很长一段时间，这会造成不公平

所以`cfs_rq`中维护了一个最小的`min_vruntime`，新的进程的`vruntime`不会小于这个，这样就还可以保持一个相对公平的调度

### 休眠的进程vruntime值不会变吗?

如果休眠进程休眠很久了，并且他的`vruntime`值不会变的话，那么他醒来就会获得比较高的优先级，会进程打断其他进程并且会执行很长时间，这显然也是不公平的

所以一个休眠进程醒来的时候会重新设置其`vruntime`，也是以`min_vruntime`为基础来设置的，并且会给予一定的补偿，这样既可以提高休眠进程的优先级**让休眠进程醒来之后及时拿到CPU，同时也不会让休眠进程长时间占用CPU**

### 进程被调度运行的时间片会很小吗

想象多个进程的`vruntime`时间接近，此时调度一个进程运行时候其`vruntime`立马变大，此时会立即调度其他`vruntime`小一点的进程吗？

答案是否定的，不会立即切换，每个进程的运行时间片都有一个最小值，只有运行超过这个最小值才能被切换，这样保证了不会频繁产生调度而带来额外的消耗

### 进程从切换到其它CPU的就绪队列后vruntime还是不变吗?

每个CPU都有一个就绪队列，多核CPU为了进行负载均衡，让CPU平均分摊就绪进程的调度，可能一个队列的进程会被移动到其它CPU的队列中

每个CPU的队列中的`vruntime`情况都是不一样的，那么如果一个进程切换队列之后`vruntime`还是不变吗? 这显然是不公平的，如果一个最小vruntime很小的队列中的进程移动到最小vruntime比较大的队列中，其vruntime还是不变的话则此进程就会在新的队列中长期占用CPU，所以当一个进程移动到其他队列时，其`vruntime`也必须重新设置

CFS的解决办法如下:

当进程从一个CPU的运行队列中出来的时候，它的vruntime要减去队列的min_vruntime值

而当进程加入另一个CPU的运行队列时，它的vruntime要加上该队列的min_vruntime值

​    

## 进程调度过程

![](https://raw.githubusercontent.com/biningo/cdn/master/2021-04/task_rq.png)

每个CPU都有一个`rq`结构，里面保存了`rt_rq`也就是实时进程的队列，还保存了`cfs_rq` 也就是普通进程的队列

CPU进行调度的时候会先执行优先级高的调度类中的调度方法，每个调度类都实现了自己的调度方法，也就是如何操作自己负责的就绪队列。比如CPU会先执行`rr`调度类，该类会操作`rt_rq`队列，如果此队列中没有进程则会继续调用下一个调度类`cfs`调度类，此调度类就会查找`cfs_rq`这颗红黑树选择最左边的节点的进程进行调度运行

**注意，这些调度类的指针在task_struct中也保存了，所以进程可以主动执行系统调用陷入内核态然后执行调度类的方法进行主动调度**

​       

## 总结

Linux进程分为俩大类:

- 实时进程
- 普通进程

其中实时进程总是比普通进程优先调度，实时进程和普通进程调度策略和调度算法是不一样的，并且低优先级的实时进程必须等待高优先级的实时进程执行完才可以执行，如果是相同优先级的实时进程则可以按照  **FIFO、RR** 等实时进程调度算法进行调度

对于普通进程则采用 **CFS完全公平调度算法**，此算法不是按照优先级来进行调度的，而是按照每个进程的虚拟执行时间`vruntime`进行调度，`vruntime`越长则代表此进程优先级越底，则越不容易被调度，反之则越容易被调度

`vruntime`计算公式会结合进程的`nice`值进行计算，`nice`值越底则代表权重越高，对于高权重的进程在消耗相同的`vruntime`时间下的实际执行时间会比底权重的进程长

CFS算法采用 **红黑树** 保存就绪任务队列，每个CPU都有属于自己的就绪任务队列，每次从树的最左边取`vruntime`最小的进程进行调度

​    

## 参考

[Linux的进程优先级](https://zorrozou.github.io/docs/books/linuxde-jin-cheng-you-xian-ji.html)

[Linux内核 | 进程调度 | nice | 进程优先级 | 通俗易懂 | 快乐小神仙](https://www.bilibili.com/video/BV1dK411G7Hc?p=7&spm_id_from=pageDriver)

[Linux进阶之进程、线程及调度算法](https://www.bilibili.com/video/BV1D5411p7Nx?p=3) 【视频将整个进程都讲解的很详细】

[从几个问题开始理解CFS调度器](http://linuxperf.com/?p=42) 【写的不错】