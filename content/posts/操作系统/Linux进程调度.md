---
title: Linux进程调度
date: 2021-04-30
categories: [操作系统]
tags: [Linux,OS]  
draft: true
---

## 实时进程和普通进程

Linux将进程分为: **实时进程和普通进程**

实时进程必须快速响应，比如一些前台进程需要和用户进行交互的进程，所以实时进程的优先级比较高，否则就会造成用户体验不好，并且实时进程是允许抢占的，普通进程则优先级没有那么高

实时进程的优先级是静态的，在创建的时候就确定了，运行时不会再改变。而普通进程的优先级Linux内核可以根据实际情况进行动态的修改

​        

## 进程优先级

每个进程都有一个优先级，在`task_struct`中保存，是一个数值类型，优先级数字越低代表优先级越高

对于实时进程，优先级的范围是 `0～99`，对于普通进程，优先级的范围是 `100～139`

**所以所有的实时进程的优先级都比普通进程要高**

​    

## Linux进程调度算法

首先来看为什么需要进程调度以及有哪些进程调度算法

因为Linux是有多进程的，进程数量肯定是大于CPU核心数量的，一个CPU需要执行多个进程，所以CPU需要选择合适的算法调度这些进程来达到多进程并发运行的效果

每个CPU都有一个属于自己的 **进程就绪队列**，每次触发进程调度条件的时候，比如发生时钟中断之后，Linux内核的调度器察觉到当前运行的进程已经达到调度条件了(比如正在运行的进程分配的时间片用完了)，那么就需要将这个进程改为就绪态，再根据合适的算法从就绪队列里选择合适的进程进行调度运行

### 实时进程调度

Linux实时进程调度算法和普通进程调度是不一样的，可选`SCHED_FIFO`或`SCHED_RR`调度策略

实时进程的调度算法主要有如下几个:

- `FIFO` **先来先服务**

    由于实时进程是可抢占的，此刻来了个高优先级的实时进程，那么这个进程就会抢占CPU进行运行，如果是优先级相同的则按照先来先服务进行运行

- `RR` **时间片轮询**

    相同优先级的任务分配的CPU执行的时间片一样，用完时间片就加入等待队列的尾部，然后CPU从队首拿进程再运行相同的时间片以此往复下去....

- `DEADLINE `  **deadline调度**  

    选择其 deadline 距离当前时间点最近的那个任务，并调度它执行，由于此调度算法是抢占式的，所以缺点就是长进程的响应时间会变长，因为长进程往往会被短进程打断，越短的进程就越先被执行

### 普通进程调度

Linux中大部分都是普通进程，采用`SCHED_NORMAL`调度策略，普通进程的调度算法为: **CFS完全公平调度算法**

​    

## CFS完全公平调度





## 参考

[Linux的进程优先级](https://zorrozou.github.io/docs/books/linuxde-jin-cheng-you-xian-ji.html)

[Linux内核 | 进程调度 | nice | 进程优先级 | 通俗易懂 | 快乐小神仙](https://www.bilibili.com/video/BV1dK411G7Hc?p=7&spm_id_from=pageDriver)

[一文搞懂Linux进程调度原理](https://zhuanlan.zhihu.com/p/348813914)