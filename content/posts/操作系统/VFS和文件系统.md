---
title: VFS和虚拟文件系统
date: 2021-04-01
categories: [操作系统]
tags: [Linux,OS,VFS]   
---

## 为什么磁盘需要分区分块

### 1、磁盘为什么要分区

磁盘分区的主要就是划分几个大块，每个分区里面可以安装不同的底层文件系统，分区之间都是独立的，也可以在不同的分区上安装不同的操作系统，就好像把磁盘容量看成一整块，然后在这个一整块上进行划分几个区域(当然只划分一个区域也是可以的)

分区主要有一下几个优点:

- **方便数据管理**
- **隔离数据，保证数据安全**，不同分区之间数据互不干扰，分区之间独立
- **加快数据查找**：因为文件系统会将磁盘分成一个个的数据块，单个文件数据可能是存放在不连续的块中，如果分区太大，某个文件数据块分散的存在开头和结尾那么磁头臂的移动就会非常频繁造成读取效率低下，所以一个分区的大小不能划分太大，如果磁盘容量很大的话则可以多划分几个分区
- **可以在一台计算机上不同的分区上安装不同的操作系统、不同的文件系统，实现双系统等**

### 2、磁盘为什么要分块

机械磁盘读写数据是以 **扇区** 为单位的，一个扇区大小为`512字节`或则`4kb`

扇区是抽象的概念，物理上是没有的，物理上只有盘片，一张盘都是一整块的，只是物理部件在读写的时候是以这个为单位读写的，所有文件的容量大小必须是扇区数量的整数，需要按照扇区大小对齐

SSD固态硬盘没有盘片的概念，但也有数据单元和数据页的概念，SSD相当于内存一样但是可以持久化，每个数据单元就是`1byte`，同时一个数据页就包含了多个数据单元，SSD读写的基本单位就是数据页，也是需要做到数据页对齐的

**但是物理划分的区块太小了，如果一个文件按照物理区块进行存储的话，因为保存文件的区块不一定连续(如果连续的话会造成碎片问题，所以都是分散存放然后建立索引表)，所以读写一个文件会造成IO次数太多造成而造成效率太低**

所以底层的文件系统再次进行了重新划分区块大小，一个数据块对应着物理上 **连续的几个扇区或则几个数据页**，文件存储的基本单位就是以文件系统划分的数据块为单位的，数据块大小一般和内存页大小一致，方便与内存数据进行交换

如果需要读一个文件，则需要找到保存文件所有数据块的索引表，此表由操作系统和文件系统维护，这些数据块之间可能是分散的，虚拟块是连续的，需要读写哪部分则按照偏移然后加载对应的数据块到内存然后进行读写，这个和内存虚拟地址思想一样

​    

## ext4文件系统

### 1、ext2 ext3

这就是最简单的`ext2、ext3`的底层结构，具体的区别不深究了，大概就是这样，跳出细节才更有利于学习

![](https://raw.githubusercontent.com/biningo/cdn/master/img/JV73ii.png)

1. **引导块**

存放引导操作系统启动的代码程序，每个分区都有一个引导块，这样可以实现多系统，只需要在**MBR**或**EFI系统**上放置一个`bootloader`，该`bootloader`就会确定**活动分区**（通常由用户在启动界面选择启动哪个系统），然后就会跳转到响应的 活动分区中的引导块中加载引导块中的代码到内存进行执行，然后就会加载该活动分区中的操作系统

2. **superblock超级块**

`super block`在索引导块后面，主要包含**整个文件系统的一些基本元数据**，可以说一个super block就代表了一个文件系统，因此此块一般会进行备份，因为如果这里面的数据被销毁了那么这个磁盘就没办法使用了，里面的数据就无法读取了，该块主要保存如下几个数据:

- 文件系统设置的数据块大小(一个数据块通常占据整数个扇区比如：`8个扇区`  `4k`大小)
- 空闲块数
- 空闲的inode节点数
- .......

操作系统在启动之后就会将`super block`从磁盘加载到内存，然后建立 **super_block对象**，该对象是常驻内存的

3. **空闲块位图和inode位图**

- **空闲区块位图bitmap**

    管理整个分区中空闲的数据块，占用多个数据块`block`

- **inode位图bitmap**

    管理整个分区中`inode`的使用和分配，占用多个连续的数据块`block`，如果inode分配完了就无法再创建文件了

4. **inode节点区块**

是一个数组结构，存放整个文件系统的`inode`信息，每个`inode`就代表一个文件，**inode节点个数**代表该文件系统最多能创建多少个文件

> **注意，inode的大小是固定的，每个inode节点的大小，一般是128字节或256字节，用于标识一个唯一的文件，所以没有保存文件名，文件名保存在文件对应的目录文件的data block中**

**inode 节点主要包括了以下信息：**

- 文件的`inode ID`
- 文件权限信息
- 所有者 ID、组 ID
- 文件大小（字节数）、文件类型
- 文件的硬链接数
- 上次访问时间、最后修改时间、inode 上次修改时间
- 文件的数据块block映射表

ext文件系统的数据保存的数据块是分散的(为什么要分散前面说了)，为了找到这些数据所以需要建立索引表，索引表如果都放在`inode`结构上，那么如果文件太大则索引表就会变的很大，但是`inode`大小是固定的，所以ext3文件系统采用了如下多级索引的方式，`inode`一共保存了`15`个索引项在inode中，如果文件很小则前面几个索引项直接指向真实的数据块，如果文件很大那么后面索引项指向的数据块就不是保存数据了而是保存索引信息了，相当于二级索引，每个数据块又能保存256个索引项，如果文件还很大则又会建立三级索引、四级索引等

![](https://raw.githubusercontent.com/biningo/cdn/master/img/640.png)

综上可以得出此文件系统对于大文件的查找需要查询多个数据块之后才可以找到对应的数据块，而小文件则直接在一级索引就可以找到直接的数据块，由于各个数据块都是分散存放的，所以`ext3`**对大文件查找速度较慢**

### 2、ext4

`ext4`为了解决**大文件查找速度慢**问题，改进如下:

TODO过于复杂看不到QAQ

​        

## VFS虚拟文件系统

> **在 Linux 中除进程之外一切皆是文件**

虚拟文件系统就是给文件系统的实现提供一个接口，然后所有底层的文件系统都根据这个接口来对具体的磁盘进行实现，**文件系统需要将函数指针注册到VFS中，然后调用函数实际就是调用底层文件系统的具体实现**

好处有下面几个: 

- **为用户进程提供一组操作文件/目录/其他对象的统一方法，方便操作**
- **跨多个不同类型的底层文件系统、不同类型的存储介质也可以互相操作** (因为操作的接口都是一样的，只是底层真实的文件系统、物理介质有区别)
- **为下层文件系统的具体实现提供统一的接口，让操作系统能适配多个文件系统、多种物理介质，可以在内存模拟出文件系统、磁盘等**
- **Linux一切皆文件，网络socket、管道等都是依赖VFS虚拟文件系统来抽象的**

在每个分区上必须安装真实的文件系统，这个过程叫**磁盘格式化**，这样底层的文件系统才可以管理磁盘空间、合理分配空间、了解磁盘使用情况等，在分区上安装文件系统其实就是增加一些文件系统对磁盘的管理数据，同时将分区划分为一个个数据块，数据块大小一般和操作系统内存页大小一致，操作磁盘的基本单位就是这些数据块

安装了文件系统之后，操作系统才可以用`VFS`接口操作底层文件系统以此来操作磁盘

操作系统需要借助底层真实文件系统提供的**IO驱动程序**来操作磁盘，驱动程序需要向操作系统注册，这些驱动程序正是实现了VFS操作的相关接口函数

![image-20181020173556821](https://raw.githubusercontent.com/biningo/cdn/master/img/KVrP0Yk.png)

​        

## VFS四大对象

VFS建立抽象出了文件系统的四大对象:

- **super_block** 代表一个文件系统
- **inode** 代表一个文件，里面保存了文件的数据块索引表等信息(每个文件系统对索引表的实现都不一样，反正就是数据块是分散的，需要根据索引表找到数据块)
- **dentry** 代表一个目录项，这样可以维护文件与文件之间的树状关系，如路径 `/usr/bin/grep` 中其存在四个目录项对象: `/` 、`dev/` 、`input/` 及 `grep`
- **file** 一个打开的文件对象，里面有该文件对应的`inode`和`dentry`对象指针

### 1、super_block

包含了整个文件系统的重要信息：inode个数、数据块大小、数据块个数等，**常驻内存**，操作系统一启动就会根据实际的底层文件系统在内存中建立此对象

每个分区都有一个`super_block`，多个`super_block`对象用链表链接方便操作系统**挂载其他类型的文件系统和查找本机所有的文件系统信息**，挂载文件系统其实就是在`super block`链表上链上一个super block对象，`df`命令读取的就是所有的`super_block`，因为常驻内存所以读取数度非常快，所有对文件系统的修改都要修改对应的`super_block`

每个`super_block`都有对应自己的操作函数

```c
struct super_block {
    struct list_head      s_list;          // 指向所有超级块的链表 
    const struct super_operations  *s_op;  // 超级块相关操作的方法 挂载、卸载等
    struct dentry         *s_root;         // 目录挂载点   
    struct list_head      s_inodes;        // inode链表，管理此文件系统中所有的已经分配了的inode
};
```

### 2、inode

每个文件都有一个`inode`，linux用inode来标识一个文件，而不是通过文件名，每个inode都有一个inodeID，这其实就是`inode table`的一个下标索引，因为inode大小都是确定的，所以可以直接根据`inode`大小加上索引来结算出存放inode数据的地址

在Unix/Linux类型的文件系统中华比如`ext4`等其`inode`都在磁盘存在真实的数据，操作系统只需要加载进内存即可，而其他文件系统则需要分析磁盘数据，由操作系统进行创建相关的`inode`到内存，当要操作一个文件时才会读取磁盘信息读取保存在磁盘上的inode数据然后在内存中建立其`inode`对象

```bash
stat a.html #查看文件的inode信息
ls -i a.html #查看文件的inode ID
df -i #查看各个分区的inode总数和使用量 -hi
```

**读取文件的过程：**

- 在目录文件的数据块中找到文件名对应的`inode ID`
- 通过`inode ID`获取该文件`inode`节点信息
- 根据文件的`inode`信息获取逻辑数据块号和实际物理数据块block号的映射表，然后就可以读取磁盘数据了

上面有个问题就是我们如何找到目录文件的数据，为了找到目录文件的数据需要找到上层目录的目录项，为了早到上层目录的数据项我们又要找到上上层目录.....这样就会无限循环，Linux有一个`/`根目录，根目录的数据块是在挂载的时候就写死了，其数据块里面记录的目录项都是`usr` `etc`等操作系统自身重要目录的`inode、目录名` 等

**目录(文件夹)其实也是一种文件**，目录文件的数据块存储的是 **目录项**  ，也就是一项一项的文件信息 由 **文件名、文件对应的inode ID 等**组成，目录也有自己的`inode`

如果目录文件没有`r`或则`x`权限，也就是说无法读取目录文件的数据，也就无法读取目录下的的数据也就是无法读取目录项了，自然也就不知道此目录下面有哪些文件了

### 3、dentry

`dentry`不会持久化到磁盘，是内核在内存中建立的，描述文件的逻辑属性，更确切的说是**存在于内存的目录文件的缓存**，为了提高查找性能而设计，每个文件都有一个`dentry`对象，不管是文件夹还是文件，都是属于目录项

例如：要`open`一个文件`/home/lyer/tmp/a.txt`，那么`/`、`home`、`lyer`、`a.txt`都是一个目录项，VFS在查找的时候，根据一层一层的目录项找到对应的每个目录项的`inode`，那么沿着目录项进行操作就可以找到最终的文件。`/`根目录项对象会在内核启动之后创建，然后文件系统就会被自动挂载到`/`目录，然后就可以进行访问文件系统了，其他的文件系统想要被使用，也必须要挂载到其中一个目录下才可以被访问



![](https://raw.githubusercontent.com/biningo/cdn/master/img/640.webp)

```c
struct dentry {
    atomic_t      d_count;         						// 使用计数 
    unsigned int  d_flags;         						// 目录项标识 
    spinlock_t    d_lock;          						// 单目录项锁 
    struct inode  *d_inode;        						// 相关联的索引节点 
    struct hlist_node  d_hash;     						// 散列表 
    struct dentry      *d_parent;  						// 父目录的目录项对象 
    struct qstr        d_name;     						// 目录项名称 我也就是文件或则目录的名字 
    struct list_head   d_lru;      						// 未使用的链表

    struct list_head   d_subdirs;  						// 子目录链表 
    struct list_head   d_alias;    						// 索引节点别名链表
    unsigned long       d_time;    						// 重置时间 
    const struct dentry_operations *d_op; 				// 目录项操作相关函数 
    
    ......
};
```

### 4、file

是一个被打开的文件的内存表现形式，每个文件对象包含对应的`inode`和`dentry`对象

- 调用`open`就是在内存中创建一个**file对象**
- `close`就是销毁内存中的 **file对象**
- 进程中使用文件描述符来表示打开的文件，文件描述符其实就是进程文件打开表的下标，其数组中的元素里面保存了`file`对象的指针，此对象保存在内核的全局文件打开表中，所以不同进程之间的文件描述符是隔离的，但是不同的进程可以同时打开同一个文件，也就是其file对象指针指向同一个file对象
- 内核会维护一个数组结构的文件打开表，此表是全局共享的，表中的每一项都有一个`file`对象，进程的文件描述符就是指向一个内核文件打开表的一个条目，文件描述符是一个整数，也就是进程本身文件打开数组的下标，该数组又指向了内核的文件打开表的一个条目，因此一个文件可以被多个进程同时打开和读写

```c
struct file {
    union {
        struct llist_node  fu_llist;      // 文件对象链表
        struct rcu_head    fu_rcuhead;    // 释放之后的RCU链表
    } f_u;
    struct path            f_path;        // 包含的目录项
    struct inode           *f_inode;      // 缓存值
    const struct file_operations  *f_op;  // 文件操作函数
    spinlock_t		f_lock;               // 锁

    atomic_long_t          f_count;       // 文件对象引用计数
    
    ......
        
    struct address_space   *f_mapping;
```

​    

## 硬链接和软链接

**硬链接**

一般情况一个`inode`对应一个文件名，但是也可以多个文件名同时指向一个`inode`，对文件的修改都会生效，这就是 **硬链接** 

硬链接直接在目录文件下增加一项，然后将`inode ID`就是原文件的`inode ID`，只是目录项的文件名不一样。多个硬链接其实都是修改的同一个`inode`对应的文件，只有当`inode`表示的硬链接数变为0才会真正的删除文件

```bash
ln 源文件 目标文件 #创建硬链接
```

![图片](https://raw.githubusercontent.com/biningo/cdn/master/img/666.webp)

**软链接**

软链与硬链接最大的不同就是：软连接相当于创建一个新文件，拥有自己的`inode`，然后文件的数据块内容保存的就是原文件的**路径+文件名**，依赖于原文件，原文件删除之后软链接也无效了

```bash
ln -s 源文文件或目录 目标文件或目录
```

![](https://raw.githubusercontent.com/biningo/cdn/master/img/700.webp)

​        

## 进程的文件描述符fd

详细信息参照上文的`file`对象

![](https://raw.githubusercontent.com/biningo/cdn/master/img1/file_table.jpg)

​    

## 文件读写过程

下面展示读写文件的大致过程，省略了缓存等内容

读文件:

1. 进程进行系统调用`read`
2. 根据传入的路径查找文件对应的`inode`
3. 根据`inode`记录的数据块索引然后根据读写文件的偏移找到对应的数据块，然后读取对应的数据块到内存中
4. 文件读完成

写文件:

1. 进程进行系统调用`write`
2. 根据传入的路径查找文件对应的`inode`
3. 将文件内容先写入内核缓存区，等待一定时间再刷入磁盘，如果是追加写入则分配磁盘数据块并建立索引，如果是写入其中的已经存在的数据块则跟新其数据块内容，如果是删减数据则清空其数据块数据以及索引

​    

## 参考

【写的不错】[一口气搞懂「文件系统」，就靠这 25 张图了](https://www.huliujia.com/blog/81d31574c9a0088e8ae0c304020b4b1c4f6b8fb9) 

[从VFS谈文件读写](http://lionoggo.com/2015/12/05/从VFS看文件读写/#超级块对象)

[干货！VFS虚拟文件系统和SSD](https://cloud.tencent.com/developer/article/1551286)

[Linux 虚拟文件系统四大对象：超级块、inode、dentry、file之间关系](https://www.eet-china.com/mp/a38145.html)

[文件描述符 fd]([https://jsharkc.github.io/2019/11/15/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/](https://jsharkc.github.io/2019/11/15/文件描述符/))

[Linux内核学习笔记（一）虚拟文件系统（VFS）https://mp.weixin.qq.com/s/qJdoXTv_XS_4ts9YuzMNIw)

[理解Linux的文件描述符FD与Inode](https://zhuanlan.zhihu.com/p/143430585)

[为什么内存要分页，磁盘要分块，缓存要有cacheline？](https://zhuanlan.zhihu.com/p/81108439)

[Ext4文件系统之文件数据组织](https://zhuanlan.zhihu.com/p/52052278)