---
title: 锁
date: 2021-04-26
categories: [操作系统]
tags: [并发,锁]
draft: true
---

## 什么是锁

锁其实就是一个变量，保存在内存中，比如一个`flag`，初始化为`false` ，当被线程加锁之后就将他设置为`true`，当一个线程拿锁时会检测这个变量是否上锁，如果没有上锁也就是值不为`true`则可以拿到锁

但是难度在与置位`flag`要求是一个原子操作，并且CPU还有一个缓存问题需要解决TODO

​    

## 互斥锁和自旋锁

**互斥锁** 在加锁失败之后会释放CPU资源让给其他线程，所以互斥锁在加锁失败之后会引发一个线程调度，线程调度是有开销的，这就是为什么互斥锁会产生开销的原因

如果你锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长

**自旋锁**  线程在加锁失败之后会进入一个 **忙等** 的一个状态，相当于当前线程并不会放弃CPU而是进入一个空转的状态，一旦锁被释放了就可以立即获得锁，所以自旋锁的消耗在于空转时的消耗，不过CPU提供了空转指令`PAUSE`能大大降低这种消耗，所以如果被锁住的处理代码很长的话则不适合使用自旋锁

​    

## 参考

[面试官：你说说互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景](https://my.oschina.net/u/4482993/blog/4572408)