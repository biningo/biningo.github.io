---
title: TCP协议
date: 2021-03-11
categories: [网络]
tags: [TCP]
draft: true
---

## TCP协议

- **面向连接、可靠的字节流传输协议**
- **全双工** 可相互传递字节流
- 只可用于 **一对一通信** ，不能用于多播和组播
- TCP 使用**校验和，确认和重传机制**来保证可靠传输
- TCP 使用**滑动窗口**机制来实现**流量控制**，通过动态改变窗口的大小进行**拥塞控制**
- TCP使用 `(源地址，源端口，目的地址，目的端口)`来标识一个连接

​    

## TCP报文

![](https://raw.githubusercontent.com/biningo/cdn/master/img1/tcp.png)

### 源端口和目的端口

端口大小为`16`位，可见端口范围为:`0~2^16` 也就是[0~65536]

IP层则用ip地址来标识一台主机，TCP层用端口来标识一个应用，使用`(源地址，源端口，目的地址，目的端口)`唯一确定一个连接，所以对于IPV4的话单台主机最大的连接数为 `2^(32+16+32+16)` 个

### 序号

每个TCP包都有一个序号，编号是为了解决TCP包乱序问题，给每个包编上序号就知道了每个包的顺序，这样就可以完整的拼好所有的TCP包了而不造成乱序，TCP给个字节都有一个序号，序号是整个TCP包数据段的第一个字节的序号，比如现在一个包的起始序号为`101`，数据长度为`500byte` ，那么最后一个字节的序号就为`600`，这个TCP包的序号为第一个字节的序号`101` ，所以下一个TCP包的第一个字节的序号应该为`601`，也就是下一个TCP包的序号为`601`

**如果序号达到最大值2^32，则回卷到0**

### 确认号

设置TCP包的确认号是为了告诉对方上一个数据包已经确认收到了，你可以继续发送下一个TCP包了，这个确认号填的就是期望对方发送的下一个TCP包的 **序号**

比如B收到了A发的序号为`101`的TCP包，该包长度为`500byte`，B现在收到了A发的`600byte`之前的数据，期望A发送下一个序号为`601`的TCP包，所以确认号为`601`

A收到B的回复的确认号为`601`得知B已经收到了A发的`600byte`之前的数据，现在要发下一个序号为`601`的TCP包了

### 首部长度

长度为`4`位

指出TCP首部的大小，因为TCB首部中有可选择字段，所以每个TCB首部都是不定长的，所以需要指定首部长度，单位是`4字节` ，最大为`2^4` ，所以首部最大长度为`16*4byte=60byte`

### 保留位

`6`位，保留以后使用，目前全部置`0`

### 五大标志位

`6`位

| 标志 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| URG  | 紧急位，为`1`的话则表示这是个紧急的TCP包，应该放到发送队列的最前面去立即发送 |
| ACK  | `ACK=1`表示确认号有效，`ACK=0`表示确认号无效，TCP连接建立成功后所有的传输报文必须把ACK置为1 |
| PSH  | 很少用到，一般为0                                            |
| RST  | 复位 `RST=1` 表示TCP连接出错，必须释放连接重新建立           |
| SYN  | 同步 `SYN=1`表示这是一个请求建立连接或接受建立连接请求报文 `SYN=1 ACK=0`表示这是一个建立连接请求，`SYN=1 ACK=1`表示这是一个应答建立连接请求的TCP报文，详情请参考TCP三次握手 |
| FIN  | 用来释放连接， `FIN=1` 表示数据已经发送完毕并且请求释放TCP连接 |

### 窗口大小

TCP使用 **滑动窗口** 来实现拥塞控制和流量控制，详情请见下文

发送双方都会建立一个窗口来提醒对方自己能接受的最大数据量，展示自己的处理能力

**窗口明确指出现在允许对方发送的数据量，窗口大小经常动态变化以此来进行拥塞控制和流量控制**

### 检验和

目的是为了发现TCP首部和数据在发送端到接收端之间发生的任何改动。如果接收方检测到校验和有差错，则TCP段会被直接丢弃

### 紧急指针

`URG=1`才有意义，TODO （不理解）

### 可选项

`<=40byte`，TCP可选的头部字段，比较常用的有如下:

> **MSS** `Maximum Segment Size` 最大报文段长度

`MSS`指的是不包括TCP头部的最大数据段长度，如果应用层数据超过MMS就需要分多个TCP包进行传输

UDP则没有这个限制，直接将应用层传递下来的所有数据封装为一个UDP包传递给IP层

但是IP层还是要根据`MTU`大小将传输层的数据包来进行分片传输的，因为以太网中规定MAC数据帧的数据大小不能超过MTU，所以IP报文大小必须小于MTU，如果超过了这个值则IP数据包就会进行分片传输到目的地再根据IP报头进行组装

`MSS`是在TCP握手阶段进行确立的，双方在三次握手包中都会发送自己的MSS，然后以后通信就会按照对方的MSS大小来发送TCP包给对方

MSS大小的选择必须是要不大不小，并且需要参照`MTU` ，如果太大了则IP层会进行分片传输容易造成IP分片而造成IP包的丢失进而引发TCP层的重传影响效率，所以一般MSS大小选择和`MTU`大小接近，这样每个TCP包刚好能被一个IP包传输

如果TCP传输的数据太小则利用率不高，比如数据只传递`1byte`却要携带好几十byte的头部信息，所以MSS也不是越小越好

> **TimeStamps** 时间戳

用于计算TCP报文往返时间`RTT`，A发送数据带上时间戳，B接受到数据之后将时间戳复制到确认包中然后发给A，这样A就可以计算出TCP包  `发送+确认` 的往返时间间隔了

RTT的变化在一定程度上反映了网络拥塞程度的变化

​    

## 为什么TCP握手是三次

### 3次握手

![](https://raw.githubusercontent.com/biningo/cdn/master/img1/tcp-hand.png)

注意，握手阶段是没有数据的，所以`ack=x+1` `ack=y+1` ，后面连接的时候发送确认包这时的`ack=x+<data-size>`

那么为什么需要 三次握手，而不是 N次握手、2次握手呢？

1. **第一次**

第一次是由A发起连接请求，表示A希望和B建立连接

2. **第二次**

A发出去需要知道**B是否收到、包有没有丢、B是否同意建立连接** 所以A需要等待B的ACK包，也就是需要第二次握手

如果B收到了A的连接请求并且同意建立连接则需要回复一个ACK包

3. **第三次**

因为B回复的ACK包也可能会丢，所以B也需要等待A的 **应答之应答** ，A回复之后B就知道A收到了B的ACK，此刻便可认为连接已经建立

三次握手之后，AB双方都经历了 **一发一收**，这样就可以基本判断双方都同意建立连接了，而不是永无休止的握手下去

### 2次握手的情况

一般人和人打招呼都是一来一回就可以了，但是网络上的情况比较复杂

A发送连接请求包给B，如果A没有收到B的ACK包，那么有下面两种情况:

- **包丢了**
- **B不愿意建立连接而不回复**

上面两种情况A都会重试，直到超时则会放弃建立连接

如果B愿意建立连接则回复一个ACK确认包给A，对于B来说这个ACK包有下面两种情况:

- **ACK包丢了** A不认为B收到了自己的连接请求，所以会重复发送SYN包
- **A挂了**

那么B发送ACK报包之后就不能认为连接已经建立了，所以B也需要等A的 **应答之应答**

如果B没有收到A的应答则不会建立连接，会继续发送ACK包直到自己收到应答

这样双方都经历了 **一收一发** 则可以认为已经建立连接了，则不需要再确认下去了，再确认下去都是多余的

其次如果AB已经建立过连接了并且断开了，但是A因为之前发送了很多建立连接的请求后来又陆续到了B，那么B也会认为A还要建立则会回复ACK，那么此刻并不能认为是A还要建立连接，所以需要A继续回复一个给B才能确定建立连接，如果A不回复则表示这是A之前的连接已经建立过了，这种情况下A是不会回复的，也就不会建立错误的连接

3次握手则可以避免这样错误的连接请求

​     

## 为什么TCP断开需要四次挥手

<img src="https://raw.githubusercontent.com/biningo/cdn/master/img1/tcp-bye.png"  />

​    

## MSS和MTU

TODO

## TCP和UDP的区别

![](https://raw.githubusercontent.com/biningo/cdn/master/img1/udp.png)

UDP报文很简单，只有一个源端口和目标端口，加上UDP长度，注意这个长度是 **报文头+UDP**的数据长度

UDP特点如下:

- **面相报文** 直接封装应用层数据为一个UDP报文进行传输，数据有边界，底层IP层可能会被分片
- **无连接** 发送数据不需要连接，不需要维护相关的数据结构
- **无拥塞控制** 不管网络多忙，反正应用层有数据传递下来就发送
- **不可靠、不保证顺序** UDP不会进行重传，丢了就丢了，和IP报文一样，丢失不会进行重传，所以UDP可以看作是传输层的IP协议吧，只是比IP协议多了端口
- **支持一对多、多对多、多对一**  谁都可以给自己传数据，他也可以把数据传给任何人，不像TCP一样只能一对一传输

所以UDP应用场景有如下:

- **网络环境简单的内网**，因为内网基本不会丢包，并且网络情况也比较好不会拥塞
- **需要广播的应用**
- **要求处理快、延迟底，但是可以容忍少量丢包** 因为UDP没有拥塞控制，只会发包所以传输的速度比TCP快，比如 **视频、直播、实时通讯** 等应用

​        

## 为什么说TCP是面相字节流

为什么TCP是面相字节流，而UDP是面相报文的呢?

UDP会将上层传递下来的数据全部封装为一个UDP包，也叫UDP报文，而不会进行拆分，然后就直接传递给下层的IP，所以UDP是面相报文的 也就是说UDP认为上层的数据是有边界的

而TCP则认为上层的数据是字节流，是没有结构没有边界的，TCP相当于开辟了一个传输通道，如果上层传递下来的数据太大则会分为多个TCP包进行传输，大小限制为`MSS`，如果传递下来的数据太小则为了提高传输利用率，会等待一定的数据量的时候再分装为一个TCP包传递给下层

TCP会给每个包设置一个 **序号** 从而维护这些字节流的顺序， 对方收到之后就可以重新按照序号进行组装传递给应用层

如果TCP通道一直没有数据在传输则会自动进行4次挥手关闭连接，这和 **KeepAlive** 机制有关，详情见下文

​    

## TCP 中的 KeepAlive 机制

TCP的`KeepAlice`要注意和HTTP`keep-alive`区别开来

TCP建立连接之后如果对方一直没有数据发送，则可能有如下两种情况:

- **对方挂了** 此时可以断开连接
- **对方数据还没准备好，或则对方还需要继续复用这条TCP连接** 此时不应该断开

为了判断对方是否挂了是否需要保存连接，客户端会定时发送一个`KeepAlive`的空包，这个就是探测对方是否存活，对方是否要继续保持连接的一个探测包

如果对方回复了，则表示对方还在，连接还需要继续保持

如果对方挂了则不会发送回复，客户端在多次尝试还是收不到回复之后则可以认为这条连接不需要保持了，可以直接断开

​    

## 参考

- 《计算机网络》谢希仁
- 极客时间-趣谈网络协议