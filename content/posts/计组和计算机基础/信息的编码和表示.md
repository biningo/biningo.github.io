---
title: 信息的编码和表示
date: 2021-02-01
categories: [计组和计算机基础]
tags: [基础]
draft: true
---

## 二进制算术运算

二进制的 **加减乘除** 运算和十进制相似，只不过二进制到`2`就需要进位，而十进制到`10`才需要进位而已，其他进制也都类似。

CPU逻辑运算：`& | ^(异或) ~(取反)`  （由相应的与非门等电路组合而成）

CPU算术运算： **加法、位移** （通过上面的逻辑运算实现）

二进制的加减乘除都是通过 **加法、位移** 组合来实现的，CPU里面实现二进制的算术运算由相应的部件来实现：

- **加法器（全加器）**  实现加法
- **除法器、乘法器** 实现乘除

### 1、二进制加减

二进制加法：`01+01=10` 第一位`1+1=0`然后需要进位并且需要链式进位，这和十进制一样，加法器基本原理就是：

- **异或**（不带进位的加法`1+1=0  0+0=0`）
- **与** （计算进位,只有`1|1==1`才会产生进位）如果有进位还必须保存进位参与下一次运算

二进制里面的减法是通过加法来运算的，**减去一个数其实就是加上这个数的负数**，计算机为了表示负数，会出现很多问题，**原码、反码、补码**就是为了解决负数问题的（稍后讨论）

二进制加法规则：`0+0=0  1+0=1 1+1=1`

二进制减法规则：`0-0=0 1-0=1 0-1=1(需要向前借位) 1-1=0`

可以看到和十进制一样，只不过十进制有10种状态`0-9`而二进制只有`0-1`两种状态

弄清楚二进制运算只需要转变以前10进制运算观念即可

### 2、二进制乘除

二进制乘法比十进制还简单，运算规则和十进制一样，下面截取**《编码》**里的一张图片说明：

![](https://raw.githubusercontent.com/biningo/cdn/master/img/image-20201024231411557.png)

第一排`1101`叫被**被乘数**，第二排`1011`叫**乘数**

为了更直观感受，将每次乘下来的结果空白部分都补0：

```bash
00001101
00011010
00000000
01101000
--------
10001111
```

CPU乘法器：有`3`个寄存器组成：

- `A`：保存被乘数
- `B`：保存乘数
- `C`：保存结果

下面展示完整流程（假设在8位机器上）：

A：`00001101` B：`00001011` C：`00000000`

- `1*00001101=00001101`=> A：`00011010` B：`00000101` C：`00001101`
- `1*00011010=00011010`=> A：`00110100` B：`00000010` C：`00001101`
- `0*00110100=00000000`=> A：`01101000` B：`00000001` C：`01101000`
- `1*01101000=01101000`=> A：`11010000` B：`00000000`C：`10001111`

所以最终结果就是 `10001111`

除法也和十进制的 **竖式除法** 规则一致，但是底层实现还是比较复杂，我没弄懂QAQ

### 3、总结

加法：加法

减法：取反，加法

乘法：移位，逻辑判断，累加

除法：移位，逻辑判断，累减

其实不必要太纠结底层，以前有段时间我也一直纠结底层，甚至陷入一个无底洞，后面明白了，其实我们只要知道有这么个东西就行了，只要知道CPU里面有这么个东西能实现二进制的加减乘除就行了，其他都不需要我们关心

​    

​    

## 整数的表示：原码、反码、补码

计算机为了表示负数，必须牺牲最高位用来表示正负，比如一个`8位`的`int`：

- 如果是没有符号的，那么就有`8`位可以表示数字，所以范围就是`0-255`
- 如果是有符号的，那么最高位就要拿来充当符号位，所以只有`7`位用来表示数字了，范围就缩小了一半：`-127~127` 但是能表示正负了

这就是 **原码**  原码就是为了将正负表示出来，但是原码有如下几个缺陷：

- `0`有两个【10000000】【00000000】
- 运算不能得出正确结果：【 0001(`1`)+1001(`-1`)=1010 (`-2`) 】正确答案应该为：`0`
- 进行负数运算不方便

为了能够方便的进行正负数运算同时运算不会出错，于是我们将原码进行了一些变化 **符号位不变，数据位相反** （至于为什么要这样其实不用纠结，就是这样QAQ）

【 0110(`1`)+1110(`-1`)=0000  】==> 1+(-1)=0

于是就解决了原码的正负运算问题，这就是**反码**

![](https://raw.githubusercontent.com/biningo/cdn/master/img/891e6b746e9ef18adafc1f478c570326_1440w.png)

反码也有缺点：**0有两种表示方法【0000】【1111】**

为了解决两个0的情况，为了把`1111`这个0去掉，在反码基础上+1

那么1111（反码的`-0`）就会变成`10000`但是这里讨论的只是`4位`，所以`10000`截断之后就是`0000`

**注意：正数都是不变的，和原码一毛一样** 

这就叫： **补码**

![](https://raw.githubusercontent.com/biningo/cdn/master/img/d3617d2ceb02f6129c9b41361804cbe2_1440w.png)

可以看到，上面**正数部分都一样**，负数部分由于原码和反码都有两个0，所以他们表示的范围就是`-7~7` 如果`0`不看的话，正负数个数一样

而补码由于在反码的基础整体往上移动了一格去掉了一个反码的`1111`，下面空了一格，于是就多补了一个`-8`，范围就是`-8~7` `0`看作正数，正负数的个数还是一样

扩大到`8`位的补码表示的整数范围就是`-128~127`（原码是`-217~127`）

​    

​    

## 定点数和浮点数

TODO

## 字节和16进制

TODO

## 字符的表示

ASCII

Unicode

UTF-8

TODO

## 参考

- 《编码：隐匿在计算机软硬件背后的语言》

- https://juejin.cn/post/6844904178259591181#heading-9