```
title: 我眼中的汇编
date: 2021-02-02
categories: [计组和计算机基础]
tags: [基础,汇编,CPU]
draft: true
```

## 汇编语言分类

汇编语言和具体的机器指令相互对应（**这是汇编移植性差的原因**），不同的CPU对应的机器指令集都不一样，因此汇编语言的种类也被分为两大派系：

- **intel汇编(x86汇编)** （语法简洁，符合人类阅读习惯，容易写）
- **ATT&T汇编** （语法稍微复杂，和`C语言`配合丝滑，`Linux`内核中的汇编用此格式）

注意，上面只是汇编语言的风格，就和菜系一样，一个“川菜”，一个 ”粤菜“，具体的语法还和汇编器有关，有如下几个汇编器：

- **masm**：微软写的汇编器，支持`16`、`32`程序，主要用于`windows`平台，已经不再独立发布
- **nasm**：最流行的`Linux`平台汇编器，也可以在`windows`下使用，支持`16、32、64`位程序。和 **nasm**配合的链接器有：**ld**

- **gas**：属于`GNU`下的汇编器，用于汇编`AT&T`格式的汇编，和 `C`比较兼容

汇编器只是将汇编语言翻译为对应平台CPU的机器指令，所以如果是在`intel`的CPU下，那么他们翻译出来的都是`x86指令`

​    

​    

## 什么是大端小端

在写汇编的时候要注意内存数据读取顺序

因为内存是以字节为编址的，但是很多数据类型都会占用多个字节，比如`int`类型占4字节，所以就会有两种排列方式，比如一个`int`类型的数`0x10000002`：

- 高地址放高位，低地址放低位：`0x02` ,`0x00`,`0x00`,`0x01`  这种就叫做**小端模式**
- 低地址放高位，高地址放低位：`0x01`,`0x00`,`0x00`,`0x02` 这种就叫做 **大端模式**

看一看到，大端模式是符合人类阅读习惯的，而小端模式是反的。他们的优缺点如下：

**小端模式优点：**

1. 内存的低地址处存放低字节，所以在强制转换数据时不需要调整字节的内容，直接将后面的截掉就行（比如把int的4字节强制转换成short的2字节时，就直接把int数据存储的前两个字节给short就行，因为其前两个字节刚好就是最低的两个字节，符合转换逻辑）
2. CPU做数值运算时从内存中依顺序依次从低位到高位取数据进行运算，直到最后刷新最高位的符号位，这样的运算方式会更高效

**大端模式优点：**

1. 符号位在所表示的数据的内存的第一个字节中，便于快速判断数据的正负和大小

注意，不同的CPU识别的字节序不同，`x86`系列的CPU采用 **小端模式**，而 `ARM`都可以识别

**TCP/IP协议规定，网络字节序采用大端模式**  如果是`x86`的CPU，发送数据的时候必须要将自己的主机字节序转换为网络字节序 即大端字节序，接收到的数据再转换为自己的主机字节序，底层会提供转换接口，直接调用即可：htons、htonl、ntohs、ntohl等

> **注意：x86系列的CPU都采用小端存储**

​    

## 参考

大小端

- [https://www.a-programmer.top](https://www.a-programmer.top/2020/01/01/为什么存在大端模式小端模式，为什么没有统一成一个标准/)

