---
title: 我眼中的CPU
date: 2021-02-02
categories: [计组和计算机基础]
tags: [基础,汇编,CPU]
draft: true
---

## 什么是CPU架构、指令集、汇编

1. 指令集是人们发明出来的东西，指令就是CPU执行具体操作的一个代号，比如`0000`代表什么指令，`0001`代表什么指令，一条机器指令进过 **指令译码器** 之后就转化为响应的电路信号从而实现特定的操作

2. 指令集决定了处理器的架构，因为**处理器架构就是用硬件电路实现指令集** 

    CPU架构又叫**微架构**，就是由一些硬件电路构成来实现指令集所规定的操作

3. 汇编语言是用人类看得懂的语言符号来描述指令集中的指令，基本一条汇编语句就对应了一条具体的指令，汇编的伪指令不对应CPU指令，只是用来帮助汇编器合理的生成机器代码和优化代码用的

​    

## CPU的前世今生

世界上最著名的CPU厂商有：

- **intel**
- **AMD**（比`intel`晚出现）
- **ARM**

**intel公司**生产的CPU主要有：**8086(16位)、8088、80386、i386(扩展到32位)、i486....**

上面的CPU都是早期生产的CPU，现代的intel CPU主要有：**酷睿>奔腾>赛扬**（性能比较）

<img src="https://raw.githubusercontent.com/biningo/cdn/master/img/v2-73ba36e9a085e8f666d039a1a465e44a_1440w.jpg" style="zoom: 50%;" />

​    

**AMD公司**生产的CPU主要有：**锐龙>AMD FX>APU>速龙>闪龙** （性能比较）

![](https://raw.githubusercontent.com/biningo/cdn/master/img/v2-bc43716167ec0d31ec957022d2442f29_1440w.jpg)

因为`intel`早期生产的CPU都是以`86`结尾的，所以intel的CPU就称为`x86系列`

在`16`位CPU时代，intel的CPU采用了`x86-16`指令集，到了`32`位CPU时代intel采用了`IA32`指令集，所以采用IA32指令集的CPU也称为`x86架构`CPU（**因为指令集决定了CPU底层电路设计和架构嘛**）

当初Intel因为产能不足，IBM要求增加第二供应商，于是Intel将`x86指令集`授权给了AMD等一众厂商，这也是为什么有AMD的存在，intel没有把CPU底层如何实现这些指令的CPU架构告诉AMD，AMD用授权的`x86指令集`设计了自己的CPU，所以intel上运行的软件也可以在AMD上运行

在64位时代intel自己搞了`IA64`（和IA32不兼容，全新的指令集）并且重新设计了CPU架构，AMD搞了`AMD64`（基于IA32）最后IA64因为不兼容IA32而失败，AMD64就变成了现在的`x86-64`又叫`amd64`、`x64`。

因为x86-64的授权在AMD，于是AMD与Intel达成交叉授权，AMD继续使用`x86架构`。这就是为什么现在市面上有AMD和Intel共存的原因，他们都是兼容x86-64架构

`x86指令集(IA32)`（包括`amd64`）是属于 **CISC** 风格的指令集

> RISC和CISC的区别可以看这篇文章：http://www.vsdiffer.com/risc-vs-cisc.html

 **ARM CPU**采用`ARM指令集`，该指令集属于 **RISC** 风格（`MIPS指令集`也是采用此风格）

ARM架构的CPU主要用在**移动设备等小型设备**，因为采用了RISC风格的指令集，所以 **体积小、低功耗、低成本、高性能**

这里总结一下：

- 指令集风格分为：`RISC`、`CISC`
- 著名的CPU指令集：`IA32(x86)`、`amd64/x86_64`(基于IA32,兼容IA32)、`ARM`、`MIPS`
- 著名的CPU厂商：`intel`、`AMD`、生产`ARM CPU`的相关厂商(ARM公司只是发明了指令集并授权给其他公司收专利费，并不生产CPU)
- RISC为代表的指令集：`IA32(x86)`、`amd64/x86_64`
- CISC为代表的指令集：`ARM`、`MIPS`
- **现在RISC和CISC的界限变得模糊了，相互借鉴对方的优点**    

​    

## 什么是大端小端

因为内存是以字节为编址的，但是很多数据类型都会占用多个字节，比如`int`类型占4字节，所以就会有两种排列方式，比如一个`int`类型的数`0x10000002`：

- 高地址放高位，低地址放低位：`0x02` ,`0x00`,`0x00`,`0x01`  这种就叫做**小端模式**
- 低地址放高位，高地址放低位：`0x01`,`0x00`,`0x00`,`0x02` 这种就叫做 **大端模式**

看一看到，大端模式是符合人类阅读习惯的，而小端模式是反的。他们的优缺点如下：

**小端模式优点：**

1. 内存的低地址处存放低字节，所以在强制转换数据时不需要调整字节的内容，直接将后面的截掉就行（比如把int的4字节强制转换成short的2字节时，就直接把int数据存储的前两个字节给short就行，因为其前两个字节刚好就是最低的两个字节，符合转换逻辑）
2. CPU做数值运算时从内存中依顺序依次从低位到高位取数据进行运算，直到最后刷新最高位的符号位，这样的运算方式会更高效

**大端模式优点：**

1. 符号位在所表示的数据的内存的第一个字节中，便于快速判断数据的正负和大小

注意，不同的CPU识别的字节序不同，`x86`系列的CPU采用 **小端模式**，而 `ARM`都可以识别

**TCP/IP协议规定，网络字节序采用大端模式**  如果是`x86`的CPU，发送数据的时候必须要将自己的主机字节序转换为网络字节序 即大端字节序，接收到的数据再转换为自己的主机字节序，底层会提供转换接口，直接调用即可：htons、htonl、ntohs、ntohl等

   

​    

## 冯诺·依曼结构





## 参考

- https://www.zhihu.com/question/20209369
- https://www.zhihu.com/question/32669957
- https://www.zhihu.com/question/322942082/answer/693302774
- https://www.zhihu.com/question/63627218
- https://www.cnblogs.com/bdqns1t22/p/3909053.html、
- http://www.vsdiffer.com/risc-vs-cisc.html
- https://blog.csdn.net/xuesen_lin/article/details/6151120
- [https://www.a-programmer.top](https://www.a-programmer.top/2020/01/01/为什么存在大端模式小端模式，为什么没有统一成一个标准/)

