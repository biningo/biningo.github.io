---
title: 8086CPU和8086汇编
date: 2021-02-02
categories: [计组和计算机基础]
tags: [基础,汇编,CPU]
draft: true
---

## CPU架构、指令集、汇编

1. 指令集是人们发明出来的东西，指令就是CPU执行具体操作的一个代号，比如`0000`代表什么指令，`0001`代表什么指令，一条机器指令进过 **指令译码器** 之后就转化为响应的电路信号从而实现特定的操作

2. 指令集决定了处理器的架构，因为**处理器架构就是用硬件电路实现指令集** 

    CPU架构又叫**微架构**，就是由一些硬件电路构成来实现指令集所规定的操作

3. 因为机器指令都是`01`组成的数字，非常难排错和编程，于是人们就用英文符号来指示一条指令，然后通过汇编程序来将这些符号转化为`01`机器指令

​    

## CPU的前世今生

世界上最著名的CPU厂商有：

- **intel**
- **AMD**（比`intel`晚出现）
- **ARM**

**intel公司**生产的CPU主要有：**8086(16位)、8088、80386、i386(扩展到32位)、i486....**

上面的CPU都是早期生产的CPU，现代的intel CPU主要有：**酷睿>奔腾>赛扬**（性能比较）

<img src="https://raw.githubusercontent.com/biningo/cdn/master/img/v2-73ba36e9a085e8f666d039a1a465e44a_1440w.jpg" style="zoom: 50%;" />

​    

**AMD公司**生产的CPU主要有：**锐龙>AMD FX>APU>速龙>闪龙** （性能比较）

![](https://raw.githubusercontent.com/biningo/cdn/master/img/v2-bc43716167ec0d31ec957022d2442f29_1440w.jpg)

因为`intel`早期生产的CPU都是以`86`结尾的，所以intel的CPU就称为`x86系列`

在`16`位CPU时代，intel的CPU采用了`x86-16`指令集，到了`32`位CPU时代intel采用了`IA32`指令集，所以采用IA32指令集的CPU也称为`x86架构`CPU（**因为指令集决定了CPU底层电路设计和架构嘛**）

当初Intel因为产能不足，IBM要求增加第二供应商，于是Intel将`x86指令集`授权给了AMD等一众厂商，这也是为什么有AMD的存在，intel没有把CPU底层如何实现这些指令的CPU架构告诉AMD，AMD用授权的`x86指令集`设计了自己的CPU，所以intel上运行的软件也可以在AMD上运行

在64位时代intel自己搞了`IA64`（和IA32不兼容，全新的指令集）并且重新设计了CPU架构，AMD搞了`AMD64`（基于IA32）最后IA64因为不兼容IA32而失败，AMD64就变成了现在的`x86-64`又叫`amd64`、`x64`。

因为x86-64的授权在AMD，于是AMD与Intel达成交叉授权，AMD继续使用`x86架构`。这就是为什么现在市面上有AMD和Intel共存的原因，他们都是兼容x86-64架构

`x86指令集(IA32)`（包括`amd64`）是属于 **CISC** 风格的指令集

> RISC和CISC的区别可以看这篇文章：http://www.vsdiffer.com/risc-vs-cisc.html

 **ARM CPU**采用`ARM指令集`，该指令集属于 **RISC** 风格（`MIPS指令集`也是采用此风格）

ARM架构的CPU主要用在**移动设备等小型设备**，因为采用了RISC风格的指令集，所以 **体积小、低功耗、低成本、高性能**

这里总结一下：

- 指令集风格分为：`RISC`、`CISC`
- 著名的CPU指令集：`IA32(x86)`、`amd64/x86_64`(基于IA32,兼容IA32)、`ARM`、`MIPS`
- 著名的CPU厂商：`intel`、`AMD`、生产`ARM CPU`的相关厂商(ARM公司只是发明了指令集并授权给其他公司收专利费，并不生产CPU)
- RISC为代表的指令集：`IA32(x86)`、`amd64/x86_64`
- CISC为代表的指令集：`ARM`、`MIPS`
- **现在RISC和CISC的界限变得模糊了，相互借鉴对方的优点**    

​    

## CPU和总线结构

CPU通过总线于外部进行交互，总线分为三类：

- **数据总线：** 传输数据
- **控制总线：** 传输控制信息比如读、写
- **地址总线：** 传输数据的地址

注意地址读写操作不只是针对主存的，主存只是主板上最重要的一部分，总线还和其他设备接口进行相连的，所以给出的地址不只是主存上的地址，还可能是主板上其他设备的地址，操作这部分地址就相当于操作这些接口的内部存储器等部件，所以逻辑上都可以将 **外设+内存** 看做是一块逻辑空间，所有就有了 **外设映射到内存地址** 这一说法，物理上只是将这些线分配连接到了其他接口部件而已

主板上提供了接口，外设会根据这些接口来设计自己的电路，CPU只需要对这些适配器接口上的存储器控制器进行操作，比如将 **控制信号、数据信号、地址信号** 通过上面的各个类型的总线发送到这些接口中的 **寄存器存储器控制器** 等部件就可以操作外设了，外设就会对这些信号进行解析然后做出响应，比如往显存里面发送数据和控制信号，然后就可以控制屏幕显示内容了

总线的宽度决定了数据的传输量，因为电信号是通过这些导线传出去的嘛

`20`位的地址总线最大的寻址空间就是`2^20=1024k=1M`

`8`位的数据总线一次最大能传送的数据大小就是`2^8=1byte` 如果要传输`1byte`char型数据则只需要一次，要传输`4byte`的`int`型数据则需要`4`次

控制总线宽度则决定了CPU对外设有多少种控制方式和控制命令，主要就是 **读写** 控制

​    

## 8086寄存器和段寻址

`8086`是`intel`最早期的一带16位CPU，所有寄存器宽度都是`16`位的，由于为了兼容之前的`8`位更老的CPU，8086允许将16位的寄存器拆分为2部分，之后的`32、64`CPU都采用这种方式来兼容之前的CPU，比如`AX(16)=AH(8)+AL(8)`

<img src="https://raw.githubusercontent.com/biningo/cdn/master/img/16b4fdd82280e57c.webp" style="zoom: 67%;" />

> **在8086中，将16位也就是2字节称为1字**
>
> 一字=16位=2byte
>
> 双字=32位=4byte
>
> 四字=64位=8byte

8086中采用 `段:偏址` 来寻址，当前执行的指令的地址采用两个寄存器来保存`CS:IP`

由于8086地址总线为`20`位，所以最终地址会进过如下处理：`CS<<4+IP`

段的基地址可以是任意值，但是最终都要 **乘16** 所以可以得出如下结论：

```bash
CS:0x0000 --> 0x00000 第1段首地址
CS:0x0001 --> 0x00010 第2段首地址
CS:0x0002 --> 0x00020 第3段首地址
```

所以一个段的最小大小为：    `16位=2byte`

那么一个段的最大为：`64kb` 也就是段首地址确定之后，段偏移`IP`可变范围就是`0~2^16=64kb`

现在如果将`CS`值设置为最大：

```bash
CS:0xFFFF --> 0xFFFF0 
```

该段之后剩余了`0x0000F`也就是`16位=2byte`空间，如果`IP`的值超过了`16位`那么继续增加`IP`的值就会造成 **地址溢出** ，比如：

```bash
CS:0xFFFF IP:0x000F  --> 0xFFFF0+0x000F = 0xFFFFF #最后一个地址
CS:0xFFFF IP:0x0010 --> 0xFFFF0+0x0010 = 0x100000 #地址溢出
```

因为`8086`的总线宽度只有`20`位，所以就会将`0x100000`截断为`0x00000`，于是又重新回滚到了第0号地址

​    

## 8086汇编

https://github.com/biningo/assembly-play/blob/8086/basic.asm

​      

## PSW寄存器



## 8086中断

`8086` CPU将中断表建立在内存的`00000~003FF`中，发生总断时提供一个中断号然后到表中查找对应的中断表项，找到中断程序（中断程序也可以自己写，只需要放入对应的内存，并且设置中断向量即可，中断向量查找过程由硬件完成）的入口地址，将当前程序的`CS:IP`压入栈，然后将`CS:IP`指向入口地址就执行了中断程序，中断程序执行完毕之后就继续回到当前程序中执行

如果我们要自己添加中断，则只需要在终端表指定的地址中存入中断程序的`CS:IP`连个值，然后将中断程序放入对应的位置即可

我们可以通过`int`指令触发 **软件中断**

```assembly
int 0 ;0号中断
int 02H; 2号中断
```

中断表项大小为2字(32位)，前1字存放IP，后一字存放CS，可以如下设置中断向量表

```assembly
;下面设置第一个表项,最终地址为 0:0200H
mov word ptr 0:[0*4],200H
mov word ptr 0:[0*4+2],0

;设置第3个表项 依次类推
mov word ptr 0:[2*4],300H
mov word ptr 0:[2*4+2],0
```

发生中断时，有如下几个步骤：

- CS、IP、PSW入栈
- 根据中断号查找中断向量，找到中断程序的`CS:IP`
- 设置寄存器`CS:IP`，这样就跳到中断程序入口地址了

如果要给中断程序传值则可以在相应的寄存器中设置值，然后再调用中断程序，中断程序会到指定的寄存器中读取值

​        

## 参考

CPU分类

- https://www.zhihu.com/question/20209369
- https://www.zhihu.com/question/32669957

intel和AMD的关系

- https://www.zhihu.com/question/322942082/answer/693302774
- https://www.zhihu.com/question/63627218
- https://www.cnblogs.com/bdqns1t22/p/3909053.html

RISC和CISC

- http://www.vsdiffer.com/risc-vs-cisc.html
- https://blog.csdn.net/xuesen_lin/article/details/6151120

8086寄存器

- 《汇编语言》(王爽)
- https://juejin.cn/post/6844903866153041928#heading-15



