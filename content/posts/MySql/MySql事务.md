---
title: MySql事务
date: 2021-02-19
categories: [Mysql]
tags: [数据库,MySql] 
---

> **更新中...**

## 事务四大特性ACID

**原子性**  `Atomicity` 

事务是数据库的逻辑工作单位，不可分割，事务中包含的各操作要么都做，要么都不做

**一致性** `Consistency`

同一个事务中所有操作要么全部成功，要么全部失败

**隔离性** `Isolation` 

每个事务都是隔离的，互相不影响，一共有`4`个隔离级别

**持久性** `Durability`

事务一旦提交，它对数据库中的数据的改变就应该是永久性的，不能回滚

​    

## 四大隔离级别

### 1、读未提交

`Read Uncommitted`

一个事务还没提交时，它做的变更对他事务可见

### 2、读已提交

`Read Committed` **Oracle默认的隔离级别**

一个事务只有提交时WW候它做的变化才对其他事务可见，该级别会造成 **在事务中两次读取数据不一致的情况**

- 不可重复读，两次读取的数据值不一样
- 幻读，两次读取的数据条数不一样

### 3、可重复读

`Repeatable Read` **MySql、Innodb默认的隔离级别**

一个事务开始之后，其所看见的数据就是事务开始时候的数据，相当于给数据在事务开始时拍一个快照，在事务执行过程中看见的都是这个快照，即使是其他事务做了变更提交了对此事务也不可见，**解决了不可重复读、幻读问题**

### 4、串行化

事务必须串行化执行，一个事务只有等另外一个事务结束之后才可以开始，效率最低不支持并发，但是解决了事务隔离性的所有问题

​    

## 事务并发读写问题

### 1、脏读

**事务读取到了其他事务还没提交的修改**

`A`事务执行过程中，`B`事务做出的变化还没提交修改就被A事务读取到了，但是`B`事务的修改发生了回滚，那么`A`事务就读取到了脏数据

| 时间线 | 存款事务                                                     | 取款事务                                                     |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1      |                                                              | 开始事务                                                     |
| 2      | 开始事务                                                     |                                                              |
| 3      |                                                              | 查询余额500                                                  |
| 4      |                                                              | 取款400，余额更改为`500-400=100`                             |
| 5      | 查询余额100（脏读）                                          |                                                              |
| 6      |                                                              | 取款操作发生错误，事务失败，执行回滚操作 rollback （使用`commit`或者`rollback`后，事务就结束了） |
| 7      | 存入500，更改余额为`500+100=600`                             |                                                              |
| 8      | 提交事务                                                     |                                                              |
| 9      | 账户出错，按照正确的逻辑此时余额应该为 `500+500=1000`，而此时余额为`600` |                                                              |

### 2、不可重复读

**事务读取到了其他事务已经提交的修改，导致同一个事务两次查询结果不一样**

`A`事务在执行过程中读到了`B`事务已经提交了的修改，造成`A`事务在执行过程中两次读取数据不一致

| 时间线 | 存款事务                                                     | 取款事务                 |
| ------ | ------------------------------------------------------------ | ------------------------ |
| 1      | 开始事务                                                     |                          |
| 2      | 查询余额`500`                                                |                          |
| 3      |                                                              | 开始事务                 |
| 4      |                                                              | 取款`500`，跟新余额为`0` |
| 5      |                                                              | 提交事务                 |
| 6      | 查询余额`0` （发送不可重复读，同一个事务中两次查询结果不一样） |                          |
| 8      | 提交事务                                                     |                          |

### 3、幻读

**幻读是指A事务在执行过程中查询一个范围的记录前后记录查询的结果不一样，会多出一行或则少掉一行，会出现幻行**

为什么会出现A事务前后查询结果不一样呢？因为A事务如果在事务执行过程中可以看见其他事务提交的变更，那么就会产生前后查询记录不一样，所以 **读已提交隔离级别会造成幻读问题**

| 时间线 | 事务A                                           | 事务B        |
| ------ | ----------------------------------------------- | ------------ |
| 1      | 开始事务                                        |              |
| 2      | 第一次查询数据一共100行                         |              |
| 3      |                                                 | 开始事务     |
| 4      |                                                 | 插入50行记录 |
| 5      |                                                 | 提交事务     |
| 6      | 第二次查询数据一共150行（出现了幻行，产生幻读） |              |

其实幻读也是由不可重复读造成的，因为在同一个事务中读取的数据不一致

> **Mysql在RR的隔离级别下是不会产生幻读的**

所以MySql为了避免幻读，默认采用了 **可重复读** 的隔离级别，防止了幻读，因为事务A启动的时候通过`MVCC`建立了一个稳定的视图，事务执行过程中都是使用这个视图，尽管其他事务提交了变更也无法被看见，因为在事务没提交之前都是操作这个视图的

场景一: 插入阻塞

```mysql
#下面有一张表
CREATE TABLE tb(id int PRIMARY KEY NOT　NULL);
INSERT INTO tb value(1);

#启动事务A 查询
begin;
select * from test;
+----+
| id |
+----+
|  1 |
+----+

#启动事务B 增加字段
begin;
insert into tb value(2);
select * from tb;
+----+
| id |
+----+
|  1 |
|  2 |
+----+

#此时事务A是查不到2这条记录的，如果事务A再次重复插入2这条记录作则会发生阻塞，直到事务B提交或阻塞超时，如果插入其他记录则不会发生阻塞，尽管事务B提交了，但是A还是看不到2这条记录
#A
insert into tb value(2); #阻塞 直到事务B提交或则超时,然后报错:主键重复
```

场景二: 更新阻塞

```mysql
#下面有一张表
CREATE TABLE tb(id int PRIMARY KEY NOT　NULL);
INSERT INTO tb value(1);

#启动事务A 更新
begin;
select * from test;
+----+
| id |
+----+
|  1 |
+----+

update set id=88 where id=1;
select * from test;
+----+
| id |
+----+
| 88 |
+----+
commit


#启动事务B (注意B在A还没提交之前就启动了) 更新记录
begin;
#如果事务A没有提交 此时会阻塞 直到A事务提交 因为他们更新了同一条记录
#当A提交之后 再次跟新id=1的记录就会更新失败
update tb set id=99 where id=1; 
select * from tb;
+----+
| id |
+----+
|  1 |
+----+

#事务A提交之后， 当事务B更新id=88这条记录 则会插入一条88的记录 而不是修改原来的记录
#直到事务B提交之后 才会删除原来的记录 1 
update tb set id=77 where id=88;
select * from tb;
+----+
| id |
+----+
| 77 |
| 1  |
+----+
commit; #等事务提交时候 才会删除 1 这条记录 因为RR保证了事务B的执行过程数据都不变
select * from tb;
+----+
| id |
+----+
| 77 |
+----+
```

​    

## MySql隔离级别实现原理

MySql默认开启自动提交事物，也就是说如果没有关闭自动提交则每条语句都是一个事务，Mysql会自动在每条语句执行完毕之后提交事物，而不需要我们显式开启日志提交日志

TODO

​    

## Mysql事务命令

```mysql
SHOW VARIABLES LIKE '%AUTOCOMMIT%';
SET AUTOCOMMIT = 0; #取消事务自动提交 on|off

SHOW VARIABLES LIKE 'transaction_isolation';  #查询当前的事务隔离级别
#修改系统的隔离级别  每次修改之后需要重新连接服务器才能生效
# read uncommitted 读未提交
# read committed 读已提交
# repeatable read 可重复读 (MySql默认的隔离级别，Mysql在此隔离级别下不会)
# serializable 串行化
set global transaction isolation level repeatable read;

begin;
commit;
rollback;


```

​    

## 参考

- https://juejin.cn/post/6844904115353436174#heading-4
- https://www.zhihu.com/question/47007926 【幻读】
- https://blog.csdn.net/mxw2552261/article/details/93263578 