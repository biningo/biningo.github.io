---
title: 常用设计模式总结
date: 2021-04-27
categories: [设计模式]
tags: [设计模式]
---

## 单例模式

单例模式有两种实现方式:

- **饿汉**

    类一加载就创建单例对象,如果对象比较多比较大并且在运行中始终没有用到那么就白白的消耗内存了

    饿汉模式可以通过如下几个方法来实现:

    1. 直接赋予属性值
    2. 静态代码块
    3. Enum枚举(Java推荐方式)

- **懒汉**

    懒汉和饿汉相反，只有当对象用到的时候才创建，但是这种模式需要考虑一个并发问题，如果处理的不恰当的话就会破坏单例而创建出两个对象

    实现饿汉的方式主要有下面几个:

    1. 静态内部类(Java语法特性，只有用到静态内部类的时候类才会被加载)
    2. 方法级别加上同步锁
    3. 双重检查，控制锁的粒度更小

> 上面的单例都会被 **反射** 给破坏，所以Java推荐以Enum方式创建单例来防止反射破坏单例，Java在编译层面防止用反射创建Enum对象

- **容器注册式单例**

    还有一种 **容器注册式单例** ，在Spring中会有一个IOC容器，如果没有显示指定对象需要多个，那么Spring都只会创建一个单例对象并且注册进IOC容器，需要的时候直接去这个容器中获取，如果容器中没有则进行创建并且保存到容器中，如果有则直接从容器中取出来返回，这个容器可以简单的看成是一个`ConcurrentHashMap`

    > 容器注册式单例和对象式单例的区别?

​    

## 工厂模式

工厂模式有三种，三种模式都是逐步演变过来的?

- **简单工厂**

    所有对象的创建都在一个工厂类里，工厂类职责过于复杂

- **工厂方法**

    定义一个工厂接口，每个类都定义一个创建他本身的工厂类，缺点就是工厂类随着类的增加会逐渐增加

- **抽象工厂**

    在工厂方法上面做的一个改进，不为每个类都创建工厂类了，而是只为同一类对象只创建一个工厂类，抽象工厂所关注的是如何创建一系列的类

    比如美的和海尔各自有自己的工厂类，美的工厂只负责创建美的空调、美的冰箱、美的电磁炉等，而海尔工厂只负责创建海尔冰箱、海尔空调、海尔电磁炉等

​    

## 建造者模式

建造者模式和工厂模式的区别在于，建造者模式关注的是创建一个对象的过程，而工厂模式关注的是创建哪个对象

建造者模式相当于对一个类的创建过程的一个封装，将类的创建过程抽象为一个建造者类，这样类本身的构造和实现就分离开来了，我们可以很清晰的通过这个类的建造者类知道这个类是如何被创建的，并且很清晰的看见这个类本身的各个实现代码，而不是看见一坨混乱的代码

在构造者类里面我们还可以做一些参数校验的工作来保证类的正确安全的创建

​    

## 代理模式

代理模式强调的是代替一个类去做一件事，这件事可能需要很多前置准备或则后置收尾工作，这样的话类本身只需要关注自己的事情即可，其他多余的事情多余的前期准备工作都由代理类去完成，代理类会为你准备好一切供你使用

在Java代码中的体现就是 **代理类持有一个被代理的对象，是一种组合的思想**

​    

## 装饰器模式

装饰模式和代理模式的区别在于，装饰模式强调的是 **功能增强**，装饰模式可以在不改变原来代码的情况下增加一些功能，这样就不会破坏原来的代码还可以增加功能，这样就解耦合了

在Java代码中的体现就是 **装饰类需要继承被装饰类，然后重写父类的方法，并且在重写方法里面调用父类方法的同时进行增强** ，当然用组合来实现也是没有问题的

​    

## 门面模式

门面模式强调的是整合多个接口为一个同一简单的接口，就是提供一个公共简洁的接口将多个复杂的接口合并为一个简单易用的接口供外部调用，主要的目的有下面几个:

1. 封装内部细节，提供统一的接口
2. 将多个接口调用合并为一个，比如可以减少网络传输的消耗，前端不需要多次请求，只需要请求一个公共合并的接口进行一次网络通讯即可获取信息
3. 保证事务的原子型，将多个必须共同完成的接口放入到一个统一的接口中进行调用这样就保证了原子型