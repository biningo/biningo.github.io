<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>lyer's blog</title><link>/</link><description>lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Thu, 04 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>打造自己的终端环境</title><link>/2021/02/04/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84linux%E7%BB%88%E7%AB%AF%E7%8E%AF%E5%A2%83/</link><pubDate>Thu, 04 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/04/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84linux%E7%BB%88%E7%AB%AF%E7%8E%AF%E5%A2%83/</guid><description><![CDATA[配置zsh  安装zsh  apt install zsh 安装oh-my-zsh  #https://github.com/ohmyzsh/ohmyzsh sh -c &#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&#34; 运行上面的sh之后，就会在家目录下配置.zshrc文件，当然也可以手动clone仓库代码到，然后按照oh-my-zsh模板文件进行配置.zshrc
配置.zshrc  该文件的作用和.bashrc作用一样，为了不让之前.bashrc的命令失效，可以在.zshrc中source进来，下面展示主要配置
#配置终端主题，不然会很丑 主题路径在.oh-my-zsh/themes 可以修改主题的样式 ZSH_THEME=&#34;robbyrussell&#34; #配置zsh插件 有些系统自带的插件则直接配置即可 #有些外部插件则需要下载(clone)到 .oh-my-zsh/custom/plugins路径下 然后需要在下面写上名字即可 plugins=( git zsh-syntax-highlighting #shell命令高亮插件 colored-man-pages #系统自带 zsh-autosuggestions #命令提示插件 ) ​
配置tmux  安装tmux  apt install tmux 修改配置文件  tmux的配置文件在~/.tmux.conf
个人觉得tmux默认的快捷键不符合自己，那么可以修改，下面展示我的配置文件
#设置快捷键前缀 set -g prefix C-a #修改快捷键前缀 我习惯与ctrl+a unbind C-b # 解绑默认的 ctrl+b 前缀快捷键 bind C-a send-prefix # 绑定Ctrl+a为新的指令前缀 #绑定方向键 bind -r k select-pane -U # 绑定k为↑ bind -r j select-pane -D # 绑定j为↓ bind -r h select-pane -L # 绑定h为← bind -r l select-pane -R # 绑定l为→ #切换切割pane按键 分割窗口要用到 unbind &#39;&#34;&#39; #解绑默认的键 # 垂直方向新增面板，默认进入当前目录  bind ] splitw -v -c &#39;#{pane_current_path}&#39; unbind % # 水平方向新增面板，默认进入当前目录 bind [ splitw -h -c &#39;#{pane_current_path}&#39; ​]]></description></item><item><title>CPU和汇编语言</title><link>/2021/02/02/cpu%E5%92%8C%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</link><pubDate>Tue, 02 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/02/cpu%E5%92%8C%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</guid><description><![CDATA[什么是CPU架构、指令集、汇编   指令集是人们发明出来的东西，指令就是CPU执行具体操作的一个代号，比如0000代表什么指令，0001代表什么指令，一条机器指令进过 指令译码器 之后就转化为响应的电路信号从而实现特定的操作
  指令集决定了处理器的架构，因为处理器架构就是用硬件电路实现指令集
CPU架构又叫微架构，就是由一些硬件电路构成来实现指令集所规定的操作
  汇编语言是用人类看得懂的语言符号来描述指令集中的指令，基本一条汇编语句就对应了一条具体的指令，汇编的伪指令不对应CPU指令，只是用来帮助汇编器合理的生成机器代码和优化代码用的
  ​
CPU的前世今生 世界上最著名的CPU厂商有：
 intel AMD（比intel晚出现） ARM  intel公司生产的CPU主要有：8086(16位)、8088、80386、i386(扩展到32位)、i486&hellip;.
上面的CPU都是早期生产的CPU，现代的intel CPU主要有：酷睿&gt;奔腾&gt;赛扬（性能比较）
​
AMD公司生产的CPU主要有：锐龙&gt;AMD FX&gt;APU&gt;速龙&gt;闪龙 （性能比较）
因为intel早期生产的CPU都是以86结尾的，所以intel的CPU就称为x86系列
在16位CPU时代，intel的CPU采用了x86-16指令集，到了32位CPU时代intel采用了IA32指令集，所以采用IA32指令集的CPU也称为x86架构CPU（因为指令集决定了CPU底层电路设计和架构嘛）
当初Intel因为产能不足，IBM要求增加第二供应商，于是Intel将x86指令集授权给了AMD等一众厂商，这也是为什么有AMD的存在，intel没有把CPU底层如何实现这些指令的CPU架构告诉AMD，AMD用授权的x86指令集设计了自己的CPU，所以intel上运行的软件也可以在AMD上运行
在64位时代intel自己搞了IA64（和IA32不兼容，全新的指令集）并且重新设计了CPU架构，AMD搞了AMD64（基于IA32）最后IA64因为不兼容IA32而失败，AMD64就变成了现在的x86-64又叫amd64、x64。
因为x86-64的授权在AMD，于是AMD与Intel达成交叉授权，AMD继续使用x86架构。这就是为什么现在市面上有AMD和Intel共存的原因，他们都是兼容x86-64架构
x86指令集(IA32)（包括amd64）是属于 CISC 风格的指令集
 RISC和CISC的区别可以看这篇文章：http://www.vsdiffer.com/risc-vs-cisc.html
 ARM CPU采用ARM指令集，该指令集属于 RISC 风格（MIPS指令集也是采用此风格）
ARM架构的CPU主要用在移动设备等小型设备，因为采用了RISC风格的指令集，所以 体积小、低功耗、低成本、高性能
这里总结一下：
 指令集风格分为：RISC、CISC 著名的CPU指令集：IA32(x86)、amd64/x86_64(基于IA32,兼容IA32)、ARM、MIPS 著名的CPU厂商：intel、AMD、生产ARM CPU的相关厂商(ARM公司只是发明了指令集并授权给其他公司收专利费，并不生产CPU) RISC为代表的指令集：IA32(x86)、amd64/x86_64 CISC为代表的指令集：ARM、MIPS 现在RISC和CISC的界限变得模糊了，相互借鉴对方的优点  ​
什么是大端小端 因为内存是以字节为编址的，但是很多数据类型都会占用多个字节，比如int类型占4字节，所以就会有两种排列方式，比如一个int类型的数0x10000002：
 高地址放高位，低地址放低位：0x02 ,0x00,0x00,0x01 这种就叫做小端模式 低地址放高位，高地址放低位：0x01,0x00,0x00,0x02 这种就叫做 大端模式  看一看到，大端模式是符合人类阅读习惯的，而小端模式是反的。他们的优缺点如下：
小端模式优点：]]></description></item><item><title>信息的编码和表示</title><link>/2021/02/01/%E4%BF%A1%E6%81%AF%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%A1%A8%E7%A4%BA/</link><pubDate>Mon, 01 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/01/%E4%BF%A1%E6%81%AF%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%A1%A8%E7%A4%BA/</guid><description><![CDATA[二进制算术运算 二进制的 加减乘除 运算和十进制相似，只不过二进制到2就需要进位，而十进制到10才需要进位而已，其他进制也都类似。
CPU逻辑运算：&amp; | ^(异或) ~(取反) （由相应的与非门等电路组合而成）
CPU算术运算： 加法、位移 （通过上面的逻辑运算实现）
二进制的加减乘除都是通过 加法、位移 组合来实现的，CPU里面实现二进制的算术运算由相应的部件来实现：
 加法器（全加器） 实现加法 除法器、乘法器 实现乘除  1、二进制加减 二进制加法：01+01=10 第一位1+1=0然后需要进位并且需要链式进位，这和十进制一样，加法器基本原理就是：
 异或（不带进位的加法1+1=0 0+0=0） 与 （计算进位,只有1|1==1才会产生进位）如果有进位还必须保存进位参与下一次运算  二进制里面的减法是通过加法来运算的，减去一个数其实就是加上这个数的负数，计算机为了表示负数，会出现很多问题，原码、反码、补码就是为了解决负数问题的（稍后讨论）
二进制加法规则：0+0=0 1+0=1 1+1=1
二进制减法规则：0-0=0 1-0=1 0-1=1(需要向前借位) 1-1=0
可以看到和十进制一样，只不过十进制有10种状态0-9而二进制只有0-1两种状态
弄清楚二进制运算只需要转变以前10进制运算观念即可
2、二进制乘除 二进制乘法比十进制还简单，运算规则和十进制一样，下面截取**《编码》**里的一张图片说明：
第一排1101叫被被乘数，第二排1011叫乘数
为了更直观感受，将每次乘下来的结果空白部分都补0：
00001101 00011010 00000000 01101000 -------- 10001111 CPU乘法器：有3个寄存器组成：
 A：保存被乘数 B：保存乘数 C：保存结果  下面展示完整流程（假设在8位机器上）：
A：00001101 B：00001011 C：00000000
 1*00001101=00001101=&gt; A：00011010 B：00000101 C：00001101 1*00011010=00011010=&gt; A：00110100 B：00000010 C：00001101 0*00110100=00000000=&gt; A：01101000 B：00000001 C：01101000 1*01101000=01101000=&gt; A：11010000 B：00000000C：10001111  所以最终结果就是 10001111]]></description></item><item><title>Python并发和GIL锁</title><link>/2021/01/31/python%E5%B9%B6%E5%8F%91%E5%92%8Cgil%E9%94%81/</link><pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/01/31/python%E5%B9%B6%E5%8F%91%E5%92%8Cgil%E9%94%81/</guid><description><![CDATA[GIL全局解释器锁 在单核时代，Python为了解决多个线程并发访问数据造成数据不安全问题，在语言层面就实现了一种机制，就是给一个进程中的多个并发线程设置一把锁，只有抢到锁的线程才可以在CPU上执行，没有锁的线程只能等待。这样就可以控制在同一时刻内对数据的访问只有一个线程（其实这也无法保证线程安全）所以这把锁就叫做 GIL锁
也就是说Python的多线程并发在单核时代可以有效控制线程安全问题，但是到了多核时代，即使有多个核，同一时刻也只能有一个线程在执行（因为同一个进程内的多个线程中只有一把GIL锁）
比如现在有 a、b、c、d三个线程和1、2、3、4号CPU核，如果是其他语言，则在同一个时刻四个线程可以同时并发的跑在4个核上运行，但是Python因为有了一把GIL锁 现在a抢到锁了，那么b、c、d只能干巴巴的等待a主动释放锁才可以继续抢锁才有机会执行，即使有4个核也无法充分利用，所以语言层面上创建了4个线程但最终也相当于串行执行
def my_task(): i = 0 for _ in range(10000000): i = i + 1 @metric def f1(): for t in range(2): t = threading.Thread(target=my_task) t.start() t.join() @metric def f2(): arr = [] for t in range(2): t = threading.Thread(target=my_task) t.start() arr.append(t) for t in arr: t.join() ​
GIL锁真的安全吗？ GIL锁其实并非安全，线程在下面三种情况下回主动释放锁：
 不间断执行字节码&gt;1000 执行时间&gt;15ms IO操作  现在有一个全局变量count=0，假设t1线程拿到count准备count+=1的时候，t1的连续执行时间恰好&gt;15ms了或则执行的字节码&gt;1000了，此时t1就会主动释放锁，被t2抢到了，t2执行count+=1此时的count==1，后来t1再次执行的时候count=0，count+=1，count==1，正确的结果应该是count=2
也就是说GIL锁并不能百分之百保证线程安全，只有在循环比较短，执行代码比较少的情况下才可以百分之百保证线程安全
count=0 def add_cpu(max_num): global count for i in range(max_num): count+=1 def f5(max_num): arr = [] for t in range(10): t = threading.]]></description></item><item><title>文件系统</title><link>/2021/01/28/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/01/28/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid><description>VFS虚拟文件系统 虚拟文件系统就是给文件系统的实现提供一个接口，好处有下面几个：
为用户进程提供一组操作文件/目录/其他对象的统一方法，方便操作 为下层文件系统的具体实现提供统一的接口，让操作系统能适配多个文件系统 在每个分区上必须安装文件系统，这样操作系统才可以操作磁盘和文件，不然操作系统是无法使用磁盘的，在分区上安装文件系统其实就是增加一些文件系统对磁盘的管理数据，同时将分区划分为一个个数据块，安装文件系统的过程就叫 分区格式化 格式化之后分区的主要结构如下：
1、引导块
存放引导操作系统启动的代码程序，每个分区都有一个引导块，这样可以实现多系统，只需要在MBR或EFI系统上放置一个bootloader，该bootloader就会确定活动分区（通常由用户在启动界面选择启动哪个系统），然后就会跳转到响应的 活动分区中的引导块中加载引导块中的代码到内存进行执行，然后就会加载该活动分区中的操作系统
2、super block 超级块
super block在索引导块后面，主要包含整个文件系统的一些基本元数据：
文件系统设置的数据块大小（一个数据块通常占据整数个扇区比如：8个扇区 4k大小） 文件系统中的数据块数 空闲块数 空闲的inode节点数 &amp;hellip;&amp;hellip;. 操作系统在启动之后就会将super block从磁盘加载到内存，然后建立 super_block对象，该对象是常驻内存的
3、空闲块位图和inode位图
空闲区块位图： 管理整个分区中空闲的数据块，占用多个数据块block
inode位图 ：管理整个分区中inode的使用和分配，占用多个数据块block
4、inode节点区块
是一个数组结构，存放整个文件系统的inode信息，每个inode就代表一个文件，inode节点个数代表该文件系统最多能创建多少个文件，inode节点存放的具体内容在下文inode对象 中说明
​
​
VFS四大对象 super_block inode dentry file 1、super_block 包含了整个文件系统的重要信息：inode个数、数据块大小、数据块个数 常驻内存 每个分区都有一个super_block，多个super_block对象用链表链接，df命令读取的就是所有的super_block，因为常驻内存所以读取数度非常快，所有对文件系统的修改都要修改super_block 每个super_block都有对应自己的操作函数 struct super_block { struct list_head s_list; // 指向所有超级块的链表 const struct super_operations *s_op; // 超级块相关操作的方法 struct dentry *s_root; // 目录挂载点 struct mutex s_lock; // 超级块信号量 int s_count; // 超级块引用计数 .</description></item><item><title>磁盘和分区</title><link>/2021/01/23/%E7%A3%81%E7%9B%98%E5%92%8C%E5%88%86%E5%8C%BA/</link><pubDate>Sat, 23 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/01/23/%E7%A3%81%E7%9B%98%E5%92%8C%E5%88%86%E5%8C%BA/</guid><description>​
磁盘物理结构 盘面：一个机械磁盘有好几个盘面组成，中间有转轴
磁头：盘面正反两面都可以使用，每个盘面都有一个磁头，用来读写这个盘面的数据
磁道：盘面被物理划分为多个磁道
扇区：每个磁道会被划分为多个固定512byte大小的扇区（现在也有4k扇区），扇区是磁盘数据存储的最小单位。整个磁盘0盘面0磁道第一个1扇区最重要，记录了整个磁盘的分区信息和操作系统启动程序，计算机启动之后首先加载第一个扇区的信息到内存
柱面：每个盘面的同一个磁道组成柱面，磁盘的读写顺序就是按照柱面来的，写入时按顺序先写满一个柱面（一个盘面的磁道数据写满后再激活下一个盘面的磁头）然后再移动磁头臂写另外一个柱面，读数据也是按照这个顺序读
磁盘在出厂前需要进行低级格式化：就是给磁盘划分磁道、扇区。这些属于硬件层面，OS无法控制
​
​
磁盘寻址方式 早期所有磁道的扇区个数一样，采用CHS方式寻址，这种划分方式外磁道颗粒稀疏，存储密度小，造成空间浪费
现在的磁盘外磁道的扇区个数大于内道，存储密度都一样了，采用LBA寻址
1、CHS寻址 CHS寻址方式的容量由CHS三个参数决定：(柱面,磁头,扇区)
早期磁盘的每个磁道的扇区数一样多 ，整体磁盘大小也很小。所以在设计时用了24位地址来确定一个扇区：10+8+6
柱面数最大为1024(用 10 个二进制位存储)。从0开始编号（一个盘面最多能划1024个磁道）
磁头数最大为256 (用 8 个二进制位存储)。从0开始编号，(最多有256个盘面)
一个盘面中的扇区数最大数 64(用 6个二进制位存储)
最大寻址空间：1024*256*64*512byte=8414461440 byte = 8G+
2、LBA寻址 现代机械磁盘容量变大，主要有如下几个改变：
磁盘面的磁颗粒更高密+磁头更稳定更细(影响C柱面数) 磁盘面的磁颗粒均匀分布（影响S扇区数） 磁盘增加磁盘盘面（影响H盘面数） 同时采用 LBA逻辑块地址寻址，线性地址，给每个扇区一个编号(0-最后一个扇区号)
LBA将CHS这种三维寻址方式转变为一维的线性寻址，它把硬盘所有的物理扇区(柱面号/盘面号/扇区号) 编号通过一定的规则转变为一维线性的编号，系统效率得到大大提高，避免了 烦琐的(磁头/柱面/扇区)的寻址方式。在访问硬盘时，由硬盘控制器再这种逻辑地址转换为实际硬盘的物理扇区地址
​
​
磁盘分区 1、什么是磁盘分区 磁盘分区就是把一整块磁盘切割为几个部分，相当于 win的 C、E、D盘，Linux的/dev/sda1、/dev/sda2&amp;hellip; 可以把磁盘看做一块原木，分区就是在原木上做一个桌子、椅子</description></item><item><title>SSL-TSL-HTTPS和CA证书</title><link>/2021/01/14/ssl-tsl-https%E5%92%8Cca%E8%AF%81%E4%B9%A6/</link><pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/01/14/ssl-tsl-https%E5%92%8Cca%E8%AF%81%E4%B9%A6/</guid><description>​
对称加密 对称加密就是在两端通信的时候使用同一个密钥进行加密解密
特点：
不够安全，密钥如何传的问题（由非对称加密解决） 加解密的CPU消耗低 相关算法：DES、AES
​
​
非对称加密 非对称加密就是使用不同的密钥进行加密解密，比如使用 公钥 加密，使用 **私钥 **解密
特点：
安全，解决了 对称加密 密钥传输问题 加解密CPU消耗高，需要复杂的数学运算 所以一般使用非对称加密进行传输对称加密密钥，之后用对称加密进行通信
相关算法：RSA、ECC
​
​
信息摘要 摘要主要是为了 防止信息被篡改 ，又称为 信息指纹
字符串、文件等内容经过 摘要算法(hash算法) 进行hash散列之后得到的一串固定长度的 hash字符串 这就是 信息摘要
常见的hash算法有：MD5、SHA256
​
​
数字签名 数字签名是一个非对称加密的方式，私钥签名，公钥解密
A：用自己的A私钥对 摘要 进行加密，加密后的就叫 数字签名 这样摘要在传输过程中就不会被篡改 B：用 A公钥 对 数字签名 进行解密，得到摘要 ，然后再用相同的 信息摘要算法对消息体计算摘要，对比两个摘要是否相同就可以验证消息体是否被篡改 ​
​
CA证书 CA证书 CA证书类似于身份证，用来证明公钥的正确性，证明对方发来的公钥是否属于对方，就比如公安局给公民发放身份证来证明这个人就是你
想象一下如果不验证公钥的正确性的话：
A给B发送自己的公钥时被中间人 C劫持并替换为C的公钥发给B B以为是A的公钥，则继续用C的公钥通信， 那么C就可以劫持所有B给A发送的消息 为了验证发来的公钥是否被劫持，是否属于对方，那么就需要一个第三方权威机构颁发一个CA证书来证明身份</description></item><item><title>docker的volumes踩坑</title><link>/2021/01/07/docker%E7%9A%84volumes%E8%B8%A9%E5%9D%91/</link><pubDate>Thu, 07 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/01/07/docker%E7%9A%84volumes%E8%B8%A9%E5%9D%91/</guid><description><![CDATA[​
挂载volume的行为 volume的挂载是 以宿主机为主 ，主要有如下几个行为可能：
   host container mount result     文件夹不存在/文件夹存在但为空 文件夹不存在/存在但为空/存在且不为空 container中文件被覆盖（清空）   文件夹存在且不为空 文件夹不存在/存在但为空/存在且不为空 container中文件夹内容被覆盖（原内容清空， 覆盖为host上文件夹内容）    ​
将容器已经存在的文件挂载到宿主机 由上面可知，容器中原本存在的文件一旦进过挂载，就一定会被宿主机覆盖，但是有如下几个方法，可以曲线救国：
 docker cp命令先将容器内的数据copy到宿主机然后再进行挂载 在docker-entrypoint.sh等脚本中执行创建文件和文件夹等相关命令，因为挂载行为先与脚本的执行行为，所以在脚本执行的时候已经挂载volume，当脚本创建相关文件的时候就可以反映到宿主机上了  ​
volume相关命令 docker volume ls #查看所有命名和匿名volume docker inspect &lt;volume-name&gt; #查看volume相关信息 docker volume create &lt;volume-name&gt; #创建volume docker volume rm &lt;volume-name&gt; #删除 docker volume preun #清空没有容器挂载中的volume stop中的容器的volume不会清空 #控制volume的读写权限 -v &lt;xxx&gt;:容器内路径:ro #只读 在容器内只能读挂载的文件  -v &lt;xxx&gt;:容器内路径:rw #读写 在容器内能读写挂载文件 默认 ​]]></description></item></channel></rss>