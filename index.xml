<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>lyer's blog</title><link>/</link><description>lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Sat, 01 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>C语言中的柔性数组</title><link>/2021/05/01/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84/</link><pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/01/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84/</guid><description><![CDATA[什么是柔性数组  结构中最后一个元素允许是未知大小的数组，这个数组就是柔性数组
 但结构中的柔性数组前面必须至少一个其他成员,柔性数组成员允许结构中包含一个大小可变的数组，sizeof返回的这种结构大小不包括柔性数组的内存。包含柔数组成员的结构体用malloc函数进行内存的动态分配,且分配的内存应该大于结构的大小以适应柔性数组的预期大小
​
为什么需要柔性数组 C中的结构体都是固定大小的，但是有些时候我们需要一个可变大小的结构体，比如有时候需要在结构体中存放一个长度动态的字符串
typedef struct mystr { int len; //记录字符串长度  char *data;//底层的char数组指针 }mystr; 我们需要为data malloc一段内存，然后通过这个指针访问这段内存。
首先我们按照常规的做法，不做任何处理，直接malloc，如下
typedef struct mystr { int len; char* data; }mystr; int main(int argc, char const *argv[]) { char* c = &#34;hello,world&#34;; //分别分配内存  mystr* s = (mystr*)malloc(sizeof(mystr)); s-&gt;data = (char*)malloc(strlen(c)+1); //+1是为\0分配的 strlen不会将\0计算进来  strcpy(s-&gt;data,c); s-&gt;len = strlen(s-&gt;data); printf(&#34;len:%d data:%s\n&#34;,s-&gt;len,s-&gt;data); //11 hello,world  //分别释放空间  free(s-&gt;data); free(s); return 0; } 可以看到上面的操作比较麻烦，结构体和内部的data指针分配内存和释放内存操作都是分开的，data数据区和结构体不是连续的两块内存，这样会带来两个问题:]]></description></item><item><title>malloc实现原理</title><link>/2021/05/01/malloc%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link><pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/01/malloc%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid><description>TODO
参考 malloc和free的实现原理解析</description></item><item><title>git原理</title><link>/2021/04/30/git%E5%8E%9F%E7%90%86/</link><pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/30/git%E5%8E%9F%E7%90%86/</guid><description>git三大对象 git三大对象分别为:
blob tree commit 下面来讲述这些对象的细节:
blob 记录了文件的实际内容，每次add都会为每个文件生成一个blob，暂存区有个index指针会指向最新add到暂存区的几个blob 每次进行commit时都会生成两个对象: tree和commit
tree 记录了index指针指向的几个blob的hash值还有对应的文件信息和文件权限
commit记录了此次commit的作者信息和对应的tree节点，同时还会记录上一个commits
​
参考 这才是真正的Git——Git内部原理</description></item><item><title>git三大区域</title><link>/2021/04/29/git%E4%B8%89%E5%A4%A7%E5%8C%BA%E5%9F%9F/</link><pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/29/git%E4%B8%89%E5%A4%A7%E5%8C%BA%E5%9F%9F/</guid><description><![CDATA[git三大区域 工作区
工作区就是我们的本地目录
暂存区
暂存区用于暂时存放我们工作区域的更改，比如我们工作区域修改了一个文件，此时就可以先放入暂存区，然后我继续修改这个文件&hellip;&hellip;
改完之后我突然觉得文件这样修改不是很好，还是原来的比较好，想要恢复回原来的样子，此时暂存区就发挥作用了，我们可以将暂存区域的文件覆盖回工作区域，这样就又回到上次暂存的样子了，恢复之后此时暂存区的内容又和工作区域一致了
git add a.txt git restore a.txt #将上次暂存的文件覆盖到工作区 git restore --staged a.txt #取消暂存 也就是清空暂存区 本地仓库
如果确保此次修改就是最终版本，那么我们可以讲暂存区域中的内容提交到本地仓库，此时三大区域就一致了，一次提交就相当于一次版本的发布，以后可以回退到此版本
所以在提交之前需要确保暂存区的内容就是确定了的不会再修改了的
git commit a.txt -m &#34;new a&#34; git reset --hard HEAD^ #回退之后 三大区域也是一致的 git reset a112c #也可以指定特定的版本号 ​]]></description></item><item><title>git优雅的提交</title><link>/2021/04/29/git%E4%BC%98%E9%9B%85%E7%9A%84%E6%8F%90%E4%BA%A4/</link><pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/29/git%E4%BC%98%E9%9B%85%E7%9A%84%E6%8F%90%E4%BA%A4/</guid><description><![CDATA[git commit命令 git commit #进入vi界面编辑 git commit -m &#34;message&#34; #直接输入剪短信息 git commit --amend -m &#34;new a&#34; #修改最近一次的commit信息 ​
commit规范 &lt;type&gt;[optional scope]: &lt;description&gt; &lt;BLANK LINE&gt; [optional body] &lt;BLANK LINE&gt; [optional footer(s)]  标题行: 必填, 描述主要修改的type类型和desc简短描述 主题内容: 描述为什么修改, 做了什么样的修改, 以及开发的思路等详细注释，这是可选的 页脚注释: 放 Breaking Changes 或 Closed Issues 这也是可选的  type 提交类型
   type desc     feat 新特性   fix 修复bug   refactor 代码重构   docs 文档修改   style 代码格式修改   test 测试相关，增加测试用例，修改测试用例   chore 杂项，其它修改，比如依赖管理、CICD等，当然还可以指出具体的比如ci: build   pref 代码优化，各种优化等   sync 同步主线分支   merge/rebase 合并分支    scope 影响范围]]></description></item><item><title>merge和rebase的区别</title><link>/2021/04/29/merge%E5%92%8Crebase%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/29/merge%E5%92%8Crebase%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>merge和rebase的区别 假如下面的分支如下
E---F dev / A---B---C---D master 使用rebase的场景 此时dev为了和master保持同步，则在dev中使用rebase操作，rebase就是寻找公共父节点
C---D--E--F dev / A---B---C---D master 实际上现在的分支图变成了这样
E--F dev / A---B---C---D master 此时在master分支中不管是执行rebase还是merge都是一条线，其实就是将master指针移动到dev指针处
A---B---C---D---E---F dev,master 使用merge的场景 dev为了和master保持同步，于是使用merge
E---F---G dev / / A---B---C---D master 现在master使用merge合并dev
E---F---G dev / / \ A---B---C---D---H master 此时master又开发了几个版本，dev也开发了几个版本
E---F---G---L---M dev / / \ A---B---C---D---H---I---J master 此时dev又要进行和master同步
E---F---G---L---M----K dev / / \ / A---B---C---D---H---I---J master 此时dev需要合并到master中
E---F---G---L---M----K dev / / \ / \ A---B---C---D---H---I---J---P master 看上面merge的图，分支一多就显的很乱</description></item><item><title>为什么数组下标从0开始?</title><link>/2021/04/28/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E4%BB%8E0%E5%BC%80%E5%A7%8B/</link><pubDate>Wed, 28 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/28/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E4%BB%8E0%E5%BC%80%E5%A7%8B/</guid><description>先说答案吧:
历史问题，C语言数组下标使用0，于是之后的语言都使用0 数组的偏移运算规则 历史问题这个不用多说了，下面说一下第二条原因
我们知道数组因为内存都是连续存放的，每个元素的大小都是固定的，所以支持随机访问，我们只需要根据偏移和元素大小来计算出地址即可实现随机任意的访问数组中的元素，所以随机访问效率为 O(1)
数组查找一个元素的效率为O(n)，如果是有序数组查找一个元素使用二分的话那就是O(logn)
a[i]的地址 = a + i * size 我们看到，如果是第一个元素，那么i=0，如果是第二个元素那么i=1 ，这就是为什么数组下标从0开始的原因
但是如果硬要从1开始的话，那么上述的公式就会变成如下:
a[i]的地址 = a + (i-1) * size 这样就会多一次i-1的减法操作，产生不必要的消耗，因为数组可能会进行一个频繁的随机查找</description></item><item><title>链表总结</title><link>/2021/04/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/</link><pubDate>Wed, 28 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/28/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/</guid><description>链表分类 链表主要分为一下几类:
单链表 循环链表 双链表 ​
各个链表比较 开发中最常用的链表就是 循环双链表
循环链表和单链表对比起来，循环链表有如下几个优点:
通过任意一个节点即可以遍历所有的节点 单链表和双链表对比起来，双链表有如下几个优点:
可以轻松获取一个节点的前后节点 双链表的删除和插入节点效率更高更方便 双链表遍历更方便，可以从一个节点开始可以往前往后遍历 ​
链表和数组的比较 随机访问
数组支持随机访问，随机访问的时间复杂度为O(1)，但是链表不支持随机访问，如果要访问指定位置的节点必须遍历前面所有的节点，时间复杂度为O(n)
查找元素
链表和数组查找元素的时间复杂度都是O(n) ，但是对于一个有序的数组可以使用二分查找来加快速度，此时时间复杂度为O(logn)，但是对于链表就没有办法进行二分了
对于元素的插入和删除，链表的时间复杂度为O(1)，而数组则为O(n)，因为数组需要进行元素的移动，链表只需要改变指针即可
总结
如果是需要频繁进行随机访问的时候可以使用数组，如果需要频繁进行增加和删除则可以考虑使用链表</description></item><item><title>Java并发总结</title><link>/2021/04/27/java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/</link><pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/27/java%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/</guid><description>TODO</description></item><item><title>常用设计模式总结</title><link>/2021/04/27/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</link><pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/27/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</guid><description>单例模式 单例模式有两种实现方式:
饿汉式单例
类一加载就创建单例对象,如果对象比较多比较大并且在运行中始终没有用到那么就白白的消耗内存了
饿汉模式可以通过如下几个方法来实现:
直接赋予属性值 静态代码块 Enum枚举(Java推荐方式) 懒汉式单例
懒汉和饿汉相反，只有当对象用到的时候才创建，但是这种模式需要考虑一个并发问题，如果处理的不恰当的话就会破坏单例而创建出两个对象
实现饿汉的方式主要有下面几个:
静态内部类(Java语法特性，只有用到静态内部类的时候静态内部类才会被加载) 方法级加上同步锁 双重检查，控制锁的粒度更小 上面的单例都会被 反射 给破坏，所以Java推荐以Enum方式创建单例来防止反射破坏单例，Java在编译层面防止用反射创建Enum对象
容器注册式单例
还有一种 容器注册式单例 ，在Spring中会有一个IOC容器，如果没有显示指定对象需要多个，那么Spring都只会创建一个单例对象并且注册进IOC容器，需要的时候直接去这个容器中获取，如果容器中没有则进行创建并且保存到容器中，如果有则直接从容器中取出来返回，这个容器可以简单的看成是一个ConcurrentHashMap
容器注册式单例和对象式单例的区别?
下面列出一些具体的应用:
Runtime类使用的就是饿汉式单例，这是一个JVM运行时类，记录了JVM运行时的一些信息比如JVM可用的堆内存，可用的CPU个数等
Spring中会解析XML配置文件然后通过BeanFactory创建单例的Bean对象同时注册到IOC容器中供程序进行DI注入
我们在使用JDBC连接数据库的时候创建的JDBC连接对象是单例的，因为我们连接对象仅仅只是维护了一些连接数据库的参数，查询的时候会根据这些参数创建TCP连接，所以这样的连接上下文对象也只需要一个即可
​
工厂模式 工厂模式有三种，三种模式都是逐步演变过来的?
简单工厂
所有对象的创建都在一个工厂类里，工厂类职责过于复杂
工厂方法
定义一个工厂接口，每个类都定义一个创建他本身的工厂类，缺点就是工厂类随着类的增加会逐渐增加
抽象工厂
在工厂方法上面做的一个改进，不为每个类都创建工厂类了，而是只为同一类对象只创建一个工厂类，抽象工厂所关注的是如何创建一系列的类
比如美的和海尔各自有自己的工厂类，美的工厂只负责创建美的空调、美的冰箱、美的电磁炉等，而海尔工厂只负责创建海尔冰箱、海尔空调、海尔电磁炉等
依赖注入Dependency Injection其实就是用工厂模式来创建对象的</description></item></channel></rss>