<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>lyer's blog</title><link>/</link><description>lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Sun, 21 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Java集合总结和源码浅析</title><link>/2021/03/21/java%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93%E5%92%8C%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/</link><pubDate>Sun, 21 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/03/21/java%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93%E5%92%8C%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/</guid><description>OverView ​
HashMap和HashTable HashMap刚开始是一个Node节点的数组 ，初始化为16大小 如果节点元素个数达到一定的值(这个值略小于 HashTable 的大小)，则会进行扩容
然后逐渐放入元素，刚开始如果发生碰撞就采用 拉链法 进行解决碰撞 ，如果链表的节点个数&amp;gt;=8同时 数组 大小大于64 则会进行树化，转化为 红黑树 来加快查找(红黑树是一颗高度平衡的二叉查找树) 如果链表节点个数大于8但是数组小于64则会进行扩容数组
HashTable和HashMap的主要区别如下:
HashTable是并发安全的，HashMap不安全 HashTable的value不允许null，HashMap允许 ​
ConcurrentHashMap 和HashMap差不多，但是这个是并发安全的
在 JDK1.8 中，ConcurrentHashMap 选择了与 HashMap 相同的数组+链表+红黑树结构，在锁的实现上，采用 CAS 操作和 synchronized锁 实现更加低粒度的锁，将锁的级别控制在了更细粒度的 table 元素级别，也就是说只需要锁住这个链表的首节点，并不会影响其他的 table 元素的读写，大大提高了并发度
​
LinkedHashMap LinkedHashMap能保持插入的顺序，HashMap+双链表 实现
在插入的时候同时给每个节点都按照插入的顺序串成一个双链表(LinkedHashMap给之前HashMap中的链表节点多加了两个前后节点实现)，这样遍历的时候就可以保持插入的顺序了，同时用key取值得时候效率还和 HashMap 一样
​
TreeMap TreeMap使用 红黑树 (一种高度平衡的二叉搜索树) 来实现 K-V 存储，根据搜索树的特性可以保持key有序，这样查找一个key就可以利用二分来快速查找
​
ArrayList、Vector、LinkedList ArrayList
ArrayList底层是一个Object[]数组 在添加元素的时候如果发现容量不足则以初始容量的 1.5倍速度扩容 初始容量默认值是10 ArrayList不是并发安全的 Vector
Vector底层也是Object[]数组 在添加元素的时候如果发现容量不足则以初始容量的 2倍速度扩容 初始容量默认值也是10 Vector是并发安全的，都在方法级别加上了synchronized LinkedList</description></item><item><title>HTTP协议FAQ</title><link>/2021/03/20/http%E5%8D%8F%E8%AE%AEfaq/</link><pubDate>Sat, 20 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/03/20/http%E5%8D%8F%E8%AE%AEfaq/</guid><description>为什么HTTP/1.1协议不支持服务器端推送 HTTP/1.1规定了只能是 请求-响应 模式，为什么这样设计呢，我个人认为主要有如下几个原因:
客户端和服务器容易实现HTTP协议，简单 当时对页面的实时性，数据量没有现在大 当时并发程度不高 浏览器等客户端以及服务器都是根据HTTP协议进行设计的，所以即使HTTP/1.1能保持TCP的keep-alive一直连接并能被多个HTTP请求复用，但是依然无法实现服务器推送
即使你自己的服务器程序实现了HTTP推送，有些浏览器不支持那也没办法，因为大家都是遵循协议来的
即使服务器和客户端都实现了，那么还有很多代理服务器、缓存服务器、CDN服务器等也可能都没有实现这个HTTP推送，所以依赖无法实现推送
所以有了WebSocket协议，浏览器和服务器双方根据HTTP先握手建立TCP连接，然后进行协议升级，双方就可以根据WebSocket协议进行通讯，服务器就可以拿到TCP句柄进行服务器推送了
请求-应答模式带来了两个问题:
队首阻塞 过多的HTTP通讯，往返延迟加大 HTTP/1.1正是因为这个 请求-应答 模式，在一个TCP连接上一个请求发送之后必须等待响应回来之后才可以用这个TCP连接发送另外一个请求，不然浏览器无法识别应答是哪个请求的应答，所以产生了 HTTP报文队首阻塞问题 只要一个请求的应答阻塞了那么这个请求就必须一直等，之后排队的请求也必须等
为了解决 队首阻塞 问题于是浏览器就为每个用户开辟多个TCP连接来并发的发送多个HTTP请求，因为他们使用不同的TCP连接所以浏览器可以识别哪个应答属于哪个请求，但是一个用户如果TCP连接过多比如一个用户有10个TCP连接，那么1000个用户将会产生1000*10=10000个并发连接，这样会造成服务器压力变大，所以浏览器就必须限制每个用户的TCP并发连接数
并且客户端请求一个页面，发现页面里面包含css、js等资源，于是又发起这些资源的请求，这样起码一个页面会产生多次请求，多次请求都会一个个排队等待响应，这样无形之中又加大了延迟，但是如果有服务器推送，那么在第一次客户端请求这个页面的同时就把页面还有css、js等资源一起推送过去，这样就只需要一次请求即可完成，减少了网络传输的HTTP包减少了请求次数，也降低了延迟
​
为什么 HTTP1.1 不能实现多路复用 HTTP不能实现多路复用是因为一个HTTP请求只能在一个TCP连接里面传输，因为HTTP的报文都是文本形式的，并且是不分帧，如果不在一个TCP连接里面传输的话浏览器就无法识别这个报文响应属于哪个请求，服务器必须将响应报文按原路返回回去
HTTP2则可以实现一个HTTP报文可以在不同的TCP连接里面传输，因为HTTP2的报文是二进制形式将HTTP报文分为一个个的数据帧的，并且有 流 的概念来识别一个请求的响应报文</description></item><item><title>Java泛型总结</title><link>/2021/03/20/java%E6%B3%9B%E5%9E%8B%E6%80%BB%E7%BB%93/</link><pubDate>Sat, 20 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/03/20/java%E6%B3%9B%E5%9E%8B%E6%80%BB%E7%BB%93/</guid><description><![CDATA[为什么需要泛型 Java的泛型机制在Java 5.0中加入，为什么需要泛型呢?
在以前没有泛型的情况下，一个 List 类型要能存放所有类型那么底层只能是Object数组来接受所有类型，这样的话我们可以将所有类型都放入这个Lits中，从Lits中获取元素的时候再强转，这样很容易会引发 ClassCastException异常
再来想想，如果不使用Object会怎么样？
这样的话虽然可以避免 ClassCastException异常 但是就要为每种类型都写一个List类，增加了代码量
如果加入泛型之后就不会在运行时引发错误，因为错误都会在编译的时候就发现，泛型的引入能让编译器更好的优化和检查程序的前期错误而不是等到运行的时候再出现错误
并且也不需要为每种类型都写一个List了，直接在new的时候指定类型即可，相当于造了一个代码模具(因为这个代码对于每种类型的操作都是一样的)，使用的使用填充类型即可
总结一下为什么需要泛型:
 强类型，编译器通过泛型实现类型检测，避免运行时类型转换错误，增强代码可读性 对象重用，减少代码量  ​
泛型在Java中的使用 泛型类和泛型方法的案例
public class Pair&lt;T, U&gt; { private T t; private U u; public Pair(T t, U u) { this.t = t; this.u = u; } public T getT() { return this.t; } //泛型可以单独应用在方法上 调用: p.&lt;String&gt;(&#34;one&#34;)  public &lt;E&gt; void echo(E e) { System.out.println(e); } public U getU() { return this.u; } 泛型还可以应用在 接口 上]]></description></item><item><title>Java注解和反射</title><link>/2021/03/20/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</link><pubDate>Sat, 20 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/03/20/java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</guid><description><![CDATA[为什么需要注解 注解也是Java 1.5开始引入的，注解产生是为了替代早期的XML配置文件的，早期使用配置文件XML
其中注解与代码强耦合，一旦改变就需要重新编译，而XML配置文件则和代码分开，修改XML配置文件不需要重新编译因为XML原本就是不编译进字节码中的，Java代码通过文件读取的方式获取XML配置文件的信息
但是注解的优点就是方便简洁好维护，而XML则不方便不容易维护而且配置复杂
​
元注解 元注解 是一种注解在注解上的一种注解，由Java标准库提供，我们自定义注解必须要标注上元注解用于说明这个自定义注解的范围等
元注解有如下4个:
 @Target 表示注解可以注解在方法上还是类上 @Retention 表示注解保留在什么范围 ，一般注解和反射配合使用，所以一般这个值为runtime 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们 @Documented  将注解中的元素包含到 Javadoc 中 @Inherited 子类可以继承父类的注解  ​
自定义注解 如果注解只有一个值，则需要设置为value()这样注解上就不需要key指定了
@Target(ElementType.METHOD) public @interface My { String value() default &#34;&#34;; //可以赋值默认值 } 直接这样使用即可，如果有多个则必须要指定key，没有指定默认值得必须写出值，否则可以不写使用默认值
@My(&#34;A&#34;) 注解也可以定义数组，数组元素只有一个时不需要花括号包裹
@Target(ElementType.METHOD) public @interface My { String value() default &#34;&#34;; String[] names(); } @My(value=&#34;A&#34;,names={&#34;lyer&#34;,&#34;b&#34;}) ​
为什么需要反射 首先来看反射能做什么我们才可以知道为什么需要反射机制了:
 有了反射我们可以在程序运行时动态的加载类，只需要给定类的全路径名即可，而不需要硬编码代码中 反射相当于给了程序员一个后门 可以破坏封装，直接获取一个类的所有属性或则方法，让我们了解一个陌生类的所有属性和方法，知道这个类里面都有什么东西，并且可以创建这个类执行里面的私有方法等  知道反射能干啥之后我们就可以得出为什么需要反射机制了:
  方便测试
  运行时动态加载类，不需要编译时确定写死 (并且有些类无法在编译之前就知道需不需要加载，只有在运行时才知道是否需要加载，这时候就需要反射了，比如数据库驱动，用户可能选择不同的数据库，所以程序需要更具用户的XML配置等来决定加载哪个数据库的驱动)]]></description></item><item><title>Shell脚本基本语法总结</title><link>/2021/03/19/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 19 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/03/19/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</guid><description><![CDATA[变量 变量类型分为:
 全局 (declare或则直接写) 局部(函数内部) local声明 环境变量  只读变量
readonly name=&#34;AAA&#34; #之后再次赋值会报错 #只读变量也可以后来才设置 name=&#34;BBB&#34; readonly name 删除变量 (只读变量不能删除)
name=&#34;AA&#34; unset name if [ -z $name ];then echo &#34;null&#34; else echo &#34;${name}&#34; fi 特殊变量有如下几个类型:
   量 含义     $0 当前脚本的文件名   $&lt;n&gt; 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。   $# 传递给脚本或函数的参数个数。   $* 传递给脚本或函数的所有参数。   $@ 传递给脚本或函数的所有参数。被双引号&quot;&quot;包含时，与 $* 稍有不同   $? 上个命令的退出状态，或函数的返回值，用于判断上一个函数或则命令是否执行成功   $$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。    ${@}和${*} 的区别]]></description></item><item><title>Spring总结</title><link>/2021/03/19/spring%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 19 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/03/19/spring%E6%80%BB%E7%BB%93/</guid><description><![CDATA[Spring控制反转IOC和依赖注入DI 1、XML配置文件DI注入  Set注入  Set注入是调用对应的Set方法来实现的，方法名需要遵循 setName 形式，必须采用小驼峰法，否则无法注入，set注入首先会调用无参构造器创建类
&lt;bean id=&#34;hello&#34; class=&#34;di.model.User&#34;&gt; &lt;property name=&#34;username&#34; value=&#34;lyer&#34;/&gt; &lt;property name=&#34;age&#34; value=&#34;18&#34;/&gt; &lt;/bean&gt; set注入可以注入多个数据类型的属性，常见的有如下几个类型
map array list 基本类型 set bean(对象) @Data public class Student { private Integer id; private String name; private List&lt;String&gt; hobby; private Map&lt;String,Integer&gt; scores; private Set&lt;String&gt; friends; private Address address; } &lt;bean id=&#34;stu&#34; class=&#34;di.model.Student&#34;&gt; &lt;property name=&#34;id&#34; value=&#34;1&#34;/&gt; &lt;property name=&#34;name&#34;&gt; &lt;null/&gt; #显示指定为null 默认不设置值也为null &lt;/property&gt; &lt;property name=&#34;scores&#34;&gt; &lt;map&gt; &lt;entry key=&#34;english&#34; value=&#34;100&#34;/&gt; &lt;entry key=&#34;chinese&#34; value=&#34;99&#34;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&#34;friends&#34;&gt; &lt;set&gt; &lt;value&gt;xioamin&lt;/value&gt; &lt;value&gt;hong&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&#34;hobby&#34;&gt; &lt;list&gt; &lt;value&gt;running&lt;/value&gt; &lt;value&gt;basketball&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; #内联bean 也可以ref引用外部bean &lt;ref bean=&#34;address&#34; /&gt; &lt;property name=&#34;address&#34;&gt; &lt;bean class=&#34;di.]]></description></item><item><title>完全二叉树和满二叉树</title><link>/2021/03/19/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Fri, 19 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/03/19/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>满二叉树 如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树
满二叉树有如下几个性质:
满二叉树第i层节点的个数2^(i-1)
深度为n的满二叉树必须有2^(n)-1个节点，叶子节点有2^(n-1) (也就是最后一层的节点数量)
满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树
具有 n 个节点的满二叉树的深度为 log2(n+1)
第i个节点的左右孩子分别为i*2+1 i*2+2 (孩子节点从0开始算起，如果孩子节点从1开始算起的话就是i*2 i*2+1 )
第i个节点的父亲节点i/2-1 ，如果从1开始算起就是i/2
​
完全二叉树 结点依次从左到右分布，中间无法断开，则此二叉树被称为完全二叉树，完全二叉树适合用数组来存储
第i个节点的左右孩子分别为i*2+1 i*2+2 (孩子节点从0开始算起，如果孩子节点从1开始算起的话就是i*2 i*2+1 )
第i个节点的父亲节点i/2-1 ，如果从1开始算起就是i/2
注意上面的计算要注意范围
堆就是用完全二叉树来实现的</description></item><item><title>Redis命令总结</title><link>/2021/03/16/redis%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</link><pubDate>Tue, 16 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/03/16/redis%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</guid><description>Keys COPY 复制key
COPY name username #name-&amp;gt;username username必须不存在 COPY name username DB 1 #name-&amp;gt;1:username COPY name username REPLACE #存在则更新 DEL 删除key 返回值是删除的个数
UNLINK非阻塞删除，重新开辟一个线程去回收内存，立即返回
DEL key1 key2 EXISTS 查看可以是否存在 返回值是存在键的数量
EXISTS age username EXPIRE EXPIREAT 设置key的过期时间，如果重新设置的key的值，前者是设置n秒后过期，后者设置一个Unix时间戳，表示在指定时间戳后过期
TTL 查看key剩余的时间·秒，返回-1则表示永久 -2则表示key不存在，PTTL则是毫秒
PERSIST 解除timeout时间
EXPIRE name 10 EXPIREAT name 8233132131 TTL name PERSIST name KEYS 模式匹配展示出keys
KEYS name* # * 匹配所有 KEYS name? # ? 匹配一个 MOVE 移动key到指定的db
MOVE age 2 OBJECT 展示redis每个key的对象相关的信息，比如对象底层的数据结构是什么
redis有五大常见对象:</description></item><item><title>TSL(SSL)协议</title><link>/2021/03/16/tslssl%E5%8D%8F%E8%AE%AE/</link><pubDate>Tue, 16 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/03/16/tslssl%E5%8D%8F%E8%AE%AE/</guid><description>什么是TSL协议 因为HTTP传输都是明文传输的，如果被中间人截获，那么报文内容就会被盗取
为了防止HTTP明文传输，于是可以讲HTTP报文和数据整个进行加密然后再将数据传递给下层的TCP层，传递到客户端再进行解密，TSL协议就是解决HTTP报文加密问题的，被TSL协议加密之后的HTTP协议就叫HTTPS HTTP over SSL 使用的是443端口
TSL是SSL的改进版，现在都是使用TSL来替换SSL了，但是延续了老的叫法，所有都叫SSL 这两个其实是同一个意思
TSL现在广泛使用的版本为TSL1.2 TSL1.3
​
TSL握手第一阶段 加密算法有 对称加密、非对称加密 ，如果将HTTP报文采用非对称加密的话那么带来的CPU运算是非常大的，速度也相对较慢，因为HTTP报文一般数据比较大
所以TSL采用对称加密的方式来加密HTTP报文加快加密解密的速度，但是这里就涉及到如何传递 对称密钥 的问题了，这就是 TSL握手 需要解决的问题，就是生成对称密钥
Client Hello TCP建立之后浏览器会先发送一个Client Hello TSL报文给服务器，目的是为了告诉服务器如下内容，重点关注如下内容:
客户端TSL版本 支持的加密套件Cipher Suites : 使用什么加密算法等，服务器会选择一个加密算法 随机字符串Random1 : 这个随机数和之后的生成对称密钥有关 Session ID 用来恢复会话 SessionTicket 客户端保存的TSL的session信息 Server Hello 服务器接受到客户端的Client Hello之后就会检查客户端版本、加密套件等信息，检查通过并且符合服务器的条件则服务器会进行回复，也就是发送Server Hello包
回复内容主要是告诉客户端如下几个重要的内容:
服务器的TSL版本
从Client Hello中选择一个加密套件，告诉服务器选择了哪个套件
随机字符串Random2 此时客户端和服务器都拥有 Random1、Random2
Session ID 初次握手服务器会返回一个Session ID，客户端会保存这个ID，之后再进行握手发送Client Hello的时候就会携带上这个Session ID，服务器就会直接查询Session ID对应的信息比如对称加密的密钥，这样就可以直接复用了就不需要再次生成了，因为生成过程也有一定的消耗</description></item><item><title>WebSocket协议</title><link>/2021/03/16/websocket%E5%8D%8F%E8%AE%AE/</link><pubDate>Tue, 16 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/03/16/websocket%E5%8D%8F%E8%AE%AE/</guid><description>WebSocket要解决的问题 由于HTTP是请求应答模式，所以如果是聊天室这样的项目的话，那么为了立即获取到信息浏览器就必须进行不断的轮询服务器，不仅效率低下，而且还无法立即获取到数据
于是就有了WebSocket协议，WebSocket是通过HTTP协议进行握手然后再进行通讯的，因为浏览器无法同服务器直接建立TCP连接，所以只能先通过HTTP协议建立一个TCP连接通道，之后再升级协议采用WebSocket协议，这样WebSocket就和HTTP采用相同的端口进行和服务器通讯了
ws://www.chrono.com ws://www.chrono.com:8080/srv wss://www.chrono.com:445/im?user_id=xxx #加密的websocket协议 ​
WebSocket握手 WebSocket握手是通过HTTP协议进行的
首先浏览器请求升级协议
GET /xx HTTP/1.1 Connection: Upgrade Upgrade: websocket Sec-WebSocket-Key: sdadsxxada== Sec-WebSocket-Version: 13 Sec-WebSocket-Key 是一个 Base64的16byte的随机数 用于简单认证，防止误连
然后浏览器返回101响应
HTTP/1.1 101 Switching Protocols Sec-WebSocket-Accept: dsdada Sec-WebSocket-Accept 是把请求头里Sec-WebSocket-Key的值，加上一个专用的 UUID “258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，再计算 SHA-1 摘要，客户端接受到响应之后使用相同的方法计算出摘要然后判断是否相等，相等表示认证成功
握手成功之后传递的就是WebSocket报文了
​
WebSocket报文格式 域 说明 FIN 1bit，是否为信息的最后一帧 RSV 1-3 1bit，备用，默认为0 opcode 4bit，帧类型 1 表示帧内容是纯文本，2 表示帧内容是二进制数据，8 是关闭连接，9 和 10 分别是连接保活的 PING 和 PONG MASK 1bit 掩码，是否用XOR进行简单加密数据。 客户端发送给服务端时，mask必须为1，否则断开连接。 服务端发送给客户端时，mask必须为0，否则断开连接。 payload length 表示帧的长度。它是另一种变长编码，最少 7 位，最多是 7+64 位，一个 WebSocket 帧最大是 2^64 Masking-key 0或32 bit掩码值(Mask为1时才有)，是一个4byte的随机数 Playload data 长度为Payload len的数据，如果有掩码，需要用Masking-Key来异或解密 ​</description></item></channel></rss>