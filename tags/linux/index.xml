<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Linux - 标签 - lyer's blog</title><link>/tags/linux/</link><description>Linux - 标签 - lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Sat, 03 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="/tags/linux/" rel="self" type="application/rss+xml"/><item><title>操作系统中的各种栈</title><link>/2021/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%88/</link><pubDate>Sat, 03 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%88/</guid><description>栈的作用 程序中栈的作用主要有如下:
局部变量的空间快速分配和释放 函数调用与返回 保存状态，以便恢复 在函数里面的变量都属于局部变量，函数调用结束，出了函数这个局部遍历就没有用了，那么其空间也不需要保留了
所以栈可以在函数调用时快速分配局部变量的内存地址，而在函数调用结束之后可以立即销毁，所以在C语言中不能在函数中返回局部变量的指针，这样会造成 悬挂指针 问题，因为在函数返回时其地址就已经被回收了
栈还有另外的作用就是嵌套函数调用，比如 递归，其实就是一层层的函数调用栈，所以所有的递归代码都可以用 迭代 来改写
栈还在 中断处理 中发挥着中断恢复的作用，进程在发生中断的时候会将进程当前的寄存器状态和当前的PC指针都压入内核栈然后开始执行中断处理代码，中断处理也是使用这个内核栈的，等中断处理完毕之后就弹出内核栈恢复寄存器继续回到之前的代码中执行
​
线程栈和进程栈 Linux的进程和线程其实都是同一个结构体task_struct来表示，Linux并没有线程的概念，只是Linux的进程有父进程子进程的概念，有一颗进程树
Linux的线程也叫轻量级进程，Linux通过多个进程共享内存空间来实现进程中的多线程
主线程就是创建进程的那个执行流，而子线程都从主线程也就是进程中fork出来，只是fork之后相当于copy，所以他们能共享内存空间等其他资源(包括文件描述符等)这样就可以实现线程的效果了
虽然他们内存空间都一样，很多资源都是一样的，但是各个线程之间的stack还是需要fork之后重新改变的，多个线程之间必须使用独立的栈，因为他们都是不同的执行流，是并行执行的，而不是向函数一样一层层嵌套的
如果线程栈都使用同一个的话那么如果发生线程切换调度，原来线程的执行过程中保存在栈中的数据就会被破坏掉，或则不是他想要的数据了
线程的stack大小是固定的，是从父进程的堆空间映射过来的，也就是说线程的栈开辟在父进程的堆中
linux创建线程都是使用fork，必须要有一个父进程(第一个用户进程init进程1号进程是由操作系统在初始化时创建的，第一个内核级进程是2号进程)，如果是创建线程则直接共享内存空间改变stack和PID、PPID等一些主要的信息即可，如果是创建进程则需要重写进程映象，加载可执行文件重新建立属于自己的内存地址空间，重新建立页表映射
​
进程内核栈 操作系统会为每个进程都创建内核栈，此栈用于系统调用、中断等发生特权级转换执行内核代码使用，在发生中断引发特权级别转化时，操作系统会将进程触发中断时的上下文都压入内核栈以便能继续回到用户态，然后在执行内核代码
注意内核栈是和PCB一起管理的，也就是说一个PCB包含了内核栈，内核栈大小是固定的
内核栈也是必须要独立的，为什么内核栈不能使用进程的栈呢?
这主要是为了保护内核，内核级的数据不允许出现在用户级空间上
哪为什么要为每个进程都建立一个内核栈呢?
这主要是为了防止进程调度之后导致的问题，就像每个线程不能共享进程栈一样，一个进程即使陷入内核了还是会发生进程调度，因为进程陷入内核还是在这个进程范围内为这个进程服务
为什么进程和子线程需要独立的内核栈?
这个问题其实和上面那个重复了，进程(也就是主线程)和子线程的内核栈也必须在独立的，同样为了防止线程调度引发的数据破坏问题 ，这个很好理解，因为Linux线程其实就是进程模拟出来的，那么自然在陷入内核时必须为其创建独立的内核栈
​
参考 Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈</description></item><item><title>进程状态恢复</title><link>/2021/04/03/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D/</link><pubDate>Sat, 03 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/03/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D/</guid><description>系统调用和中断时的状态恢复 发生系统调用的时候，需要发生 特权级转化 ，这样才可以指向内核代码执行系统调用代码等，这时候也需要保存进程的状态，因为系统调用或则中断处理完毕之后需要回到之前的用户进程继续执行
操作系统会为每个进程分配一个 内核栈，此栈每个进程都有并且内核栈大小是固定的，其地址空间保存在PCB中，也就是 task_struct中，方便和PCB一起管理
内核栈用于存放一些系统调用执行的数据等，因为系统调用执行的代码也需要用到栈，因此为了在系统调用结束之后还可以继续回到之前的位置执行于是在发生系统调用之前需要将进程相关的上下文信息都压入内核栈中，比如 PC指针、各个寄存器值、堆栈指针等 因为进入内核态之后堆栈也会发生变化，所以这里需要保存进程之前的堆栈信息
**注意，发生中断时进程的 **CR3 寄存器是不会改变的也不需要保存，此寄存器保存了用户进程的页表，因此操作系统可以根据这个页表将内核空间的数据copy到用户空间(内核态和用户态的数据有两个系统调用函数: copy_to_user和copy_from_user)
因为用户的页表永远都有操作系统的地址映射，所以不影响内核代码的执行
上下文信息保存完毕之后，就可以执行内核代码了，内核代码指向完毕之后栈相关数据也空了，然后继续恢复之前在栈底保存的进程上下文信息即可，这样就可以继续回到进程中断前的代码去执行了
​
进程调度时的状态恢复 发生进程调度时需要将进程当前的所有信息都保存在task_struct中，以便下次被调度之后可以继续恢复之前的状态，比如恢复 页表、PC指针、栈指针、各个寄存器值、进程页表 等
进程调度发生的上下文切换是比 中断 引发的上下文切换代价要大的，因为进程调度还需要切换页表加载页表清空TLB缓存等操作，而中断是在一个进程内引发并且中断完毕之后需要继续回到之前的进程，相当于在进程中调用了系统内核函数一样只不过调用系统函数执行内核代码需要转化特权级和内核堆栈等，还有很多进程的信息是不需要切换的
​
参考 进程切换与系统调用(中断和异常)切换哪个耗时耗资源多
Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈</description></item><item><title>Linux中的VFS虚拟文件系统</title><link>/2021/04/02/linux%E4%B8%AD%E7%9A%84vfs%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Fri, 02 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/02/linux%E4%B8%AD%E7%9A%84vfs%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid><description>为什么磁盘需要分区分块 1、磁盘为什么要分区 磁盘分区的主要就是划分几个大块，每个分区里面可以安装不同的底层文件系统，分区之间都是独立的，也可以在不同的分区上安装不同的操作系统，就好像把磁盘容量看成一整块，然后在这个一整块上进行划分几个区域(当然只划分一个区域也是可以的)
分区主要有一下几个优点:
方便数据管理 隔离数据，保证数据安全，不同分区之间数据互不干扰，分区之间独立 加快数据查找：因为文件系统会将磁盘分成一个个的数据块，单个文件数据可能是存放在不连续的块中，如果分区太大，某个文件数据块分散的存在开头和结尾那么磁头臂的移动就会非常频繁造成读取效率低下，所以一个分区的大小不能划分太大，如果磁盘容量很大的话则可以多划分几个分区 可以在一台计算机上不同的分区上安装不同的操作系统、不同的文件系统，实现双系统等 2、磁盘为什么要分块 机械磁盘读写数据是以 扇区 为单位的，一个扇区大小为512字节或则4kb
扇区是抽象的概念，物理上是没有的，物理上只有盘片，一张盘都是一整块的，只是物理部件在读写的时候是以这个为单位读写的，所有文件的容量大小必须是扇区数量的整数，需要按照扇区大小对齐
SSD固态硬盘没有盘片的概念，但也有数据单元和数据页的概念，SSD相当于内存一样但是可以持久化，每个数据单元就是1byte，同时一个数据页就包含了多个数据单元，SSD读写的基本单位就是数据页，也是需要做到数据页对齐的
但是物理划分的区块太小了，如果一个文件按照物理区块进行存储的话，因为保存文件的区块不一定连续(如果连续的话会造成碎片问题，所以都是分散存放然后建立索引表)，所以读写一个文件会造成IO次数太多造成而造成效率太低
所以底层的文件系统再次进行了重新划分区块大小，一个数据块对应着物理上 连续的几个扇区或则几个数据页，文件存储的基本单位就是以文件系统划分的数据块为单位的，数据块大小一般和内存页大小一致，方便与内存数据进行交换
如果需要读一个文件，则需要找到保存文件所有数据块的索引表，此表由操作系统和文件系统维护，这些数据块之间可能是分散的，虚拟块是连续的，需要读写哪部分则按照偏移然后加载对应的数据块到内存然后进行读写，这个和内存虚拟地址思想一样
​
ext4文件系统 1、ext2 ext3 这就是最简单的ext2、ext3的底层结构，具体的区别不深究了，大概就是这样，跳出细节才更有利于学习
引导块 存放引导操作系统启动的代码程序，每个分区都有一个引导块，这样可以实现多系统，只需要在MBR或EFI系统上放置一个bootloader，该bootloader就会确定活动分区（通常由用户在启动界面选择启动哪个系统），然后就会跳转到响应的 活动分区中的引导块中加载引导块中的代码到内存进行执行，然后就会加载该活动分区中的操作系统
superblock超级块 super block在索引导块后面，主要包含整个文件系统的一些基本元数据，可以说一个super block就代表了一个文件系统，因此此块一般会进行备份，因为如果这里面的数据被销毁了那么这个磁盘就没办法使用了，里面的数据就无法读取了，该块主要保存如下几个数据:
文件系统设置的数据块大小(一个数据块通常占据整数个扇区比如：8个扇区 4k大小) 空闲块数 空闲的inode节点数 &amp;hellip;&amp;hellip;. 操作系统在启动之后就会将super block从磁盘加载到内存，然后建立 super_block对象，该对象是常驻内存的
空闲块位图和inode位图 空闲区块位图bitmap
管理整个分区中空闲的数据块，占用多个数据块block
inode位图bitmap
管理整个分区中inode的使用和分配，占用多个连续的数据块block，如果inode分配完了就无法再创建文件了
inode节点区块 是一个数组结构，存放整个文件系统的inode信息，每个inode就代表一个文件，inode节点个数代表该文件系统最多能创建多少个文件
注意，inode的大小是固定的，每个inode节点的大小，一般是128字节或256字节，用于标识一个唯一的文件，所以没有保存文件名，文件名保存在文件对应的目录文件的data block中
inode 节点主要包括了以下信息：
文件的inode ID 文件权限信息 所有者 ID、组 ID 文件大小（字节数）、文件类型 文件的硬链接数 上次访问时间、最后修改时间、inode 上次修改时间 文件的数据块block映射表 ext文件系统的数据保存的数据块是分散的(为什么要分散前面说了)，为了找到这些数据所以需要建立索引表，索引表如果都放在inode结构上，那么如果文件太大则索引表就会变的很大，但是inode大小是固定的，所以ext3文件系统采用了如下多级索引的方式，inode一共保存了15个索引项在inode中，如果文件很小则前面几个索引项直接指向真实的数据块，如果文件很大那么后面索引项指向的数据块就不是保存数据了而是保存索引信息了，相当于二级索引，每个数据块又能保存256个索引项，如果文件还很大则又会建立三级索引、四级索引等</description></item><item><title>中断</title><link>/2021/03/24/%E4%B8%AD%E6%96%AD/</link><pubDate>Wed, 24 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/03/24/%E4%B8%AD%E6%96%AD/</guid><description>中断分类 中断按照是否由CPU内部发生分为:
外部中断 (由CPU外部引发，比如外设、网卡等) 内部中断 (由CPU内部引发，比如系统调用) 外部中断分为:
可屏蔽中断 (比如网卡发出数据读取中断，可以屏蔽) 不可屏蔽中断 (比如掉电、设备损坏等) 内部中断分为:
软中断 (由软件程序触发，比如系统调用0x80号中断) 异常 (异常也是一种特殊的中断，比如除0异常、缺页异常) ​
中断产生和调用过程 触发中断其实就是给出一个 中断号 ，然后CPU根据中断号去查找中断对应的程序进行执行的一个过程
操作系统会设置一个 IDT中断描述符表 ，里面记载了各个中断号对应的程序的入口地址，操作系统内核在运行初始化的时候必须初始化 中断寄存器指向的位置 ，因为一旦发生中断CPU就会去中断寄存器指向的IDT中去寻找中断程序
发生中断时用户态就会转化为内核态，CPU会保存程序当前执行的状态，比如会将栈指针、各个寄存器值、PC指针压入内核栈，然后开始执行中断处理程序，执行完毕之后再恢复现场，也就是将栈中的值都出栈然后放到各个寄存器中继续执行之前的代码
这里需要注意中断的进程状态管理和进程调度的进程状态管理这两个是不一样的
中断发生时的进程状态是保存在内核栈中，而进程调度发生时需要将进程的状态保存在PCB中
那么这个中断是如何引发的呢?
软中断和异常容易理解，CPU有一个int指令，后面跟给一个中断号，程序只需要执行这个指令即可触发软中断或异常，最常见的软中断就是int 0x80中断，此中断是系统调用中断，所有的系统调用都会触发这个中断，系统调用中断还需要给出 系统调用号 ，系统调用中断处理程序会根据系统调用号去执行相应的系统调用代码
外中断需要经过一个叫 中断代理 的硬件，该硬件连接了所有外设接口的中断线，外设如果需要引发中断则只需要往这个中断线里面传输信号到中断代理即可，中断代理会根据不同的信号转化为相应的 中断号 ，中断代理和CPU只连接了两条线: INTR和NMI INTR表示可屏蔽中断，比如网卡发出的中断、NMI表示不可屏蔽中断
可屏蔽中断的话只需要CPU设置状态寄存器中相应的位就表示屏蔽这些中断，注意: 软中断、异常都是会忽略该位的 也就是说软中断和异常都是不可屏蔽的，软中断通常来说是系统调用，用户进程需要系统调用则操作系统必须响应，否则会造成用户程序卡死无法获得操作系统提供的帮助，会造成用户体验不好，异常更不用说了，需要立即处理
中断代理将相应的中断号输出到INTR线中通知CPU，CPU没执行一条指令都会检查该线是否有中断信号(注意:CPU检查中断是由硬件电路来实现的，并不会有任何的损耗)
如果有中断信号则CPU会立即检测到
​
中断的上半部分和下半部分 一个中断程序可以分为 上部分和下部分 ，中断处理时可以先执行上半部分，这个部分一般来说比较紧急，等CPU空闲之后再继续执行下半部分
比如网卡发出数据读取操作，此时CPU先执行上半部分的中断程序：先将网卡缓存区里的数据拷贝到内核数据区，这个网卡就不会因为缓存区满而频繁丢包了(相当于一个紧急救火)，然后等CPU空闲了之后再执行中断下半部分，也就是将内核数据区域的数据拷贝到用户空间供用户使用
​
操作系统时钟中断 这个时钟和CPU的时钟不是一个概念，但是他们的功能都是差不多的，都是为了使操作系统或则CPU能正确的工作，时钟就相当于一个 节拍器，很多硬件设备也有时钟，为的就是让各个电路有序的进行操作
操作系统的时钟中断由 可编程的脉冲器 产生的，因为操作系统需要和硬件配合的，所以一般和硬件结合的比较紧密，该硬件脉冲频率是和操作系统厂商商量好的，并且可以人为的编程去改变脉冲的频率
时钟中断会定时的引发然后传递到CPU的NMI引脚，时钟中断属于不可屏蔽中断
时钟中断的作用非常大，可以说没有时钟中断操作系统就没有控制权，时钟中断的作用如下:
更新系统的时间 定时的将控制权转移到操作系统的程序中，以便操作系统进行各个调度工作比如进程时间片调度，每经过一个时钟则时间片减一 (如果没有时钟中断，那么如果用户程序如果一直不进行系统调用、不引发异常那么操作系统可能永远也拿不到CPU的控制权) ​</description></item><item><title>Shell脚本基本语法总结</title><link>/2021/03/19/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</link><pubDate>Fri, 19 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/03/19/shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</guid><description><![CDATA[变量 变量类型分为:
 全局 (declare或则直接写) 局部(函数内部) local声明 环境变量  只读变量
readonly name=&#34;AAA&#34; #之后再次赋值会报错 #只读变量也可以后来才设置 name=&#34;BBB&#34; readonly name 删除变量 (只读变量不能删除)
name=&#34;AA&#34; unset name if [ -z $name ];then echo &#34;null&#34; else echo &#34;${name}&#34; fi 特殊变量有如下几个类型:
   量 含义     $0 当前脚本的文件名   $&lt;n&gt; 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。   $# 传递给脚本或函数的参数个数。   $* 传递给脚本或函数的所有参数。   $@ 传递给脚本或函数的所有参数。被双引号&quot;&quot;包含时，与 $* 稍有不同   $? 上个命令的退出状态，或函数的返回值，用于判断上一个函数或则命令是否执行成功   $$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。    ${@}和${*} 的区别]]></description></item><item><title>Linux常用命令总结</title><link>/2021/02/23/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</link><pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/23/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</guid><description><![CDATA[持续跟新&hellip;..
 进程相关 进程的信息都在/proc下
ps ps 显示系统进程
ps -ef ps -aux ps -ef | grep sshd jobs fg bg &amp; nohub &amp; jobs fg bg nohub
./exe &amp; #后台运行 ./exe &gt; log.txt 2&gt;&amp;1 &amp; #0:标准输入 1:标准输出 2:标准错误 2&gt;&amp;1是将标准出错重定向到标准输出 最终结果就是`标准输出`和`错误`都被重定向到`log.txt`中 etcd &gt; /dev/null 2&gt;&amp;1 &amp; #后台运行 同时输出日志重定向到垃圾桶 nohup etcd &gt; /dev/null 2&gt;&amp;1 &amp; #以守护进程方式运行 不会随着终端退出而退出 jobs #查看后台运行中的进程 #ctrl+z暂停任务 ctrl+c终止任务 fg 1 #将后台任务放到前台执行 bg 1 #将一个暂停的任务放在后台执行 kill kill killall
kill -9 1111 #强制终止 killall 1111 #杀死进程 以及所有子进程 pstree pstree 显示进程树]]></description></item><item><title>vmware配置一台ubuntu-server</title><link>/2021/02/15/vmware%E9%85%8D%E7%BD%AE%E4%B8%80%E5%8F%B0ubuntu-server/</link><pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/15/vmware%E9%85%8D%E7%BD%AE%E4%B8%80%E5%8F%B0ubuntu-server/</guid><description>配置步骤 ubuntu阿里镜像站：http://mirrors.aliyun.com/ubuntu-releases/
ubuntu配置阿里云软件源：https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.3e221b11Zy3CPT
更新软件源头
$ apt update 重置root密码：
$ su passwd 设置允许以root身份ssh登入，设置PermitRootLogin yes：
$ vim /etc/ssh/sshd_config #设置PermitRootLogin yes $ service ssh restart #重启ssh服务 静态IP和网络相关的设置
$ vim /etc/netplan/00-installer-config.yaml ---------------------------------------------- # This is the network config written by &amp;#39;subiquity&amp;#39; network: ethernets: ens33: #网卡名字 addresses: - 192.168.1.10/24 #IP dhcp4: false #关闭DHCP gateway4: 192.168.1.1 #设置网关 4表示ipv4 nameservers: #设置DNS addresses: - 192.168.1.1 version: 2 ------------------------------------------------- $ netplan apply #应用配置 发送宿主机公钥给vmware虚拟机，允许宿主机免密登入虚拟机
ssh-copy-id -i ~/.ssh/id_rsa.pub root@u ​</description></item><item><title>打造自己的终端环境</title><link>/2021/02/04/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84linux%E7%BB%88%E7%AB%AF%E7%8E%AF%E5%A2%83/</link><pubDate>Thu, 04 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/04/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84linux%E7%BB%88%E7%AB%AF%E7%8E%AF%E5%A2%83/</guid><description><![CDATA[配置zsh  安装zsh  apt install zsh 安装oh-my-zsh  #https://github.com/ohmyzsh/ohmyzsh sh -c &#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&#34; 运行上面的sh之后，就会在家目录下配置.zshrc文件，当然也可以手动clone仓库代码到，然后按照oh-my-zsh模板文件进行配置.zshrc
配置.zshrc  该文件的作用和.bashrc作用一样，为了不让之前.bashrc的命令失效，可以在.zshrc中source进来，下面展示主要配置
#配置终端主题，不然会很丑 主题路径在.oh-my-zsh/themes 可以修改主题的样式 ZSH_THEME=&#34;robbyrussell&#34; #配置zsh插件 有些系统自带的插件则直接配置即可 #有些外部插件则需要下载(clone)到 .oh-my-zsh/custom/plugins路径下 然后需要在下面写上名字即可 plugins=( git zsh-syntax-highlighting #shell命令高亮插件 colored-man-pages #系统自带 zsh-autosuggestions #命令提示插件 ) 可以为zsh也配置wakatime来统计你在终端上的时间
https://github.com/sobolevn/wakatime-zsh-plugin pip install wakatime waketime的python cli程序也需要安装，其地址如下:
https://github.com/wakatime/wakatime ​
配置tmux  安装tmux  apt install tmux 修改配置文件  tmux的配置文件在~/.tmux.conf
个人觉得tmux默认的快捷键不符合自己，那么可以修改，下面展示我的配置文件
#设置快捷键前缀 set -g prefix C-a #修改快捷键前缀 我习惯与ctrl+a unbind C-b # 解绑默认的 ctrl+b 前缀快捷键 bind C-a send-prefix # 绑定Ctrl+a为新的指令前缀 #绑定方向键 bind -r k select-pane -U # 绑定k为↑ bind -r j select-pane -D # 绑定j为↓ bind -r h select-pane -L # 绑定h为← bind -r l select-pane -R # 绑定l为→ #切换切割pane按键 分割窗口要用到 unbind &#39;&#34;&#39; #解绑默认的键 # 垂直方向新增面板，默认进入当前目录  bind ] splitw -v -c &#39;#{pane_current_path}&#39; unbind % # 水平方向新增面板，默认进入当前目录 bind [ splitw -h -c &#39;#{pane_current_path}&#39; tmux的基本命令这里分享一个链接，可以速查一些相关的命令: https://gist.]]></description></item></channel></rss>