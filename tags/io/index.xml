<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>IO on lyer's blog</title><link>/tags/io/</link><description>Recent content in IO on lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Thu, 01 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="/tags/io/index.xml" rel="self" type="application/rss+xml"/><item><title>IO模型</title><link>/2021/04/01/io%E6%A8%A1%E5%9E%8B/</link><pubDate>Thu, 01 Apr 2021 00:00:00 +0000</pubDate><author>icepan@aliyun.com (lyer)</author><guid>/2021/04/01/io%E6%A8%A1%E5%9E%8B/</guid><description>直接IO和非直接IO 磁盘 I/O 是非常慢的，所以 Linux 内核为了减少磁盘 I/O 次数，在系统调用后，会把用户数据拷贝到内核中缓存起来，这个内核缓存空间也就是页缓存，只有当缓存满足某些条件的时候，才发起磁盘 I/O 的请求
直接 I/O: 不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。 非直接 I/O: 读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘 内核会在一下几种情况下对真实的磁盘进行读写:
内核缓存区满了 用户主动调用sync 缓存数据超过指定时间 &amp;hellip;. ​
缓冲IO和非缓冲IO 缓冲IO 指的是标准库在应用程序进行读写数据的时候会开辟一个缓冲区，进行系统调用的时候回先调用标准库函数，然后标准库函数再去进行系统调用读取数据，系统调用会预先读取一部分数据缓存在用户标准库里面的缓冲区中，这样就不必每次读取数据都进行系统调用了，减少了系统调用的开销
非缓冲IO 则是每次读写数据都直接进行系统调用，系统调用结果直接返回到应用程序
​
阻塞IO(BIO)和非阻塞IO(NIO) 阻塞IO 指的是用户线程在read系统调用时会一直等待内核读取数据，等内核读取数据到内核缓冲区(比如从网卡读取数据、通过底层文件系统从磁盘读取数据到内核缓冲区)然后将内核缓冲区数据copy到用户空间，这样整个read调用才会返回
阻塞IO线程需要等待的时间: 操作系统读取数据时间+内核缓冲区到用户缓存区copy的时间
非阻塞IO 指的是用户线程在read系统调用之后可以立即返回，但是需要自己主动再次向内核询问数据是否读取到内核缓冲区中，这里需要多次询问直到数据读取完毕(在轮询期间可以干一些其它事情)，当数据准备好了之后，则需要阻塞的等待内核将内核缓冲区的数据copy到用户空间中(注意这个过程是阻塞的)
非阻塞IO线程需要等待的时间: 不断轮询的消耗的时间+内核缓冲区到用户缓存区copy的时间
​
IO多路复用 传统的非阻塞IO模型有如下缺点:
一个线程不断轮询效率低下问题
一个线程只能监听一个IO，为了达到多个网络IO并发连接就只能多线程，多线程多进程有系统调度的开销
于是就出现了 IO多路复用
多路复用是一种 非阻塞IO模型 ，传统同步IO模型比如阻塞IO和非阻塞IO只能在一个线程中监听一个IO句柄，并且需要用户程序主动轮询，但是多路复用则可以在一个线程中监听多个IO句柄，并且不需要用户程序主动轮询，相当于进行系统调用操作系统帮你进行轮询管理多个IO句柄了，所以非阻塞IO需要操作系统的支持
数据从内核缓冲区copy到用户缓冲区等一系列操作，这个copy的过程还是阻塞的，因此多路复用是一种 同步IO模型中的非阻塞IO
​
select、poll、epoll TODO
​
异步IO(AIO)和同步IO 同步IO中用户程序还是会在内核缓冲区copy到用户缓存区的时候阻塞等待，而异步IO在 内核数据准备+数据从内核态拷贝到用户态这两个过程都不用等待，发起aio read就立即返回，用户不需要等待也不需要轮询，操作系统会在后台进行数据准备，数据准备完毕之后会将数据从内核态copy到用户数据区域，这一系列动作都完成之后就会通知用户程序，用户程序收到通知之后数据就已经在自己的用户空间了
​
参考 一口气搞懂「文件系统」，就靠这 25 张图了</description></item></channel></rss>