<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TCP on lyer's blog</title><link>/tags/tcp/</link><description>Recent content in TCP on lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Thu, 11 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="/tags/tcp/index.xml" rel="self" type="application/rss+xml"/><item><title>TCP协议</title><link>/2021/03/11/tcp%E5%8D%8F%E8%AE%AE/</link><pubDate>Thu, 11 Mar 2021 00:00:00 +0000</pubDate><author>icepan@aliyun.com (lyer)</author><guid>/2021/03/11/tcp%E5%8D%8F%E8%AE%AE/</guid><description>TCP协议 面向连接、可靠的字节流传输协议 全双工 可相互传递字节流 只可用于 一对一通信 ，不能用于多播和组播 TCP 使用校验和，确认和重传机制来保证可靠传输 TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制 TCP使用 (源地址，源端口，目的地址，目的端口)来标识一个连接 ​
TCP报文 源端口和目的端口 端口大小为16位，可见端口范围为:0~2^16 也就是[0~65536]
IP层则用ip地址来标识一台主机，TCP层用端口来标识一个应用，使用(源地址，源端口，目的地址，目的端口)唯一确定一个连接，所以对于IPV4的话单台主机最大的连接数为 2^(32+16+32+16) 个
序号 每个TCP包都有一个序号，编号是为了解决TCP包乱序问题，给每个包编上序号就知道了每个包的顺序，这样就可以完整的拼好所有的TCP包了而不造成乱序，TCP给个字节都有一个序号，序号是整个TCP包数据段的第一个字节的序号，比如现在一个包的起始序号为101，数据长度为500byte ，那么最后一个字节的序号就为600，这个TCP包的序号为第一个字节的序号101 ，所以下一个TCP包的第一个字节的序号应该为601，也就是下一个TCP包的序号为601
如果序号达到最大值2^32，则回卷到0
由于初始的seq号是随机生成的，所以TCP回绕到0之后怎么继续保持字节序呢?怎么判断字节序呢?
回绕之后遇到相同的seq号则可以根据TCP头部携带的时间戳来判断前后
确认号 设置TCP包的确认号是为了告诉对方上一个数据包已经确认收到了，你可以继续发送下一个TCP包了，这个确认号填的就是期望对方发送的下一个TCP包的 序号
比如B收到了A发的序号为101的TCP包，该包长度为500byte，B现在收到了A发的600byte之前的数据，期望A发送下一个序号为601的TCP包，所以确认号为601
A收到B的回复的确认号为601得知B已经收到了A发的600byte之前的数据，现在要发下一个序号为601的TCP包了
首部长度 长度为4位
指出TCP首部的大小，因为TCB首部中有可选择字段，所以每个TCB首部都是不定长的，所以需要指定首部长度，单位是4字节 ，最大为2^4 ，所以首部最大长度为16*4byte=60byte
保留位 6位，保留以后使用，目前全部置0
五大标志位 6位
标志 含义 URG 紧急位，为1的话则表示这是个紧急的TCP包，应该放到发送队列的最前面去立即发送 ACK ACK=1表示确认号有效，ACK=0表示确认号无效，TCP连接建立成功后所有的传输报文必须把ACK置为1 PSH 很少用到，一般为0 RST 复位 RST=1 表示TCP连接出错，必须释放连接重新建立 SYN 同步 SYN=1表示这是一个请求建立连接或接受建立连接请求报文 SYN=1 ACK=0表示这是一个建立连接请求，SYN=1 ACK=1表示这是一个应答建立连接请求的TCP报文，详情请参考TCP三次握手 FIN 用来释放连接， FIN=1 表示数据已经发送完毕并且请求释放TCP连接 窗口大小 TCP使用 滑动窗口 来实现拥塞控制和流量控制，详情请见下文，比如B响应给A的报文中窗口字段的大小为1000 ，确认号为101 目的就是为了告诉A可以发送101开始的数据包了，缓存空间大小为1000byte，也就是还可以接受101~1101字节范围的数据包</description></item><item><title>网络分层和协议栈总览</title><link>/2021/03/05/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E5%92%8C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%80%BB%E8%A7%88/</link><pubDate>Fri, 05 Mar 2021 00:00:00 +0000</pubDate><author>icepan@aliyun.com (lyer)</author><guid>/2021/03/05/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E5%92%8C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%80%BB%E8%A7%88/</guid><description>OSI七层模型和TCP/IP五层模型 ​
为什么网络要分层 复杂的计算机程序都需要通过分层来设计，这是一种设计模式，通过分层每层各司其职，每层都可以独立升级和维护
​
TCP/IP协议栈 1、应用层 协议 全名 功能 基于/端口 HTTP Hypertext Transfer Protocol web TCP/80 HTTPS Hypertext Transfer Protocol Secure 加密的HTTP SSL/TSL/443 SSL/TSL Secure Socket Layer/Transport Layer Security 加密协议 FTP File Transfer Protocol 传输文件 TCP/21(控制)/20(数据传输) SSH Secure Shell 连接远程Linux主机 TCP/22 SFTP SSH File Transfer Protocol SSH加密的FTP SSH/22 DNS Domain Name System IP和域名的解析转化 UDP/TCP/53 SMTP Simple Mail Transfer Protocol 邮件收发 TCP/25 POP3 Post Office Protocol-Version 3 收邮件 TCP/110 RPC Remote Procedure Call 调用远程的函数 TCP/随机 DHCP Dynamic Host Configuration Protocol 在局域网中动态分配IP UDP/67(接收)/68(请求) 2、传输层 协议 全名 功能 TCP Transmission Control Protoco 可靠的传递网络数据包 QUIC Quick UDP Internet Connections Google研发的基于UDP的传输层协议，用于替换TCP 2、网络层 协议 全名 功能 IP Internet Protocol 广域网传递数据包 ARP Address Resolution Protocol 根据IP获取MAC ICMP Internet Control Message Protocol 传递网络控制信息，需要加上IP报头组成IP数据报发送 ​</description></item></channel></rss>