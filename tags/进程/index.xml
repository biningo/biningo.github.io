<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>进程 on lyer's blog</title><link>/tags/%E8%BF%9B%E7%A8%8B/</link><description>Recent content in 进程 on lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Thu, 01 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="/tags/%E8%BF%9B%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux进程和线程</title><link>/2021/04/01/linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</link><pubDate>Thu, 01 Apr 2021 00:00:00 +0000</pubDate><author>icepan@aliyun.com (lyer)</author><guid>/2021/04/01/linux%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</guid><description>CopyOnWrite 由于操作系统创建进程必须通过fork来创建，fork创建的子进程和父进程一模一样只是task_struct不一样，其虚拟地址空间底层的物理地址指向的都是同一个页面，只有在子进程需要修改的时候才会重新分配一个物理然后将原来的内容copy过去，最后再修改子进程的物理页，这样子进程的修改就不会影响到父进程了，这个就是 Copy On Write技术
操作系统主要是为了减少物理页的分配和copy的消耗，因为创建子进程之后一般子进程会通过exec系统调用重写自己的进程映象，所以就没有必要copy一份了，而且Linux线程是通过进程实现了，这样就可以实现多个线程共享主线程也就是父进程的内存地址空间了
​
Linux线程的实现 Linux中没有线程这一个单独的概念，Linux中所有的执行流所有的线程进程都通过一个task_struct来进行标识，Linux就是通过task_struct来感知线程和进程，也是通过task_struct中的信息来进行线程进程调度的
所以在C下创建线程都是能被Linux的内核感知到的，也就是说Linux的线程模型是 一对一模型 ，当然其他高级语言可以自己实现自己的用户线程库来实现 一对多、多对多线程模型，比如Go就通过自己goroutinue来实现了 多对多模型 ，所以goroutinue是比较轻量并且高效的，这也是为什么go的并发这么优秀的原因
Linux下每个进程都有自己的父亲，一个进程如果没有其它子线程那么就只有一个主线程，也就是进程，如果该进程创建了多个线程，那么这多个线程的父亲也就是PPID都指向同一个: 主线程，主线程的PPID指向fork它的那个进程，这两个进程是独立的不同的进程。然后每个task_struct中都有一个gid，用来标识多个task_struct属于同一个 进程组，子线程的gid指向主线程的pid，主线程的gid指向自己，这样就将进程和线程区别开来了，只要是属于同一个gid的task_struct就属于同一个进程，只要是gid=pid的则这个就是主线程也就是进程本身
另外还需要注意的就是每个task_struct的虚拟地址空间中都有一个栈区，这个栈每个线程进程都必须是独立的，主线程的栈空间就是创建进程时的那个栈空间，而子线程的栈空间是从主线程也就是进程的堆空间中map出来的，这个堆空间每个线程都是共享的，fork之后如果是线程则不会重写重写自己的进程映象，也就是意味着可以和主线程共享内存空间，而如果是进程则会立即重写自己的进程映象，属于独立与父进程的一个进程
​
进程的虚拟地址空间 一些特殊的进程 操作系统进程: idle[0] 唯一一个没有通过fork创建的进程，也就是内核代码的main执行流
第一个用户进程: init[1]
第一个内核进程: kthreadd[2]
参考 虚拟内存[01] 用户内存空间的各个段分布
写时复制技术</description></item></channel></rss>