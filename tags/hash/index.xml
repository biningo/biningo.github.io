<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Hash - 标签 - lyer's blog</title><link>/tags/hash/</link><description>Hash - 标签 - lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Sat, 17 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="/tags/hash/" rel="self" type="application/rss+xml"/><item><title>常见的Hash算法</title><link>/2021/04/17/%E5%B8%B8%E8%A7%81%E7%9A%84hash%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/17/%E5%B8%B8%E8%A7%81%E7%9A%84hash%E7%AE%97%E6%B3%95/</guid><description><![CDATA[什么是Hash算法 Hash表这种数据结构中就是使用了Hash算法，其将值进行Hash转化为表数组对应的下标，这种Hash算法的目的就是将其他数据比如 字符串、int、bool 转化为数组下标(正整数)
下面来看看JDK11里面HashMap的hash函数
static final int hash(Object key) { int h; return key == null ? 0 : (h = key.hashCode()) ^ h &gt;&gt;&gt; 16; } 主要通过key的hashCode函数来计算hash值，并且还进行了二次hash来减少碰撞
用户实现的这个hashCode有如下几个规定:
 如果 key1 = key2，那 hash(key1) == hash(key2) 如果 key1 != key2，那 hash(key1) != hash(key2) 如果不同的key产生了相同的hash值那么就代表产生了hash碰撞 hashCode必须返回一个非负整数  我们再来看一看String的hashCode的实现，下面是英文的拉丁字母的hashCode函数
至于为什么31这是为什么减少hash碰撞，因为31是一个不大不小的质数
public static int hashCode(byte[] value) { int h = 0; byte[] var2 = value; int var3 = value.length; for(int var4 = 0; var4 &lt; var3; ++var4) { byte v = var2[var4]; h = 31 * h + (v &amp; 255); //字母会转化为对应的ASCII码值然后计算hash  } return h; }  Java中Integer类型的hashCode是它本身]]></description></item></channel></rss>