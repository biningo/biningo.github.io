<!doctype html><html lang=zh-cn><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>lyer's blog</title><meta name=Description content><meta property="og:title" content="lyer's blog"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="/"><meta property="og:updated_time" content="2021-04-28T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="lyer's blog"><meta name=twitter:description content><meta name=application-name content="lyer's blog"><meta name=apple-mobile-web-app-title content="lyer's blog"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=/><link rel=alternate href=/index.xml type=application/rss+xml title="lyer's blog"><link rel=feed href=/index.xml type=application/rss+xml title="lyer's blog"><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","url":"\/","inLanguage":"zh-CN","author":{"@type":"Person","name":"lyer"},"name":"lyer's blog"}</script></head><body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':(''==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:''==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="lyer's blog">lyer's blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>archive </a><a class=menu-item href=/tags/>tag </a><a class=menu-item href=/categories/>category </a><a class=menu-item href=/book>book </a><a class=menu-item href=/about>about </a><a class=menu-item href=/study>study </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="lyer's blog">lyer's blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/>archive</a><a class=menu-item href=/tags/>tag</a><a class=menu-item href=/categories/>category</a><a class=menu-item href=/book>book</a><a class=menu-item href=/about>about</a><a class=menu-item href=/study>study</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class="page home" posts><div class=home-profile><div class=home-avatar><a href=/posts/ title=archive><img class=lazyload src=/svg/loading.min.svg data-src=https://pic4.zhimg.com/v2-e263475646652726731e13e44b5d2479_im.jpg data-srcset="https://pic4.zhimg.com/v2-e263475646652726731e13e44b5d2479_im.jpg, https://pic4.zhimg.com/v2-e263475646652726731e13e44b5d2479_im.jpg 1.5x, https://pic4.zhimg.com/v2-e263475646652726731e13e44b5d2479_im.jpg 2x" data-sizes=auto alt=https://pic4.zhimg.com/v2-e263475646652726731e13e44b5d2479_im.jpg title=https://pic4.zhimg.com/v2-e263475646652726731e13e44b5d2479_im.jpg></a></div><h2 class=home-subtitle><div id=id-1 class=typeit></div></h2><div class=links><a href=https://github.com/biningo title=GitHub target=_blank rel="noopener noreffer me"><i class="fab fa-github-alt fa-fw"></i></a><a href=https://twitter.com/biningo2 title=Twitter target=_blank rel="noopener noreffer me"><i class="fab fa-twitter fa-fw"></i></a><a href=https://t.me/icepan title=Telegram target=_blank rel="noopener noreffer me"><i class="fab fa-telegram-plane fa-fw"></i></a><a href=mailto:icepan@aliyun.com title=Email rel=me><i class="far fa-envelope fa-fw"></i></a><a href=/index.xml title=RSS target=_blank rel="noopener noreffer me"><i class="fas fa-rss fa-fw"></i></a></div></div><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/2021/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%88/>操作系统中的各种栈</a></h1><div class=post-meta><span class=post-author><a href=https://icepan.cloud title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>lyer</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-04-03>2021-04-03</time></span>&nbsp;<span class=post-category>收录于 <a href=/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/><i class="far fa-folder fa-fw"></i>操作系统</a></span></div><div class=content>栈的作用 程序中栈的作用主要有如下:
局部变量的空间快速分配和释放 函数调用与返回 保存状态，以便恢复 在函数里面的变量都属于局部变量，函数调用结束，出了函数这个局部遍历就没有用了，那么其空间也不需要保留了
所以栈可以在函数调用时快速分配局部变量的内存地址，而在函数调用结束之后可以立即销毁，所以在C语言中不能在函数中返回局部变量的指针，这样会造成 悬挂指针 问题，因为在函数返回时其地址就已经被回收了
栈还有另外的作用就是嵌套函数调用，比如 递归，其实就是一层层的函数调用栈，所以所有的递归代码都可以用 迭代 来改写
栈还在 中断处理 中发挥着中断恢复的作用，进程在发生中断的时候会将进程当前的寄存器状态和当前的PC指针都压入内核栈然后开始执行中断处理代码，中断处理也是使用这个内核栈的，等中断处理完毕之后就弹出内核栈恢复寄存器继续回到之前的代码中执行
​
线程栈和进程栈 Linux的进程和线程其实都是同一个结构体task_struct来表示，Linux并没有线程的概念，只是Linux的进程有父进程子进程的概念，有一颗进程树
Linux的线程也叫轻量级进程，Linux通过多个进程共享内存空间来实现进程中的多线程
主线程就是创建进程的那个执行流，而子线程都从主线程也就是进程中fork出来，只是fork之后相当于copy，所以他们能共享内存空间等其他资源(包括文件描述符等)这样就可以实现线程的效果了
虽然他们内存空间都一样，很多资源都是一样的，但是各个线程之间的stack还是需要fork之后重新改变的，多个线程之间必须使用独立的栈，因为他们都是不同的执行流，是并行执行的，而不是向函数一样一层层嵌套的
如果线程栈都使用同一个的话那么如果发生线程切换调度，原来线程的执行过程中保存在栈中的数据就会被破坏掉，或则不是他想要的数据了
线程的stack大小是固定的，是从父进程的堆空间映射过来的，也就是说线程的栈开辟在父进程的堆中
linux创建线程都是使用fork，必须要有一个父进程(第一个用户进程init进程1号进程是由操作系统在初始化时创建的，第一个内核级进程是2号进程)，如果是创建线程则直接共享内存空间改变stack和PID、PPID等一些主要的信息即可，如果是创建进程则需要重写进程映象，加载可执行文件重新建立属于自己的内存地址空间，重新建立页表映射
​
进程内核栈 操作系统会为每个进程都创建内核栈，此栈用于系统调用、中断等发生特权级转换执行内核代码使用，在发生中断引发特权级别转化时，操作系统会将进程触发中断时的上下文都压入内核栈以便能继续回到用户态，然后在执行内核代码
注意内核栈是和PCB一起管理的，也就是说一个PCB包含了内核栈，内核栈大小是固定的
内核栈也是必须要独立的，为什么内核栈不能使用进程的栈呢?
这主要是为了保护内核，内核级的数据不允许出现在用户级空间上
哪为什么要为每个进程都建立一个内核栈呢?
这主要是为了防止进程调度之后导致的问题，就像每个线程不能共享进程栈一样，一个进程即使陷入内核了还是会发生进程调度，因为进程陷入内核还是在这个进程范围内为这个进程服务
为什么进程和子线程需要独立的内核栈?
这个问题其实和上面那个重复了，进程(也就是主线程)和子线程的内核栈也必须在独立的，同样为了防止线程调度引发的数据破坏问题 ，这个很好理解，因为Linux线程其实就是进程模拟出来的，那么自然在陷入内核时必须为其创建独立的内核栈
​
参考 Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈</div><div class=post-footer><a href=/2021/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%88/>阅读全文</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/linux/>Linux</a>,&nbsp;<a href=/tags/os/>OS</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/2021/04/03/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D/>进程状态恢复</a></h1><div class=post-meta><span class=post-author><a href=https://icepan.cloud title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>lyer</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-04-03>2021-04-03</time></span>&nbsp;<span class=post-category>收录于 <a href=/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/><i class="far fa-folder fa-fw"></i>操作系统</a></span></div><div class=content>系统调用和中断时的状态恢复 发生系统调用的时候，需要发生 特权级转化 ，这样才可以指向内核代码执行系统调用代码等，这时候也需要保存进程的状态，因为系统调用或则中断处理完毕之后需要回到之前的用户进程继续执行
操作系统会为每个进程分配一个 内核栈，此栈每个进程都有并且内核栈大小是固定的，其地址空间保存在PCB中，也就是 task_struct中，方便和PCB一起管理
内核栈用于存放一些系统调用执行的数据等，因为系统调用执行的代码也需要用到栈，因此为了在系统调用结束之后还可以继续回到之前的位置执行于是在发生系统调用之前需要将进程相关的上下文信息都压入内核栈中，比如 PC指针、各个寄存器值、堆栈指针等 因为进入内核态之后堆栈也会发生变化，所以这里需要保存进程之前的堆栈信息
**注意，发生中断时进程的 **CR3 寄存器是不会改变的也不需要保存，此寄存器保存了用户进程的页表，因此操作系统可以根据这个页表将内核空间的数据copy到用户空间(内核态和用户态的数据有两个系统调用函数: copy_to_user和copy_from_user)
因为用户的页表永远都有操作系统的地址映射，所以不影响内核代码的执行
上下文信息保存完毕之后，就可以执行内核代码了，内核代码指向完毕之后栈相关数据也空了，然后继续恢复之前在栈底保存的进程上下文信息即可，这样就可以继续回到进程中断前的代码去执行了
​
进程调度时的状态恢复 发生进程调度时需要将进程当前的所有信息都保存在task_struct中，以便下次被调度之后可以继续恢复之前的状态，比如恢复 页表、PC指针、栈指针、各个寄存器值、进程页表 等
进程调度发生的上下文切换是比 中断 引发的上下文切换代价要大的，因为进程调度还需要切换页表加载页表清空TLB缓存等操作，而中断是在一个进程内引发并且中断完毕之后需要继续回到之前的进程，相当于在进程中调用了系统内核函数一样只不过调用系统函数执行内核代码需要转化特权级和内核堆栈等，还有很多进程的信息是不需要切换的
​
参考 进程切换与系统调用(中断和异常)切换哪个耗时耗资源多
Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈</div><div class=post-footer><a href=/2021/04/03/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D/>阅读全文</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/linux/>Linux</a>,&nbsp;<a href=/tags/os/>OS</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/2021/04/02/linux%E4%B8%AD%E7%9A%84vfs%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/>Linux中的VFS虚拟文件系统</a></h1><div class=post-meta><span class=post-author><a href=https://icepan.cloud title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>lyer</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-04-02>2021-04-02</time></span>&nbsp;<span class=post-category>收录于 <a href=/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/><i class="far fa-folder fa-fw"></i>操作系统</a></span></div><div class=content>为什么磁盘需要分区分块 1、磁盘为什么要分区 磁盘分区的主要就是划分几个大块，每个分区里面可以安装不同的底层文件系统，分区之间都是独立的，也可以在不同的分区上安装不同的操作系统，就好像把磁盘容量看成一整块，然后在这个一整块上进行划分几个区域(当然只划分一个区域也是可以的)
分区主要有一下几个优点:
方便数据管理 隔离数据，保证数据安全，不同分区之间数据互不干扰，分区之间独立 加快数据查找：因为文件系统会将磁盘分成一个个的数据块，单个文件数据可能是存放在不连续的块中，如果分区太大，某个文件数据块分散的存在开头和结尾那么磁头臂的移动就会非常频繁造成读取效率低下，所以一个分区的大小不能划分太大，如果磁盘容量很大的话则可以多划分几个分区 可以在一台计算机上不同的分区上安装不同的操作系统、不同的文件系统，实现双系统等 2、磁盘为什么要分块 机械磁盘读写数据是以 扇区 为单位的，一个扇区大小为512字节或则4kb
扇区是抽象的概念，物理上是没有的，物理上只有盘片，一张盘都是一整块的，只是物理部件在读写的时候是以这个为单位读写的，所有文件的容量大小必须是扇区数量的整数，需要按照扇区大小对齐
SSD固态硬盘没有盘片的概念，但也有数据单元和数据页的概念，SSD相当于内存一样但是可以持久化，每个数据单元就是1byte，同时一个数据页就包含了多个数据单元，SSD读写的基本单位就是数据页，也是需要做到数据页对齐的
但是物理划分的区块太小了，如果一个文件按照物理区块进行存储的话，因为保存文件的区块不一定连续(如果连续的话会造成碎片问题，所以都是分散存放然后建立索引表)，所以读写一个文件会造成IO次数太多造成而造成效率太低
所以底层的文件系统再次进行了重新划分区块大小，一个数据块对应着物理上 连续的几个扇区或则几个数据页，文件存储的基本单位就是以文件系统划分的数据块为单位的，数据块大小一般和内存页大小一致，方便与内存数据进行交换
如果需要读一个文件，则需要找到保存文件所有数据块的索引表，此表由操作系统和文件系统维护，这些数据块之间可能是分散的，虚拟块是连续的，需要读写哪部分则按照偏移然后加载对应的数据块到内存然后进行读写，这个和内存虚拟地址思想一样
​
ext4文件系统 1、ext2 ext3 这就是最简单的ext2、ext3的底层结构，具体的区别不深究了，大概就是这样，跳出细节才更有利于学习
引导块 存放引导操作系统启动的代码程序，每个分区都有一个引导块，这样可以实现多系统，只需要在MBR或EFI系统上放置一个bootloader，该bootloader就会确定活动分区（通常由用户在启动界面选择启动哪个系统），然后就会跳转到响应的 活动分区中的引导块中加载引导块中的代码到内存进行执行，然后就会加载该活动分区中的操作系统
superblock超级块 super block在索引导块后面，主要包含整个文件系统的一些基本元数据，可以说一个super block就代表了一个文件系统，因此此块一般会进行备份，因为如果这里面的数据被销毁了那么这个磁盘就没办法使用了，里面的数据就无法读取了，该块主要保存如下几个数据:
文件系统设置的数据块大小(一个数据块通常占据整数个扇区比如：8个扇区 4k大小) 空闲块数 空闲的inode节点数 &mldr;&mldr;. 操作系统在启动之后就会将super block从磁盘加载到内存，然后建立 super_block对象，该对象是常驻内存的
空闲块位图和inode位图 空闲区块位图bitmap
管理整个分区中空闲的数据块，占用多个数据块block
inode位图bitmap
管理整个分区中inode的使用和分配，占用多个连续的数据块block，如果inode分配完了就无法再创建文件了
inode节点区块 是一个数组结构，存放整个文件系统的inode信息，每个inode就代表一个文件，inode节点个数代表该文件系统最多能创建多少个文件
注意，inode的大小是固定的，每个inode节点的大小，一般是128字节或256字节，用于标识一个唯一的文件，所以没有保存文件名，文件名保存在文件对应的目录文件的data block中
inode 节点主要包括了以下信息：
文件的inode ID 文件权限信息 所有者 ID、组 ID 文件大小（字节数）、文件类型 文件的硬链接数 上次访问时间、最后修改时间、inode 上次修改时间 文件的数据块block映射表 ext文件系统的数据保存的数据块是分散的(为什么要分散前面说了)，为了找到这些数据所以需要建立索引表，索引表如果都放在inode结构上，那么如果文件太大则索引表就会变的很大，但是inode大小是固定的，所以ext3文件系统采用了如下多级索引的方式，inode一共保存了15个索引项在inode中，如果文件很小则前面几个索引项直接指向真实的数据块，如果文件很大那么后面索引项指向的数据块就不是保存数据了而是保存索引信息了，相当于二级索引，每个数据块又能保存256个索引项，如果文件还很大则又会建立三级索引、四级索引等</div><div class=post-footer><a href=/2021/04/02/linux%E4%B8%AD%E7%9A%84vfs%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/>阅读全文</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/linux/>Linux</a>,&nbsp;<a href=/tags/os/>OS</a>,&nbsp;<a href=/tags/vfs/>VFS</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/2021/03/31/bloomfilter%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/>BloomFilter布隆过滤器</a></h1><div class=post-meta><span class=post-author><a href=https://icepan.cloud title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>lyer</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-03-31>2021-03-31</time></span>&nbsp;<span class=post-category>收录于 <a href=/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/><i class="far fa-folder fa-fw"></i>算法和数据结构</a></span></div><div class=content>布隆过滤器原理 布隆过滤器就是通过 3个hash函数，当然hash函数的数量不限，hash函数越多判断越准确，但是同时消耗也越大
将值进行一个hash，计算出对应的index，然后设置对应的bitmap
查找的时候再将值进行hash，分别查找对应的bitmap的位数是否为1，,如果都为1那么则表示找到，如果有一个不为1则表示不存在
BloomFilter 的缺点就是发生hash碰撞之后会出现误判的情况 ，也就是说有可能多个值都映射到相同的位置，所以如果判断出元素存在的话还需要进一步到真实的数据中去再次确认元素是否存在，但是如果判断出不存在，则肯定是不存在
同时布隆过滤器也有 删除问题，也就是说如果删除了一个值，那么其对应的bitmap就要置为0 ，但是如果和他产生hash碰撞的值也都无法判断了，比如原来本来存在的值其中一位和删除的值的bit位一样，但是被删除了，那么判断这个值得时候就会误判为不存在
综上，我们得出 BloomFilter 的主要作用如下:
一个元素如果判断结果为存在的时候元素不一定存在，但是判断结果为不存在的时候则一定不存在。 布隆过滤器可以添加元素，但是不能删除元素 ​
BloomFilter的应用场景 网页爬虫对URL的去重，避免爬取相同的URL地址；
反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱；
防止缓存击穿，将已存在的key放到布隆过滤器中，当访问不存在的缓存时迅速返回避免去真实的数据库查询缓存，这样如果黑客暴力故意查询一个不存在的键时也不会打到后台真实的服务器上而是直接在BloomFilter缓存中就已经判断出不存在了
​
BloomFilter的实现 TODO
​
布谷鸟过滤器 布谷鸟过滤器是布隆过滤器的升级版，其支持删除操作并且不影响判断，我在github上找到了一个实现
https://github.com/linvon/cuckoo-filter/blob/main/cuckoofilter.go
​
参考 https://developer.aliyun.com/article/773205 【布隆过滤器，这一篇给你讲的明明白白】
https://segmentfault.com/a/1190000039156246 【布隆，牛逼！布谷鸟，牛逼！】讲的不错</div><div class=post-footer><a href=/2021/03/31/bloomfilter%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/>阅读全文</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/bloomfilter/>BloomFilter</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/2021/03/31/b%E6%A0%91b-%E6%A0%91avl%E6%A0%91%E7%BA%A2%E9%BB%91%E6%A0%91/>B树B+树AVL树红黑树</a></h1><div class=post-meta><span class=post-author><a href=https://icepan.cloud title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>lyer</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-03-31>2021-03-31</time></span>&nbsp;<span class=post-category>收录于 <a href=/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/><i class="far fa-folder fa-fw"></i>算法和数据结构</a></span></div><div class=content>B树B+树AVL树红黑树 把这四颗 可爱 的树放在一篇博客来写就是因为他们都有一个共同点: 都是平衡树
传统的二叉树一旦发生倾斜那么就会退化为链表，这是二叉树最致命的缺点，所以就出现了如此多种的树，来提高数据查找的效率
B树 不同于二叉树，B树一个节点可能会有多颗子树，相当于是一颗多叉树，并且按照一定的规则来保持这种状态那么这个树就会维持的比较 矮胖，又因为B树有搜索树的性质所以二分查找起来速度就快了
B+树 就是B树的升级版，B+树和B树的不同在于叶子节点，B+树的每个叶子节点都会用链表连接起来，这样就支持 范围查找，B+树的叶子节点存放了所有数据和索引，而非叶子节点则只保存索引，这个非叶子节点保存的索引代表了子树中最小或则最大的索引，此索引是冗余的，一旦找到起始节点那么中间的节点就可以一起获取到，就不需要每次都从root节点开始遍历了
AVL树 是一颗平衡的二叉搜索树，一旦左右子树的平衡因子太大或则太小了那么就表示树已经失衡了，就会通过旋转操作来继续维持平衡因子到指定的值，所以旋转操作执行次数多的话也是比较耗时的
红黑树 和AVL树一样也是通过一定规则并且靠旋转、变色来维持树的平衡
在学习这些数据结构的时候不需要背规则，知道个大致原理即可
​
B树 又叫 多路查找树，和二叉树不同的是一个节点最多可以有多个子树
B树靠如下几个规则来保持树的平衡和矮胖:
根节点如果有孩子节点的话则至少有2个子节点
一颗m阶的B树中所有节点的最大孩子节点数量&lt;=m，所以最多包含m-1个关键字(因为孩子节点是在两个关键字之间进行插入的)
中间节点关键字数量为k: ceil(m/2)&lt;=k&lt;=m-1
关键字之间是有序的，并且有搜索树的性质
所有叶子节点在同一层，也就是说根节点到所有叶子节点的距离都是一样的
​
B+树 B+树就是在B树的基础上对叶子节点进行了改进，将所有的叶子节点都用链表连接起来，B+树的只在叶子节点保存数据，其他节点保存索引值
B+树和B树的区别如下:
子树数量和关键字数量一致(B树中子树数量比关键字数量多1) 叶子节点使用链表连接 非叶子节点会存放冗余的索引，叶子节点会存放具体的值和所有索引，所以非叶子节点有值重复(而B树所有节点都是唯一的) 因为B+树的所有叶子都使用链表连接，所以B+树支持范围查找，只需要找到起始节点即可
​
AVL树 左旋 右旋 左右旋 右左旋 ​
红黑树 参考 B树-王道考研视频 【讲的很好】
数据结构-B树【宁哥算法课堂】
2020B站最详细红黑树结构-二叉树-哈希-B+树-HASH-平衡算法
MYSQL核心底层原理大盘点！看完心里有B树了吗？ 【InnoDB讲的很好】</div><div class=post-footer><a href=/2021/03/31/b%E6%A0%91b-%E6%A0%91avl%E6%A0%91%E7%BA%A2%E9%BB%91%E6%A0%91/>阅读全文</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/>平衡树</a></div></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/2021/03/31/%E4%BD%8D%E8%BF%90%E7%AE%97%E9%AA%9A%E6%93%8D%E4%BD%9C/>位运算骚操作</a></h1><div class=post-meta><span class=post-author><a href=https://icepan.cloud title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>lyer</a></span>&nbsp;<span class=post-publish>发布于 <time datetime=2021-03-31>2021-03-31</time></span>&nbsp;<span class=post-category>收录于 <a href=/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/><i class="far fa-folder fa-fw"></i>算法和数据结构</a></span></div><div class=content>XOR 异或: 相同为0，不同为1
x^0=x x^(~x)=全1 #位数和x一样的全1 x^x=0 交换两个整数变量
a^=b b^=a a^=b 判断奇偶性
x&1 == 1 #奇数 x&1 == 0 #偶数 计算某个数字二进制位1的个数
int countOne(int num) { int cnt = 0; for (int i = 0; i &lt; 8 * sizeof(num); ++i) { cnt += num & 1; num >>= 1; } return cnt; } 判断某一位是否为1
(n>>(pos-1))&1 乘2除2
n>>1 #/2 n&lt;&lt;1 #*2 掩码操作，获取前面几位
mask=11110000 n=10100000 mask&n #获取前面4位 其它位置0 将最低位的1置0
num & (num - 1) 一个数组中其他数都出现了2次，只有一个数出现了1次，找出那个数</div><div class=post-footer><a href=/2021/03/31/%E4%BD%8D%E8%BF%90%E7%AE%97%E9%AA%9A%E6%93%8D%E4%BD%9C/>阅读全文</a><div class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/>位运算</a></div></div></article><ul class=pagination><li class=page-item><span class=page-link><a href=/>1</a></span></li><li class=page-item><span class=page-link><a href=/page/2/>2</a></span></li><li class=page-item><span class=page-link><a href=/page/3/>3</a></span></li><li class="page-item active"><span class=page-link><a href=/page/4/>4</a></span></li><li class=page-item><span class=page-link><a href=/page/5/>5</a></span></li><li class=page-item><span class=page-link><a href=/page/6/>6</a></span></li><li class=page-item><span class=page-link aria-hidden=true>&mldr;</span></li><li class=page-item><span class=page-link><a href=/page/13/>13</a></span></li></ul></div></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.80.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://icepan.cloud target=_blank>lyer</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/algoliasearch/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/typeit/typeit.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"data":{"id-1":"我叫lyer,Gopher,vim党,重度依赖jetbrains IDE"},"search":{"algoliaAppID":null,"algoliaIndex":null,"algoliaSearchKey":null,"highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"typeit":{"cursorChar":null,"cursorSpeed":null,"data":{"id-1":["id-1"]},"duration":null,"speed":null}};</script><script type=text/javascript src=/js/theme.min.js></script></body></html>