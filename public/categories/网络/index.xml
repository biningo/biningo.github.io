<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>网络 - 分类 - lyer's blog</title><link>/categories/%E7%BD%91%E7%BB%9C/</link><description>网络 - 分类 - lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Thu, 27 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="/categories/%E7%BD%91%E7%BB%9C/" rel="self" type="application/rss+xml"/><item><title>TCP半连接和全连接队列</title><link>/2021/05/27/tcp%E5%8D%8A%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/</link><pubDate>Thu, 27 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/27/tcp%E5%8D%8A%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97/</guid><description>什么是半连接和全连接队列 操作系统在listen开启监听时就会建立两个队列
半连接 全连接 半连接队列存放的就是一些还没建立TCP连接，并且还在三次握手过程中的客户端连接
全连接队列存放的就是一些已经完全建立TCP连接但是还没被应用层取走的连接，每次应用层调用accept时就会从全连接队列里取一个连接去处理，但是如果队列中没有连接就会阻塞
​
半连接队列 当服务器端在LISTEN状态时能接受其他客户端的TCP建立连接请求，当服务器收到客户端发来的SYN包时就会回复ACK+SYN，此时服务器就进入了 SYN_RECV的状态，这个时候服务器就会将这个连接存放到半连接队列中，并且等待客户端发来应答的ACK
如果在指定时间内客户端没有发第三次握手，则服务器会进行重试直到超过一定次数则会将此连接从半连接队列里面删除
#SYN+ACK重试次数 默认为5 /proc/sys/net/ipv4/tcp_synack_retries 如果客户端发来了第三次握手ACK，则会将此连接放入全连接队列等待用户应用去队列里面取
如果半连接队列满了的话，则服务器不会继续接受客户端的连接请求，当其他客户端想要建立TCP连接发送SYN时，服务器就会发送RST报文告诉客户端 &amp;ldquo;连接失败&amp;quot;或则是直接丢弃
​
半连接队列大小 半连接队列大小收到下面几个因素影响
用户层 listen 传入的backlog （用户传入的全连接队列大小） 系统变量 net.ipv4.tcp_max_syn_backlog，默认值为 128 系统变量 net.core.somaxconn，默认值为 128 （Linux配置的全连接队列大小） int listen(int sockfd, int backlog); //第二个参数 /proc/sys/net/ipv4/tcp_max_syn_backlog #1024 /proc/sys/net/core/somaxconn #4096 如果我们想要增加半连接队列的大小，我们就需要同时增加上面三个值，而单单的增加其中的几个则可能无法增加半连接队列的大小
​
全连接队列 当服务器收到客户端发来的第三次握手的时候，服务器就会将这个连接从半连接队里里面转移到全连接队里面并等待应用去全连接队列里取连接进行处理，应用一旦取走该连接就不会保存在队列里了
全连接队列只是用来保存已经建立TCP连接但是还没被用户取走待处理的连接
如果全连接队列满了的话服务器会使用下面两种策略，用户可以在一下文件中配置
/proc/sys/net/ipv4/tcp_abort_on_overflow 0 全连接队列满了则server会丢弃ACK，当作没收到
即使收到了客户端发来的第三次握手ACK也会丢弃当做没收到，则此半连接就无法进入全连接队里，同时server端也会在超时的时候继续发送SYN+ACK，当重试超过指定次数之后全连接队列还是满的则会因为将此半连接删除
1 全连接队列满了则会发送RST包告诉客户端废除这个连接请求
一般配置为0可以有效的增加服务器的并发能力，可能全连接队列只是短暂的满了，之后会被快速取走，则配置为0之后，在后面重试的ACK中还是可以建立连接的
​
全连接队列大小 全连接大小由操作系统配置somaxconn和用户应用配置的backlog两个值确定的
min(somaxconn, backlog) int listen(int sockfd, int backlog) //用户决定 /proc/sys/net/core/somaxconn #4096 操作系统参数 我们如果要增加全连接大小，则需要考虑操作系统的配置以及应用程序传入的配置，取他们之间最小的一个，也就是说即使应用程序传入的backlog再大，如果somaxconn很小的话则依然无法增加全连接队列的大小</description></item><item><title>TCP协议中的KeepAlive机制</title><link>/2021/05/27/tcp%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84keepalive%E6%9C%BA%E5%88%B6/</link><pubDate>Thu, 27 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/27/tcp%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84keepalive%E6%9C%BA%E5%88%B6/</guid><description>HTTP中的keep-alive 在HTTP的头部中，也有一个字段
connection: keep-alive 此字段告诉服务器HTTP会复用这一条TCP连接，当前的HTTP请求完毕之后不会立即断开连接，还可以被另外的HTTP请求复用这条连接，这样就可以减少建立TCP连接的次数
​
TCP的长连接和短连接 TCP连接并没有分为长短连接，长短连接只是在于你如何使用TCP
如果建立TCP连接短暂通讯结束之后立即释放这条连接则此连接就为短连接，比如我HTTP发一次请求就建立一次TCP连接，HTTP响应回来之后就立即断开TCP连接
短连接的缺点就是需要频繁的建立TCP连接，比较耗时，优点就是可以很快的释放TCP连接队列，以便于空出位置建立其他TCP连接
如果建立TCP连接在使用时候不立即断开，如果一直没有请求的话就将这条连接空闲即可，以便与后面如果还要请求通讯的话就不需要建立TCP连接了，直接复用那条已经建立好的TCP连接即可。比如我HTTP请求建立TCP连接，响应结束之后浏览器不会立即释放与服务器的TCP连接，如果下次还有其他请求的话则可以复用之前建立的TCP连接即可，如果一时半会儿还没有请求的话只需要将TCP连接空闲着即可，等下次有请求了就可以继续用这条连接进行传输
长连接的优点就是可以减少建立TCP连接的消耗，复用连接。缺点就是如果很长一段时间都没有数据可发的话就会占用操作系统的TCP全连接队列，如果TCP全连接队列比较紧张的话那么就无法建立其他的TCP连接了
​
TCP的KeepAlive机制 TCP的KeepAlive机制会在指定的间隔时间发送KeepAlive探活包，如果收到了KeepAlive包的ACK则表明对方还在，如果多次发送KeepAlive包都得不到回复则可以认为对方已经挂了，就可以将这个TCP连接从队列里面删除了
KeepAlice主要有如下几个作用:
保活 解决窗口值为0的情况 在空闲的长连接里我们可以通过KeepAlive机制探测对方是否存活，如果收到ACK则表明对方还存活并且还需要复用这条连接
如果多次发送KeepAlive都收不到则说明对方已经挂了或则对方拒绝回复，这样就表明这条长连接可以断开清除了。如果没有KeepAlive机制如果对方挂了则这个连接还会一直保留在服务区占用着TCP全连接队列
还有一种情况就是在接收方的窗口值为0的情况下，那么发送方就不能继续发送数据了，那么即使接收方的窗口扩大了也没有办法告诉发送方，此时就相当于死锁了双方都不会发送数据
所以KeepAlive探测包还可以用于解决窗口值减少为0而造成死锁的情况。当接收方的窗口为0的时候，发送方可以定时的发送KeepAlive包来探测接收方的窗口是否扩大了
​
Linux中KeepAlive相关配置 #7200 每7200s发送KeepAlive包 /proc/sys/net/ipv4/tcp_keepalive_time #75 如果75s内没有收到KeepAlive的ACK则再次发送 /proc/sys/net/ipv4/tcp_keepalive_intvl #9 如果重试9次都没有响应则把此连接删除掉 /proc/sys/net/ipv4/tcp_keepalive_probes</description></item><item><title>netcat和socat网络小工具</title><link>/2021/05/19/netcat%E5%92%8Csocat%E7%BD%91%E7%BB%9C%E5%B0%8F%E5%B7%A5%E5%85%B7/</link><pubDate>Wed, 19 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/19/netcat%E5%92%8Csocat%E7%BD%91%E7%BB%9C%E5%B0%8F%E5%B7%A5%E5%85%B7/</guid><description>netcat网络瑞士军刀 netcat是一个网络小工具，可以用来监听端口，数据回发(简单的echo)，TCP端口扫描，探测网络，网络测速等
echo监听端口和连接端口
#server -l表示监听 nc -l 8000 #监听8000端口 #client nc localhost 8000 #连接本地的8000端口 #然后直接输入数据对方就可以收到了 #监听UDP端口 nc -u -l 8080 #请求UDP端口 nc -u localhost 8080 传输文件
#server nc -l 1234 &amp;gt; filename.out #client nc -N localhost 1234 &amp;lt; filename.in #-N表示如果接受到EOF则断开 端口扫描和检测端口
# -z表示只是检测端口 不需要发送数据 # -v表示显示详细信息 # -w表示指定超时时间s nc -zv host.example.com 20-30 #[20,30] nc -zv icepan.cloud 9000 #端口检测 telnet效果一样 nc -zv -w 5 icepan.cloud 1111 #检测端口设置超时时间为5s 结合pv网络测速（pv用于测量任何操作的数度，可以以管道符来测量）
#server nc -l 8080 &amp;lt; /dev/zero #给这个传输无限多个空白字符串 #client nc icepan.</description></item><item><title>TTL和MSL</title><link>/2021/05/14/ttl%E5%92%8Cmsl/</link><pubDate>Fri, 14 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/14/ttl%E5%92%8Cmsl/</guid><description>TTL Time To Live 指定了IP包允许跳转(允许通过的最大网段数量)的路由器数量，最大值为255，推荐值为64
TTL在IP数据包中表示
IP数据包每经过一个路由器其值就会-1，一旦TTL=0路由器就会将该IP数据包丢弃，并向IP包的发送者发送 ICMP time exceeded消息
TTL主要就是为了防止IP数据包在网络上出现无限的循环跳转，一旦出现循环跳转的话就会比较浪费网络资源
​
MSL Maximum Segment Lifetime最大报文段生存时间，此时间应该是略大于TTL跳转的时间的，也就是说一旦IP包只要送到对方的机器上，那么此包就一定不会超过MSL，想象一下如果MSL小于TTL那么IP包送到了但是TCP包超时了那么就会比较浪费资源，并且因为TCP包是包含在IP包上的，里面的时间按逻辑上就应该大于等于TTL的
所以只要经过了MSL时间，那么TCP包就肯定已经被传输线路上的路由器给丢弃了
​
参考 TCP/IP</description></item><item><title>HTTP协议FAQ</title><link>/2021/03/20/http%E5%8D%8F%E8%AE%AEfaq/</link><pubDate>Sat, 20 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/03/20/http%E5%8D%8F%E8%AE%AEfaq/</guid><description>为什么HTTP/1.1协议不支持服务器端推送 HTTP/1.1规定了只能是 请求-响应 模式，为什么这样设计呢，我个人认为主要有如下几个原因:
客户端和服务器容易实现HTTP协议，简单 当时对页面的实时性，数据量没有现在大 当时并发程度不高 浏览器等客户端以及服务器都是根据HTTP协议进行设计的，所以即使HTTP/1.1能保持TCP的keep-alive一直连接并能被多个HTTP请求复用，但是依然无法实现服务器推送
即使你自己的服务器程序实现了HTTP推送，有些浏览器不支持那也没办法，因为大家都是遵循协议来的
即使服务器和客户端都实现了，那么还有很多代理服务器、缓存服务器、CDN服务器等也可能都没有实现这个HTTP推送，所以依赖无法实现推送
所以有了WebSocket协议，浏览器和服务器双方根据HTTP先握手建立TCP连接，然后进行协议升级，双方就可以根据WebSocket协议进行通讯，服务器就可以拿到TCP句柄进行服务器推送了
请求-应答模式带来了两个问题:
队首阻塞 过多的HTTP通讯，往返延迟加大 HTTP/1.1正是因为这个 请求-应答 模式，在一个TCP连接上一个请求发送之后必须等待响应回来之后才可以用这个TCP连接发送另外一个请求，不然浏览器无法识别应答是哪个请求的应答，所以产生了 HTTP报文队首阻塞问题 只要一个请求的应答阻塞了那么这个请求就必须一直等，之后排队的请求也必须等
为了解决 队首阻塞 问题于是浏览器就为每个用户开辟多个TCP连接来并发的发送多个HTTP请求，因为他们使用不同的TCP连接所以浏览器可以识别哪个应答属于哪个请求，但是一个用户如果TCP连接过多比如一个用户有10个TCP连接，那么1000个用户将会产生1000*10=10000个并发连接，这样会造成服务器压力变大，所以浏览器就必须限制每个用户的TCP并发连接数
并且客户端请求一个页面，发现页面里面包含css、js等资源，于是又发起这些资源的请求，这样起码一个页面会产生多次请求，多次请求都会一个个排队等待响应，这样无形之中又加大了延迟，但是如果有服务器推送，那么在第一次客户端请求这个页面的同时就把页面还有css、js等资源一起推送过去，这样就只需要一次请求即可完成，减少了网络传输的HTTP包减少了请求次数，也降低了延迟
​
为什么 HTTP1.1 不能实现多路复用 HTTP不能实现多路复用是因为一个HTTP请求只能在一个TCP连接里面传输，因为HTTP的报文都是文本形式的，并且是不分帧，如果不在一个TCP连接里面传输的话浏览器就无法识别这个报文响应属于哪个请求，服务器必须将响应报文按原路返回回去
HTTP2则可以实现一个HTTP报文可以在不同的TCP连接里面传输，因为HTTP2的报文是二进制形式将HTTP报文分为一个个的数据帧的，并且有 流 的概念来识别一个请求的响应报文</description></item><item><title>TSL(SSL)协议</title><link>/2021/03/16/tslssl%E5%8D%8F%E8%AE%AE/</link><pubDate>Tue, 16 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/03/16/tslssl%E5%8D%8F%E8%AE%AE/</guid><description>什么是TSL协议 因为HTTP传输都是明文传输的，如果被中间人截获，那么报文内容就会被盗取
为了防止HTTP明文传输，于是可以讲HTTP报文和数据整个进行加密然后再将数据传递给下层的TCP层，传递到客户端再进行解密，TSL协议就是解决HTTP报文加密问题的，被TSL协议加密之后的HTTP协议就叫HTTPS HTTP over SSL 使用的是443端口
TSL是SSL的改进版，现在都是使用TSL来替换SSL了，但是延续了老的叫法，所有都叫SSL 这两个其实是同一个意思
TSL现在广泛使用的版本为TSL1.2 TSL1.3
​
TSL握手第一阶段 加密算法有 对称加密、非对称加密 ，如果将HTTP报文采用非对称加密的话那么带来的CPU运算是非常大的，速度也相对较慢，因为HTTP报文一般数据比较大
所以TSL采用对称加密的方式来加密HTTP报文加快加密解密的速度，但是这里就涉及到如何传递 对称密钥 的问题了，这就是 TSL握手 需要解决的问题，就是生成对称密钥
Client Hello TCP建立之后浏览器会先发送一个Client Hello TSL报文给服务器，目的是为了告诉服务器如下内容，重点关注如下内容:
客户端TSL版本 支持的加密套件Cipher Suites : 使用什么加密算法等，服务器会选择一个加密算法 随机字符串Random1 : 这个随机数和之后的生成对称密钥有关 Session ID 用来恢复会话 SessionTicket 客户端保存的TSL的session信息 Server Hello 服务器接受到客户端的Client Hello之后就会检查客户端版本、加密套件等信息，检查通过并且符合服务器的条件则服务器会进行回复，也就是发送Server Hello包
回复内容主要是告诉客户端如下几个重要的内容:
服务器的TSL版本
从Client Hello中选择一个加密套件，告诉服务器选择了哪个套件
随机字符串Random2 此时客户端和服务器都拥有 Random1、Random2
Session ID 初次握手服务器会返回一个Session ID，客户端会保存这个ID，之后再进行握手发送Client Hello的时候就会携带上这个Session ID，服务器就会直接查询Session ID对应的信息比如对称加密的密钥，这样就可以直接复用了就不需要再次生成了，因为生成过程也有一定的消耗</description></item><item><title>WebSocket协议</title><link>/2021/03/16/websocket%E5%8D%8F%E8%AE%AE/</link><pubDate>Tue, 16 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/03/16/websocket%E5%8D%8F%E8%AE%AE/</guid><description>WebSocket要解决的问题 由于HTTP是请求应答模式，所以如果是聊天室这样的项目的话，那么为了立即获取到信息浏览器就必须进行不断的轮询服务器，不仅效率低下，而且还无法立即获取到数据
于是就有了WebSocket协议，WebSocket是通过HTTP协议进行握手然后再进行通讯的，因为浏览器无法同服务器直接建立TCP连接，所以只能先通过HTTP协议建立一个TCP连接通道，之后再升级协议采用WebSocket协议，这样WebSocket就和HTTP采用相同的端口进行和服务器通讯了
ws://www.chrono.com ws://www.chrono.com:8080/srv wss://www.chrono.com:445/im?user_id=xxx #加密的websocket协议 ​
WebSocket握手 WebSocket握手是通过HTTP协议进行的
首先浏览器请求升级协议
GET /xx HTTP/1.1 Connection: Upgrade Upgrade: websocket Sec-WebSocket-Key: sdadsxxada== Sec-WebSocket-Version: 13 Sec-WebSocket-Key 是一个 Base64的16byte的随机数 用于简单认证，防止误连
然后浏览器返回101响应
HTTP/1.1 101 Switching Protocols Sec-WebSocket-Accept: dsdada Sec-WebSocket-Accept 是把请求头里Sec-WebSocket-Key的值，加上一个专用的 UUID “258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，再计算 SHA-1 摘要，客户端接受到响应之后使用相同的方法计算出摘要然后判断是否相等，相等表示认证成功
握手成功之后传递的就是WebSocket报文了
​
WebSocket报文格式 域 说明 FIN 1bit，是否为信息的最后一帧 RSV 1-3 1bit，备用，默认为0 opcode 4bit，帧类型 1 表示帧内容是纯文本，2 表示帧内容是二进制数据，8 是关闭连接，9 和 10 分别是连接保活的 PING 和 PONG MASK 1bit 掩码，是否用XOR进行简单加密数据。 客户端发送给服务端时，mask必须为1，否则断开连接。 服务端发送给客户端时，mask必须为0，否则断开连接。 payload length 表示帧的长度。它是另一种变长编码，最少 7 位，最多是 7+64 位，一个 WebSocket 帧最大是 2^64 Masking-key 0或32 bit掩码值(Mask为1时才有)，是一个4byte的随机数 Playload data 长度为Payload len的数据，如果有掩码，需要用Masking-Key来异或解密 ​</description></item><item><title>TCP协议</title><link>/2021/03/11/tcp%E5%8D%8F%E8%AE%AE/</link><pubDate>Thu, 11 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/03/11/tcp%E5%8D%8F%E8%AE%AE/</guid><description>TCP协议 面向连接、可靠的字节流传输协议 全双工 可相互传递字节流 只可用于 一对一通信 ，不能用于多播和组播 TCP 使用校验和，确认和重传机制来保证可靠传输 TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制 TCP使用 (源地址，源端口，目的地址，目的端口)来标识一个连接 ​
TCP报文 源端口和目的端口 端口大小为16位，可见端口范围为:0~2^16 也就是[0~65536]
IP层则用ip地址来标识一台主机，TCP层用端口来标识一个应用，使用(源地址，源端口，目的地址，目的端口)唯一确定一个连接，所以对于IPV4的话单台主机最大的连接数为 2^(32+16+32+16) 个
序号 每个TCP包都有一个序号，编号是为了解决TCP包乱序问题，给每个包编上序号就知道了每个包的顺序，这样就可以完整的拼好所有的TCP包了而不造成乱序，TCP给个字节都有一个序号，序号是整个TCP包数据段的第一个字节的序号，比如现在一个包的起始序号为101，数据长度为500byte ，那么最后一个字节的序号就为600，这个TCP包的序号为第一个字节的序号101 ，所以下一个TCP包的第一个字节的序号应该为601，也就是下一个TCP包的序号为601
如果序号达到最大值2^32，则回卷到0
由于初始的seq号是随机生成的，所以TCP回绕到0之后怎么继续保持字节序呢?怎么判断字节序呢?
回绕之后遇到相同的seq号则可以根据TCP头部携带的时间戳来判断前后
确认号 设置TCP包的确认号是为了告诉对方上一个数据包已经确认收到了，你可以继续发送下一个TCP包了，这个确认号填的就是期望对方发送的下一个TCP包的 序号
比如B收到了A发的序号为101的TCP包，该包长度为500byte，B现在收到了A发的600byte之前的数据，期望A发送下一个序号为601的TCP包，所以确认号为601
A收到B的回复的确认号为601得知B已经收到了A发的600byte之前的数据，现在要发下一个序号为601的TCP包了
首部长度 长度为4位
指出TCP首部的大小，因为TCB首部中有可选择字段，所以每个TCB首部都是不定长的，所以需要指定首部长度，单位是4字节 ，最大为2^4 ，所以首部最大长度为16*4byte=60byte
保留位 6位，保留以后使用，目前全部置0
五大标志位 6位
标志 含义 URG 紧急位，为1的话则表示这是个紧急的TCP包，应该放到发送队列的最前面去立即发送 ACK ACK=1表示确认号有效，ACK=0表示确认号无效，TCP连接建立成功后所有的传输报文必须把ACK置为1 PSH 很少用到，一般为0 RST 复位 RST=1 表示TCP连接出错，必须释放连接重新建立 SYN 同步 SYN=1表示这是一个请求建立连接或接受建立连接请求报文 SYN=1 ACK=0表示这是一个建立连接请求，SYN=1 ACK=1表示这是一个应答建立连接请求的TCP报文，详情请参考TCP三次握手 FIN 用来释放连接， FIN=1 表示数据已经发送完毕并且请求释放TCP连接 窗口大小 TCP使用 滑动窗口 来实现拥塞控制和流量控制，详情请见下文，比如B响应给A的报文中窗口字段的大小为1000 ，确认号为101 目的就是为了告诉A可以发送101开始的数据包了，缓存空间大小为1000byte，也就是还可以接受101~1101字节范围的数据包</description></item><item><title>HTTP协议</title><link>/2021/03/08/http%E5%8D%8F%E8%AE%AE/</link><pubDate>Mon, 08 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/03/08/http%E5%8D%8F%E8%AE%AE/</guid><description>请求和响应报文 请求报文第一行必须指定 请求的方法、资源路径、HTTP协议版本
紧接着就是请求头信息
然后还需要一个空行
紧接着如果有请求体的话就是请求体，注意如果没有请求体也必须加一个空行
GET /note/ef1b6cee.html HTTP/1.1 Host: www.ru23.com Connection: keep-alive Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) ....各个请求头 &amp;lt;空行&amp;gt; 响应报文第一行必须指定 HTTP协议版本、状态码、状态码的字符串简短描述
紧接着就是响应头信息
然后还需要一个空行
如果有响应体的化就需要一个响应体，没有的话空行也是必须的
HTTP/1.1 200 OK Server: nginx/1.16.1 Date: Sun, 04 Oct 2020 02:27:01 GMT Last-Modified: Sun, 30 Aug 2020 14:12:42 GMT Content-Type: text/html Content-Length: 40846 Accept-Ranges: bytes &amp;lt;!</description></item><item><title>网络分层和协议栈总览</title><link>/2021/03/05/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E5%92%8C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%80%BB%E8%A7%88/</link><pubDate>Fri, 05 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/03/05/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E5%92%8C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%80%BB%E8%A7%88/</guid><description>OSI七层模型和TCP/IP五层模型 ​
为什么网络要分层 复杂的计算机程序都需要通过分层来设计，这是一种设计模式，通过分层每层各司其职，每层都可以独立升级和维护
​
TCP/IP协议栈 1、应用层 协议 全名 功能 基于/端口 HTTP Hypertext Transfer Protocol web TCP/80 HTTPS Hypertext Transfer Protocol Secure 加密的HTTP SSL/TSL/443 SSL/TSL Secure Socket Layer/Transport Layer Security 加密协议 FTP File Transfer Protocol 传输文件 TCP/21(控制)/20(数据传输) SSH Secure Shell 连接远程Linux主机 TCP/22 SFTP SSH File Transfer Protocol SSH加密的FTP SSH/22 DNS Domain Name System IP和域名的解析转化 UDP/TCP/53 SMTP Simple Mail Transfer Protocol 邮件收发 TCP/25 POP3 Post Office Protocol-Version 3 收邮件 TCP/110 RPC Remote Procedure Call 调用远程的函数 TCP/随机 DHCP Dynamic Host Configuration Protocol 在局域网中动态分配IP UDP/67(接收)/68(请求) 2、传输层 协议 全名 功能 TCP Transmission Control Protoco 可靠的传递网络数据包 QUIC Quick UDP Internet Connections Google研发的基于UDP的传输层协议，用于替换TCP 2、网络层 协议 全名 功能 IP Internet Protocol 广域网传递数据包 ARP Address Resolution Protocol 根据IP获取MAC ICMP Internet Control Message Protocol 传递网络控制信息，需要加上IP报头组成IP数据报发送 ​</description></item></channel></rss>