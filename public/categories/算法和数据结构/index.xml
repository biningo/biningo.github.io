<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>算法和数据结构 - 分类 - lyer's blog</title><link>/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><description>算法和数据结构 - 分类 - lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Fri, 19 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="self" type="application/rss+xml"/><item><title>完全二叉树和满二叉树</title><link>/2021/03/19/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Fri, 19 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/03/19/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>满二叉树 如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树
满二叉树有如下几个性质:
满二叉树第i层节点的个数2^(i-1)
深度为n的满二叉树必须有2^(n)-1个节点，叶子节点有2^(n-1) (也就是最后一层的节点数量)
满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树
具有 n 个节点的满二叉树的深度为 log2(n+1)
第i个节点的左右孩子分别为i*2+1 i*2+2 (孩子节点从0开始算起，如果孩子节点从1开始算起的话就是i*2 i*2+1 )
第i个节点的父亲节点i/2-1 ，如果从1开始算起就是i/2
​
完全二叉树 结点依次从左到右分布，中间无法断开，则此二叉树被称为完全二叉树，完全二叉树适合用数组来存储
第i个节点的左右孩子分别为i*2+1 i*2+2 (孩子节点从0开始算起，如果孩子节点从1开始算起的话就是i*2 i*2+1 )
第i个节点的父亲节点i/2-1 ，如果从1开始算起就是i/2
注意上面的计算要注意范围
堆就是用完全二叉树来实现的</description></item><item><title>快速排序</title><link>/2021/02/18/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link><pubDate>Thu, 18 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/18/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid><description>快排思想 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列
就是需要确定一个 pivot支点，然后将小于pivot的放到左边，大于pivot的放到右边，此时pivot就已经排好序了，然后再分别对两别进行递归排序
所以快排主要需要解决下面两个问题:
pivot的选择 如何把元素放到左边和右边，也就是如何确定pivot的位置 ​
复杂度分析 最优时间复杂度: O(nlogn) 最优空间复杂度: O(logn)
pivot每次都平分，计算时间复杂度过程和 归并排序一样计算
空间复杂度主要是递归栈的空间，看递归树的高度，比如50,10,90,30, 70,40,80,60,20 这个序列，递归深度如下，这是一颗平衡二叉树，高度是数组个数的 logn倍
最差时间复杂度: O(n^2) 最差空间复杂度: O(n)
pivot每次取最大最小值，退化为 冒泡排序 冒泡排序的时间复杂度：
T[n] = n * (n-1) = n^2 + n = O(n^2) 空间复杂度就是树的高度，单边树的高度就是元素的个数，所以空间复杂度为O(n)
​
pivot支点的选择 支点只要能将两边平均分就是最好的支点，主要有如下几个选法:
选第一个/最后一个 选中间一个 随机选一个 三数取中法: 选 开头、结尾、中间 的数中大小排中间的数 为了便于算法实现，需要取中间某个Pivot时，可以通过交换元素，转换成取第一个（或最后一个）
//随机 pivot := rand.Intn(end+1-start) + start //三数取中 func getMiddle(arr []int, start, end int) int { mid := start + (end-start)/2 if arr[start] &amp;gt; arr[mid] { mid, start = start, mid } if arr[mid] &amp;gt; arr[end] { mid, end = end, mid } return mid } ​</description></item><item><title>十大排序算法</title><link>/2021/02/17/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link><pubDate>Wed, 17 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/17/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid><description><![CDATA[更新中&hellip;..
 冒泡排序  稳定排序 最好时间复杂度: O(n) 基本有序状态，进行1次冒泡 最坏时间复杂度: O(n^2) 逆序状态，需要进行n次冒泡 平均时间复杂度: O(n^2) 空间复杂度: O(1)  func BubbleSort(arr []int) { flag := true for i := 0; i &lt; len(arr); i++ { for j := 0; j &lt; len(arr)-i-1; j++ { if arr[j] &gt; arr[j+1] { flag = false arr[j], arr[j+1] = arr[j+1], arr[j] } } if flag { break } } } ​
选择排序  不稳定排序 比如 5 8 5 2 9 两个相同的5会发生位置交换 最好时间复杂度: O(n^2) 最坏时间复杂度: O(n^2) 平均时间复杂度: O(n^2) 空间复杂度: O(1)  每次选择剩余排序区间中最小(大)的元素放入排序好的区间的最后一个位置中]]></description></item></channel></rss>