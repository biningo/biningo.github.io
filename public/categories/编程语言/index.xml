<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>编程语言 - 分类 - lyer's blog</title><link>/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</link><description>编程语言 - 分类 - lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Fri, 12 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="self" type="application/rss+xml"/><item><title>Go命令行</title><link>/2021/02/12/go%E5%91%BD%E4%BB%A4%E8%A1%8C/</link><pubDate>Fri, 12 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/12/go%E5%91%BD%E4%BB%A4%E8%A1%8C/</guid><description>go build 将代码编译为相关平台的可执行文件，只需要编译带有main的入口文件即可
go build #会寻找当前目录下main入口文件然后进行编译 go build -o main #指定生成可执行文件的名字 go build mymain.go #也可以编译指定的go文件 ​
go env 用于管理go的环境变量相关信息，go相关环境变量也可在.bashrc等文件里面设置，优先级高
go env #打印所有go的环境变量 go env GOPROXY #打印某个环境变量的值 go env -json #json格式输出 go env -w GOPROXY=https://goproxy.cn,direct #修改某个值 这里设置了中国代理，direct表示如果代理没有则直接走go官网，可以设置多个代理网站，用逗号分割 ​
go fmt和gofmt go fmt是对gofmt的封装，直接使用gofmt即可，格式化如果不加-w是不会改变源代码的，所以最常用的就是：
gofmt -w ./ #格式化当前项目，并且会修改原文件而不是输出到控制台 还有一些其他命令，看看就行
gofmt test.go #格式化单个文件 gofmt ./viper/ #格式化整个目录文件 gofmt -l ./viper/ #列出哪些文件格式化前后会出现不同(只是列出 不进行格式化) gofmt -w ./viper/ #执行格式化 并且写入源代码 ​
go get 最重要的一个工具，用于获取go依赖，类似于pip、maven、npm等 go的包管理采用go mod的方式，每个项目都必须有一个go.mod依赖声明文件，里面列出了自己的项目依赖了哪些项目，以及依赖项目的版本信息，在项目下面执行go get [url]即可下载依赖并且将依赖项自动添加到go.mod文件中</description></item><item><title>Python并发和GIL锁</title><link>/2021/01/31/python%E5%B9%B6%E5%8F%91%E5%92%8Cgil%E9%94%81/</link><pubDate>Sun, 31 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/01/31/python%E5%B9%B6%E5%8F%91%E5%92%8Cgil%E9%94%81/</guid><description><![CDATA[GIL全局解释器锁 在单核时代，Python为了解决多个线程并发访问数据造成数据不安全问题，在语言层面就实现了一种机制，就是给一个进程中的多个并发线程设置一把锁，只有抢到锁的线程才可以在CPU上执行，没有锁的线程只能等待。这样就可以控制在同一时刻内对数据的访问只有一个线程（其实这也无法保证线程安全）所以这把锁就叫做 GIL锁
也就是说Python的多线程并发在单核时代可以有效控制线程安全问题，但是到了多核时代，即使有多个核，同一时刻也只能有一个线程在执行（因为同一个进程内的多个线程中只有一把GIL锁）
比如现在有 a、b、c、d三个线程和1、2、3、4号CPU核，如果是其他语言，则在同一个时刻四个线程可以同时并发的跑在4个核上运行，但是Python因为有了一把GIL锁 现在a抢到锁了，那么b、c、d只能干巴巴的等待a主动释放锁才可以继续抢锁才有机会执行，即使有4个核也无法充分利用，所以语言层面上创建了4个线程但最终也相当于串行执行
def my_task(): i = 0 for _ in range(10000000): i = i + 1 @metric def f1(): for t in range(2): t = threading.Thread(target=my_task) t.start() t.join() @metric def f2(): arr = [] for t in range(2): t = threading.Thread(target=my_task) t.start() arr.append(t) for t in arr: t.join() ​
GIL锁真的安全吗？ GIL锁其实并非安全，线程在下面三种情况下回主动释放锁：
 不间断执行字节码&gt;1000 执行时间&gt;15ms IO操作  现在有一个全局变量count=0，假设t1线程拿到count准备count+=1的时候，t1的连续执行时间恰好&gt;15ms了或则执行的字节码&gt;1000了，此时t1就会主动释放锁，被t2抢到了，t2执行count+=1此时的count==1，后来t1再次执行的时候count=0，count+=1，count==1，正确的结果应该是count=2
也就是说GIL锁并不能百分之百保证线程安全，只有在循环比较短，执行代码比较少的情况下才可以百分之百保证线程安全
count=0 def add_cpu(max_num): global count for i in range(max_num): count+=1 def f5(max_num): arr = [] for t in range(10): t = threading.]]></description></item></channel></rss>