<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>OS - 标签 - lyer's blog</title><link>/tags/os/</link><description>OS - 标签 - lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Wed, 24 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="/tags/os/" rel="self" type="application/rss+xml"/><item><title>中断</title><link>/2021/03/24/%E4%B8%AD%E6%96%AD/</link><pubDate>Wed, 24 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/03/24/%E4%B8%AD%E6%96%AD/</guid><description>中断分类 中断按照是否由CPU内部发生分为:
外部中断 (由CPU外部引发，比如外设、网卡等) 内部中断 (由CPU内部引发，比如系统调用) 外部中断分为:
可屏蔽中断 (比如网卡发出数据读取中断，可以屏蔽) 不可屏蔽中断 (比如掉电、设备损坏等) 内部中断分为:
软中断 (由软件程序触发，比如系统调用0x80号中断) 异常 (异常也是一种特殊的中断，比如除0异常、缺页异常) ​
中断产生和调用原理 触发中断其实就是给出一个 中断号 ，然后CPU根据中断号去查找中断对应的程序进行执行的一个过程
操作系统会设置一个 IDT中断描述符表 ，里面记载了各个中断号对应的程序的入口地址，操作系统内核在运行初始化的时候必须初始化 中断寄存器指向的位置 ，因为一旦发生中断CPU就会去中断寄存器指向的IDT中去寻找中断程序
发生中断时用户态就会转化为内核态，CPU会保存程序当前执行的状态，比如会将栈指针、各个寄存器值、PC指针压入内核栈，然后开始执行中断处理程序，执行完毕之后再恢复现场，也就是将栈中的值都出栈然后放到各个寄存器中继续执行之前的代码
那么这个中断是如何引发的呢?
软中断和异常容易理解，CPU有一个int指令，后面跟给一个中断号，程序只需要执行这个指令即可触发软中断或异常，最常见的软中断就是int 0x80中断，此中断是系统调用中断，所有的系统调用都会触发这个中断，系统调用中断还需要给出 系统调用号 ，系统调用中断处理程序会根据系统调用号去执行相应的系统调用代码
外中断需要经过一个叫 中断代理 的硬件，该硬件连接了所有外设接口的中断线，外设如果需要引发中断则只需要往这个中断线里面传输信号到中断代理即可，中断代理会根据不同的信号转化为相应的 中断号 ，中断代理和CPU只连接了两条线: INTR和NMI INTR表示可屏蔽中断，比如网卡发出的中断、NMI表示不可屏蔽中断
可屏蔽中断的话只需要CPU设置状态寄存器中相应的位就表示屏蔽这些中断，注意: 软中断、异常都是会忽略该位的 也就是说软中断和异常都是不可屏蔽的，软中断通常来说是系统调用，用户进程需要系统调用则操作系统必须响应，否则会造成用户程序卡死无法获得操作系统提供的帮助，会造成用户体验不好，异常更不用说了，需要立即处理
中断代理将相应的中断号输出到INTR线中通知CPU，CPU没执行一条指令都会检查该线是否有中断信号(注意:CPU检查中断是由硬件电路来实现的，并不会有任何的损耗)
如果有中断信号则CPU会立即检测到
​
中断的上半部分和下半部分 一个中断程序可以分为 上部分和下部分 ，中断处理时可以先执行上半部分，这个部分一般来说比较紧急，等CPU空闲之后再继续执行下半部分
比如网卡发出数据读取操作，此时CPU先执行上半部分的中断程序：先将网卡缓存区里的数据拷贝到内核数据区，这个网卡就不会因为缓存区满而频繁丢包了(相当于一个紧急救火)，然后等CPU空闲了之后再执行中断下半部分，也就是将内核数据区域的数据拷贝到用户空间供用户使用
​
操作系统时钟中断 这个时钟和CPU的时钟不是一个概念，但是他们的功能都是差不多的，都是为了使操作系统或则CPU能正确的工作，时钟就相当于一个 节拍器，很多硬件设备也有时钟，为的就是让各个电路有序的进行操作
操作系统的时钟中断由 可编程的脉冲器 产生的，因为操作系统需要和硬件配合的，所以一般和硬件结合的比较紧密，该硬件脉冲频率是和操作系统厂商商量好的，并且可以人为的编程去改变脉冲的频率
时钟中断会定时的引发然后传递到CPU的NMI引脚，时钟中断属于不可屏蔽中断
时钟中断的作用非常大，可以说没有时钟中断操作系统就没有控制权，时钟中断的作用如下:
更新系统的时间 定时的将控制权转移到操作系统的程序中，以便操作系统进行各个调度工作比如进程时间片调度，每经过一个时钟则时间片减一 (如果没有时钟中断，那么如果用户程序如果一直不进行系统调用、不引发异常那么操作系统可能永远也拿不到CPU的控制权) ​</description></item><item><title>文件系统</title><link>/2021/01/28/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Thu, 28 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/01/28/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid><description>VFS虚拟文件系统 虚拟文件系统就是给文件系统的实现提供一个接口，好处有下面几个：
为用户进程提供一组操作文件/目录/其他对象的统一方法，方便操作 为下层文件系统的具体实现提供统一的接口，让操作系统能适配多个文件系统 在每个分区上必须安装文件系统，这样操作系统才可以操作磁盘和文件，不然操作系统是无法使用磁盘的，在分区上安装文件系统其实就是增加一些文件系统对磁盘的管理数据，同时将分区划分为一个个数据块，安装文件系统的过程就叫 分区格式化 格式化之后分区的主要结构如下：
1、引导块
存放引导操作系统启动的代码程序，每个分区都有一个引导块，这样可以实现多系统，只需要在MBR或EFI系统上放置一个bootloader，该bootloader就会确定活动分区（通常由用户在启动界面选择启动哪个系统），然后就会跳转到响应的 活动分区中的引导块中加载引导块中的代码到内存进行执行，然后就会加载该活动分区中的操作系统
2、super block 超级块
super block在索引导块后面，主要包含整个文件系统的一些基本元数据：
文件系统设置的数据块大小（一个数据块通常占据整数个扇区比如：8个扇区 4k大小） 文件系统中的数据块数 空闲块数 空闲的inode节点数 &amp;hellip;&amp;hellip;. 操作系统在启动之后就会将super block从磁盘加载到内存，然后建立 super_block对象，该对象是常驻内存的
3、空闲块位图和inode位图
空闲区块位图： 管理整个分区中空闲的数据块，占用多个数据块block
inode位图 ：管理整个分区中inode的使用和分配，占用多个数据块block
4、inode节点区块
是一个数组结构，存放整个文件系统的inode信息，每个inode就代表一个文件，inode节点个数代表该文件系统最多能创建多少个文件，inode节点存放的具体内容在下文inode对象 中说明
​
​
VFS四大对象 super_block inode dentry file 1、super_block 包含了整个文件系统的重要信息：inode个数、数据块大小、数据块个数 常驻内存 每个分区都有一个super_block，多个super_block对象用链表链接，df命令读取的就是所有的super_block，因为常驻内存所以读取数度非常快，所有对文件系统的修改都要修改super_block 每个super_block都有对应自己的操作函数 struct super_block { struct list_head s_list; // 指向所有超级块的链表 const struct super_operations *s_op; // 超级块相关操作的方法 struct dentry *s_root; // 目录挂载点 struct mutex s_lock; // 超级块信号量 int s_count; // 超级块引用计数 .</description></item><item><title>磁盘和分区</title><link>/2021/01/23/%E7%A3%81%E7%9B%98%E5%92%8C%E5%88%86%E5%8C%BA/</link><pubDate>Sat, 23 Jan 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/01/23/%E7%A3%81%E7%9B%98%E5%92%8C%E5%88%86%E5%8C%BA/</guid><description>磁盘物理结构 盘面：一个机械磁盘有好几个盘面组成，中间有转轴
磁头：盘面正反两面都可以使用，每个盘面都有一个磁头，用来读写这个盘面的数据
磁道：盘面被物理划分为多个磁道
扇区：每个磁道会被划分为多个固定512byte大小的扇区（现在也有4k扇区），扇区是磁盘数据存储的最小单位。整个磁盘0盘面0磁道第一个1扇区最重要，记录了整个磁盘的分区信息和操作系统启动程序，计算机启动之后首先加载第一个扇区的信息到内存
柱面：每个盘面的同一个磁道组成柱面，磁盘的读写顺序就是按照柱面来的，写入时按顺序先写满一个柱面（一个盘面的磁道数据写满后再激活下一个盘面的磁头）然后再移动磁头臂写另外一个柱面，读数据也是按照这个顺序读
磁盘在出厂前需要进行低级格式化：就是给磁盘划分磁道、扇区。这些属于硬件层面，OS无法控制
​
​
磁盘寻址方式 早期所有磁道的扇区个数一样，采用CHS方式寻址，这种划分方式外磁道颗粒稀疏，存储密度小，造成空间浪费
现在的磁盘外磁道的扇区个数大于内道，存储密度都一样了，采用LBA寻址
1、CHS寻址 CHS寻址方式的容量由CHS三个参数决定：(柱面,磁头,扇区)
早期磁盘的每个磁道的扇区数一样多 ，整体磁盘大小也很小。所以在设计时用了24位地址来确定一个扇区：10+8+6
柱面数最大为1024(用 10 个二进制位存储)。从0开始编号（一个盘面最多能划1024个磁道）
磁头数最大为256 (用 8 个二进制位存储)。从0开始编号，(最多有256个盘面)
一个盘面中的扇区数最大数 64(用 6个二进制位存储)
最大寻址空间：1024*256*64*512byte=8414461440 byte = 8G+
2、LBA寻址 现代机械磁盘容量变大，主要有如下几个改变：
磁盘面的磁颗粒更高密+磁头更稳定更细(影响C柱面数) 磁盘面的磁颗粒均匀分布（影响S扇区数） 磁盘增加磁盘盘面（影响H盘面数） 同时采用 LBA逻辑块地址寻址，线性地址，给每个扇区一个编号(0-最后一个扇区号)
LBA将CHS这种三维寻址方式转变为一维的线性寻址，它把硬盘所有的物理扇区(柱面号/盘面号/扇区号) 编号通过一定的规则转变为一维线性的编号，系统效率得到大大提高，避免了 烦琐的(磁头/柱面/扇区)的寻址方式。在访问硬盘时，由硬盘控制器再这种逻辑地址转换为实际硬盘的物理扇区地址
​
​
磁盘分区 1、什么是磁盘分区 磁盘分区就是把一整块磁盘切割为几个部分，相当于 win的 C、E、D盘，Linux的/dev/sda1、/dev/sda2&amp;hellip; 可以把磁盘看做一块原木，分区就是在原木上做一个桌子、椅子</description></item></channel></rss>