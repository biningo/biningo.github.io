<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>排序算法 - 标签 - lyer's blog</title><link>/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link><description>排序算法 - 标签 - lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Thu, 18 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="self" type="application/rss+xml"/><item><title>快速排序</title><link>/2021/02/18/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link><pubDate>Thu, 18 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/18/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid><description>TODO</description></item><item><title>十大排序算法</title><link>/2021/02/17/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link><pubDate>Wed, 17 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/17/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid><description>冒泡排序 稳定排序 最好时间复杂度: O(n) 基本有序状态，进行1次冒泡 最坏时间复杂度: O(n^2) 逆序状态，需要进行n次冒泡 平均时间复杂度: O(n^2) 空间复杂度: O(1) func BubbleSort(arr []int) { flag := true for i := 0; i &amp;lt; len(arr); i++ { for j := 0; j &amp;lt; len(arr)-i-1; j++ { if arr[j] &amp;gt; arr[j+1] { flag = false arr[j], arr[j+1] = arr[j+1], arr[j] } } if flag { break } } } ​
选择排序 不稳定排序 比如 5 8 5 2 9 两个相同的5会发生位置交换 最好时间复杂度: O(n^2) 最坏时间复杂度: O(n^2) 平均时间复杂度: O(n^2) 空间复杂度: O(1) 每次选择剩余排序区间中最小(大)的元素放入排序好的区间的最后一个位置中</description></item></channel></rss>