<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>缓存 - 标签 - lyer's blog</title><link>/tags/%E7%BC%93%E5%AD%98/</link><description>缓存 - 标签 - lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Mon, 31 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="/tags/%E7%BC%93%E5%AD%98/" rel="self" type="application/rss+xml"/><item><title>HTTP缓存</title><link>/2021/05/31/http%E7%BC%93%E5%AD%98/</link><pubDate>Mon, 31 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/31/http%E7%BC%93%E5%AD%98/</guid><description><![CDATA[浏览器缓存原理 浏览器会把请求的URL作为key，value就是此次请求对应的响应。每次查找缓存的时候就会到内存或则磁盘去查找key对应的响应信息即可
​
Cache-Control 强缓存 Cache-Control 控制浏览器缓存的时间，注意此头部是通用头部，请求和响应都可以有
如果是服务器响应头部的话则是告诉浏览器此信息可以缓存多久，下面的报文表示可以缓存10s
GET /ping HTTP/1.1 Cache-Control: max-age=10 Content-Length: 4 Content-Type: application/json; charset=utf-8 Date: Tue, 01 Jun 2021 13:23:49 GMT 比如我现在一个重定向到此请求，则下次重定向就不需要再次请求/ping了，直接从缓存里面读取，下面是go后端演示程序
func main() { r := gin.Default() r.GET(&#34;/ping&#34;, func(context *gin.Context) { context.Header(&#34;Cache-Control&#34;, &#34;max-age=10&#34;) context.JSON(200, &#34;OK&#34;) }) r.GET(&#34;/a&#34;, func(context *gin.Context) { context.Header(&#34;Location&#34;, &#34;/ping&#34;) context.Status(302) //临时重定向 不会被浏览器缓存 每次请求都会打到后端 	}) r.GET(&#34;/b&#34;, func(context *gin.Context) { context.Header(&#34;Location&#34;, &#34;/ping&#34;) context.Status(301) //永久重定向 会被浏览器缓存 下次请求此则直接从缓存中读取响应报文 然后直接重定向到/ping 	}) r.Run(&#34;:8080&#34;) } 用户主动刷新、地址栏重新输入、ctrl+f5强制刷新等动作浏览器会自动的在请头中设置Cache-Control的值为max-age=0 或则 no-cache ，表示直接请求服务器而不从缓存中读取，不管缓存是否过期都会请求服务器]]></description></item></channel></rss>