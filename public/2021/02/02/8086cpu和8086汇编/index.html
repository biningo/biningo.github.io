<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>8086CPU和8086汇编 - lyer&#39;s blog</title><meta name="Description" content=""><meta property="og:title" content="8086CPU和8086汇编" />
<meta property="og:description" content="CPU架构、指令集、汇编   指令集是人们发明出来的东西，指令就是CPU执行具体操作的一个代号，比如0000代表什么指令，0001代表什么指令，一条机器指令进过 指令译码器 之后就转化为响应的电路信号从而实现特定的操作
  指令集决定了处理器的架构，因为处理器架构就是用硬件电路实现指令集
CPU架构又叫微架构，就是由一些硬件电路构成来实现指令集所规定的操作
  因为机器指令都是01组成的数字，非常难排错和编程，于是人们就用英文符号来指示一条指令，然后通过汇编程序来将这些符号转化为01机器指令
  ​
CPU的前世今生 世界上最著名的CPU厂商有：
 intel AMD（比intel晚出现） ARM  intel公司生产的CPU主要有：8086(16位)、8088、80386、i386(扩展到32位)、i486&hellip;.
上面的CPU都是早期生产的CPU，现代的intel CPU主要有：酷睿&gt;奔腾&gt;赛扬（性能比较）
​
AMD公司生产的CPU主要有：锐龙&gt;AMD FX&gt;APU&gt;速龙&gt;闪龙 （性能比较）
因为intel早期生产的CPU都是以86结尾的，所以intel的CPU就称为x86系列
在16位CPU时代，intel的CPU采用了x86-16指令集，到了32位CPU时代intel采用了IA32指令集，所以采用IA32指令集的CPU也称为x86架构CPU（因为指令集决定了CPU底层电路设计和架构嘛）
当初Intel因为产能不足，IBM要求增加第二供应商，于是Intel将x86指令集授权给了AMD等一众厂商，这也是为什么有AMD的存在，intel没有把CPU底层如何实现这些指令的CPU架构告诉AMD，AMD用授权的x86指令集设计了自己的CPU，所以intel上运行的软件也可以在AMD上运行
在64位时代intel自己搞了IA64（和IA32不兼容，全新的指令集）并且重新设计了CPU架构，AMD搞了AMD64（基于IA32）最后IA64因为不兼容IA32而失败，AMD64就变成了现在的x86-64又叫amd64、x64。
因为x86-64的授权在AMD，于是AMD与Intel达成交叉授权，AMD继续使用x86架构。这就是为什么现在市面上有AMD和Intel共存的原因，他们都是兼容x86-64架构
x86指令集(IA32)（包括amd64）是属于 CISC 风格的指令集
 RISC和CISC的区别可以看这篇文章：http://www.vsdiffer.com/risc-vs-cisc.html
 ARM CPU采用ARM指令集，该指令集属于 RISC 风格（MIPS指令集也是采用此风格）
ARM架构的CPU主要用在移动设备等小型设备，因为采用了RISC风格的指令集，所以 体积小、低功耗、低成本、高性能
这里总结一下：
 指令集风格分为：RISC、CISC 著名的CPU指令集：IA32(x86)、amd64/x86_64(基于IA32,兼容IA32)、ARM、MIPS 著名的CPU厂商：intel、AMD、生产ARM CPU的相关厂商(ARM公司只是发明了指令集并授权给其他公司收专利费，并不生产CPU) RISC为代表的指令集：IA32(x86)、amd64/x86_64 CISC为代表的指令集：ARM、MIPS 现在RISC和CISC的界限变得模糊了，相互借鉴对方的优点  ​
CPU和总线结构 CPU通过总线于外部进行交互，总线分为三类：
 数据总线： 传输数据 控制总线： 传输控制信息比如读、写 地址总线： 传输数据的地址  注意地址读写操作不只是针对主存的，主存只是主板上最重要的一部分，总线还和其他设备接口进行相连的，所以给出的地址不只是主存上的地址，还可能是主板上其他设备的地址，操作这部分地址就相当于操作这些接口的内部存储器等部件，所以逻辑上都可以将 外设&#43;内存 看做是一块逻辑空间，所有就有了 外设映射到内存地址 这一说法，物理上只是将这些线分配连接到了其他接口部件而已" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/2021/02/02/8086cpu%E5%92%8C8086%E6%B1%87%E7%BC%96/" />
<meta property="article:published_time" content="2021-02-02T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-02-02T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="8086CPU和8086汇编"/>
<meta name="twitter:description" content="CPU架构、指令集、汇编   指令集是人们发明出来的东西，指令就是CPU执行具体操作的一个代号，比如0000代表什么指令，0001代表什么指令，一条机器指令进过 指令译码器 之后就转化为响应的电路信号从而实现特定的操作
  指令集决定了处理器的架构，因为处理器架构就是用硬件电路实现指令集
CPU架构又叫微架构，就是由一些硬件电路构成来实现指令集所规定的操作
  因为机器指令都是01组成的数字，非常难排错和编程，于是人们就用英文符号来指示一条指令，然后通过汇编程序来将这些符号转化为01机器指令
  ​
CPU的前世今生 世界上最著名的CPU厂商有：
 intel AMD（比intel晚出现） ARM  intel公司生产的CPU主要有：8086(16位)、8088、80386、i386(扩展到32位)、i486&hellip;.
上面的CPU都是早期生产的CPU，现代的intel CPU主要有：酷睿&gt;奔腾&gt;赛扬（性能比较）
​
AMD公司生产的CPU主要有：锐龙&gt;AMD FX&gt;APU&gt;速龙&gt;闪龙 （性能比较）
因为intel早期生产的CPU都是以86结尾的，所以intel的CPU就称为x86系列
在16位CPU时代，intel的CPU采用了x86-16指令集，到了32位CPU时代intel采用了IA32指令集，所以采用IA32指令集的CPU也称为x86架构CPU（因为指令集决定了CPU底层电路设计和架构嘛）
当初Intel因为产能不足，IBM要求增加第二供应商，于是Intel将x86指令集授权给了AMD等一众厂商，这也是为什么有AMD的存在，intel没有把CPU底层如何实现这些指令的CPU架构告诉AMD，AMD用授权的x86指令集设计了自己的CPU，所以intel上运行的软件也可以在AMD上运行
在64位时代intel自己搞了IA64（和IA32不兼容，全新的指令集）并且重新设计了CPU架构，AMD搞了AMD64（基于IA32）最后IA64因为不兼容IA32而失败，AMD64就变成了现在的x86-64又叫amd64、x64。
因为x86-64的授权在AMD，于是AMD与Intel达成交叉授权，AMD继续使用x86架构。这就是为什么现在市面上有AMD和Intel共存的原因，他们都是兼容x86-64架构
x86指令集(IA32)（包括amd64）是属于 CISC 风格的指令集
 RISC和CISC的区别可以看这篇文章：http://www.vsdiffer.com/risc-vs-cisc.html
 ARM CPU采用ARM指令集，该指令集属于 RISC 风格（MIPS指令集也是采用此风格）
ARM架构的CPU主要用在移动设备等小型设备，因为采用了RISC风格的指令集，所以 体积小、低功耗、低成本、高性能
这里总结一下：
 指令集风格分为：RISC、CISC 著名的CPU指令集：IA32(x86)、amd64/x86_64(基于IA32,兼容IA32)、ARM、MIPS 著名的CPU厂商：intel、AMD、生产ARM CPU的相关厂商(ARM公司只是发明了指令集并授权给其他公司收专利费，并不生产CPU) RISC为代表的指令集：IA32(x86)、amd64/x86_64 CISC为代表的指令集：ARM、MIPS 现在RISC和CISC的界限变得模糊了，相互借鉴对方的优点  ​
CPU和总线结构 CPU通过总线于外部进行交互，总线分为三类：
 数据总线： 传输数据 控制总线： 传输控制信息比如读、写 地址总线： 传输数据的地址  注意地址读写操作不只是针对主存的，主存只是主板上最重要的一部分，总线还和其他设备接口进行相连的，所以给出的地址不只是主存上的地址，还可能是主板上其他设备的地址，操作这部分地址就相当于操作这些接口的内部存储器等部件，所以逻辑上都可以将 外设&#43;内存 看做是一块逻辑空间，所有就有了 外设映射到内存地址 这一说法，物理上只是将这些线分配连接到了其他接口部件而已"/>
<meta name="application-name" content="lyer&#39;s blog">
<meta name="apple-mobile-web-app-title" content="lyer&#39;s blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="/2021/02/02/8086cpu%E5%92%8C8086%E6%B1%87%E7%BC%96/" /><link rel="prev" href="/2021/02/01/%E4%BF%A1%E6%81%AF%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%A1%A8%E7%A4%BA/" /><link rel="next" href="/2021/02/04/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84linux%E7%BB%88%E7%AB%AF%E7%8E%AF%E5%A2%83/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "8086CPU和8086汇编",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "\/2021\/02\/02\/8086cpu%E5%92%8C8086%E6%B1%87%E7%BC%96\/"
        },"genre": "posts","keywords": "基础, 汇编, CPU","wordcount":  179 ,
        "url": "\/2021\/02\/02\/8086cpu%E5%92%8C8086%E6%B1%87%E7%BC%96\/","datePublished": "2021-02-02T00:00:00+00:00","dateModified": "2021-02-02T00:00:00+00:00","publisher": {
            "@type": "Organization",
            "name": "lyer"},"author": {
                "@type": "Person",
                "name": "lyer"
            },"description": ""
    }
    </script></head>
    <body header-desktop="" header-mobile=""><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : '' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="lyer&#39;s blog">lyer&#39;s blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> archive </a><a class="menu-item" href="/tags/"> tag </a><a class="menu-item" href="/categories/"> category </a><a class="menu-item" href="/book"> book </a><a class="menu-item" href="/about"> about </a><a class="menu-item" href="/study"> study </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="lyer&#39;s blog">lyer&#39;s blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">archive</a><a class="menu-item" href="/tags/" title="">tag</a><a class="menu-item" href="/categories/" title="">category</a><a class="menu-item" href="/book" title="">book</a><a class="menu-item" href="/about" title="">about</a><a class="menu-item" href="/study" title="">study</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">8086CPU和8086汇编</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://icepan.cloud" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>lyer</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E8%AE%A1%E7%BB%84%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><i class="far fa-folder fa-fw"></i>计组和计算机基础</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-02-02">2021-02-02</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 179 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 1 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#cpu架构指令集汇编">CPU架构、指令集、汇编</a></li>
    <li><a href="#cpu的前世今生">CPU的前世今生</a></li>
    <li><a href="#cpu和总线结构">CPU和总线结构</a></li>
    <li><a href="#8086寄存器和段寻址">8086寄存器和段寻址</a></li>
    <li><a href="#8086汇编">8086汇编</a></li>
    <li><a href="#psw寄存器">PSW寄存器</a></li>
    <li><a href="#8086中断">8086中断</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="cpu架构指令集汇编">CPU架构、指令集、汇编</h2>
<ol>
<li>
<p>指令集是人们发明出来的东西，指令就是CPU执行具体操作的一个代号，比如<code>0000</code>代表什么指令，<code>0001</code>代表什么指令，一条机器指令进过 <strong>指令译码器</strong> 之后就转化为响应的电路信号从而实现特定的操作</p>
</li>
<li>
<p>指令集决定了处理器的架构，因为<strong>处理器架构就是用硬件电路实现指令集</strong></p>
<p>CPU架构又叫<strong>微架构</strong>，就是由一些硬件电路构成来实现指令集所规定的操作</p>
</li>
<li>
<p>因为机器指令都是<code>01</code>组成的数字，非常难排错和编程，于是人们就用英文符号来指示一条指令，然后通过汇编程序来将这些符号转化为<code>01</code>机器指令</p>
</li>
</ol>
<p>​</p>
<h2 id="cpu的前世今生">CPU的前世今生</h2>
<p>世界上最著名的CPU厂商有：</p>
<ul>
<li><strong>intel</strong></li>
<li><strong>AMD</strong>（比<code>intel</code>晚出现）</li>
<li><strong>ARM</strong></li>
</ul>
<p><strong>intel公司</strong>生产的CPU主要有：<strong>8086(16位)、8088、80386、i386(扩展到32位)、i486&hellip;.</strong></p>
<p>上面的CPU都是早期生产的CPU，现代的intel CPU主要有：<strong>酷睿&gt;奔腾&gt;赛扬</strong>（性能比较）</p>
<p><!-- raw HTML omitted --></p>
<p>​</p>
<p><strong>AMD公司</strong>生产的CPU主要有：<strong>锐龙&gt;AMD FX&gt;APU&gt;速龙&gt;闪龙</strong> （性能比较）</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/biningo/cdn/master/img/v2-bc43716167ec0d31ec957022d2442f29_1440w.jpg"
        data-srcset="https://raw.githubusercontent.com/biningo/cdn/master/img/v2-bc43716167ec0d31ec957022d2442f29_1440w.jpg, https://raw.githubusercontent.com/biningo/cdn/master/img/v2-bc43716167ec0d31ec957022d2442f29_1440w.jpg 1.5x, https://raw.githubusercontent.com/biningo/cdn/master/img/v2-bc43716167ec0d31ec957022d2442f29_1440w.jpg 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/biningo/cdn/master/img/v2-bc43716167ec0d31ec957022d2442f29_1440w.jpg"
        title="https://raw.githubusercontent.com/biningo/cdn/master/img/v2-bc43716167ec0d31ec957022d2442f29_1440w.jpg" /></p>
<p>因为<code>intel</code>早期生产的CPU都是以<code>86</code>结尾的，所以intel的CPU就称为<code>x86系列</code></p>
<p>在<code>16</code>位CPU时代，intel的CPU采用了<code>x86-16</code>指令集，到了<code>32</code>位CPU时代intel采用了<code>IA32</code>指令集，所以采用IA32指令集的CPU也称为<code>x86架构</code>CPU（<strong>因为指令集决定了CPU底层电路设计和架构嘛</strong>）</p>
<p>当初Intel因为产能不足，IBM要求增加第二供应商，于是Intel将<code>x86指令集</code>授权给了AMD等一众厂商，这也是为什么有AMD的存在，intel没有把CPU底层如何实现这些指令的CPU架构告诉AMD，AMD用授权的<code>x86指令集</code>设计了自己的CPU，所以intel上运行的软件也可以在AMD上运行</p>
<p>在64位时代intel自己搞了<code>IA64</code>（和IA32不兼容，全新的指令集）并且重新设计了CPU架构，AMD搞了<code>AMD64</code>（基于IA32）最后IA64因为不兼容IA32而失败，AMD64就变成了现在的<code>x86-64</code>又叫<code>amd64</code>、<code>x64</code>。</p>
<p>因为x86-64的授权在AMD，于是AMD与Intel达成交叉授权，AMD继续使用<code>x86架构</code>。这就是为什么现在市面上有AMD和Intel共存的原因，他们都是兼容x86-64架构</p>
<p><code>x86指令集(IA32)</code>（包括<code>amd64</code>）是属于 <strong>CISC</strong> 风格的指令集</p>
<blockquote>
<p>RISC和CISC的区别可以看这篇文章：http://www.vsdiffer.com/risc-vs-cisc.html</p>
</blockquote>
<p><strong>ARM CPU</strong>采用<code>ARM指令集</code>，该指令集属于 <strong>RISC</strong> 风格（<code>MIPS指令集</code>也是采用此风格）</p>
<p>ARM架构的CPU主要用在<strong>移动设备等小型设备</strong>，因为采用了RISC风格的指令集，所以 <strong>体积小、低功耗、低成本、高性能</strong></p>
<p>这里总结一下：</p>
<ul>
<li>指令集风格分为：<code>RISC</code>、<code>CISC</code></li>
<li>著名的CPU指令集：<code>IA32(x86)</code>、<code>amd64/x86_64</code>(基于IA32,兼容IA32)、<code>ARM</code>、<code>MIPS</code></li>
<li>著名的CPU厂商：<code>intel</code>、<code>AMD</code>、生产<code>ARM CPU</code>的相关厂商(ARM公司只是发明了指令集并授权给其他公司收专利费，并不生产CPU)</li>
<li>RISC为代表的指令集：<code>IA32(x86)</code>、<code>amd64/x86_64</code></li>
<li>CISC为代表的指令集：<code>ARM</code>、<code>MIPS</code></li>
<li><strong>现在RISC和CISC的界限变得模糊了，相互借鉴对方的优点</strong></li>
</ul>
<p>​</p>
<h2 id="cpu和总线结构">CPU和总线结构</h2>
<p>CPU通过总线于外部进行交互，总线分为三类：</p>
<ul>
<li><strong>数据总线：</strong> 传输数据</li>
<li><strong>控制总线：</strong> 传输控制信息比如读、写</li>
<li><strong>地址总线：</strong> 传输数据的地址</li>
</ul>
<p>注意地址读写操作不只是针对主存的，主存只是主板上最重要的一部分，总线还和其他设备接口进行相连的，所以给出的地址不只是主存上的地址，还可能是主板上其他设备的地址，操作这部分地址就相当于操作这些接口的内部存储器等部件，所以逻辑上都可以将 <strong>外设+内存</strong> 看做是一块逻辑空间，所有就有了 <strong>外设映射到内存地址</strong> 这一说法，物理上只是将这些线分配连接到了其他接口部件而已</p>
<p>主板上提供了接口，外设会根据这些接口来设计自己的电路，CPU只需要对这些适配器接口上的存储器控制器进行操作，比如将 <strong>控制信号、数据信号、地址信号</strong> 通过上面的各个类型的总线发送到这些接口中的 <strong>寄存器存储器控制器</strong> 等部件就可以操作外设了，外设就会对这些信号进行解析然后做出响应，比如往显存里面发送数据和控制信号，然后就可以控制屏幕显示内容了</p>
<p>总线的宽度决定了数据的传输量，因为电信号是通过这些导线传出去的嘛</p>
<p><code>20</code>位的地址总线最大的寻址空间就是<code>2^20=1024k=1M</code></p>
<p><code>8</code>位的数据总线一次最大能传送的数据大小就是<code>2^8=1byte</code> 如果要传输<code>1byte</code>char型数据则只需要一次，要传输<code>4byte</code>的<code>int</code>型数据则需要<code>4</code>次</p>
<p>控制总线宽度则决定了CPU对外设有多少种控制方式和控制命令，主要就是 <strong>读写</strong> 控制</p>
<p>​</p>
<h2 id="8086寄存器和段寻址">8086寄存器和段寻址</h2>
<p><code>8086</code>是<code>intel</code>最早期的一带16位CPU，所有寄存器宽度都是<code>16</code>位的，由于为了兼容之前的<code>8</code>位更老的CPU，8086允许将16位的寄存器拆分为2部分，之后的<code>32、64</code>CPU都采用这种方式来兼容之前的CPU，比如<code>AX(16)=AH(8)+AL(8)</code></p>
<p><!-- raw HTML omitted --></p>
<blockquote>
<p><strong>在8086中，将16位也就是2字节称为1字</strong></p>
<p>一字=16位=2byte</p>
<p>双字=32位=4byte</p>
<p>四字=64位=8byte</p>
</blockquote>
<p>8086中采用 <code>段:偏址</code> 来寻址，当前执行的指令的地址采用两个寄存器来保存<code>CS:IP</code></p>
<p>由于8086地址总线为<code>20</code>位，所以最终地址会进过如下处理：<code>CS&lt;&lt;4+IP</code></p>
<p>段的基地址可以是任意值，但是最终都要 <strong>乘16</strong> 所以可以得出如下结论：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">CS:0x0000 --&gt; 0x00000 第1段首地址
CS:0x0001 --&gt; 0x00010 第2段首地址
CS:0x0002 --&gt; 0x00020 第3段首地址
</code></pre></div><p>所以一个段的最小大小为：    <code>16位=2byte</code></p>
<p>那么一个段的最大为：<code>64kb</code> 也就是段首地址确定之后，段偏移<code>IP</code>可变范围就是<code>0~2^16=64kb</code></p>
<p>现在如果将<code>CS</code>值设置为最大：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">CS:0xFFFF --&gt; 0xFFFF0 
</code></pre></div><p>该段之后剩余了<code>0x0000F</code>也就是<code>16位=2byte</code>空间，如果<code>IP</code>的值超过了<code>16位</code>那么继续增加<code>IP</code>的值就会造成 <strong>地址溢出</strong> ，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">CS:0xFFFF IP:0x000F  --&gt; 0xFFFF0+0x000F <span class="o">=</span> 0xFFFFF <span class="c1">#最后一个地址</span>
CS:0xFFFF IP:0x0010 --&gt; 0xFFFF0+0x0010 <span class="o">=</span> 0x100000 <span class="c1">#地址溢出</span>
</code></pre></div><p>因为<code>8086</code>的总线宽度只有<code>20</code>位，所以就会将<code>0x100000</code>截断为<code>0x00000</code>，于是又重新回滚到了第0号地址</p>
<p>​</p>
<h2 id="8086汇编">8086汇编</h2>
<p><a href="https://github.com/biningo/assembly-play/blob/8086/basic.asm">https://github.com/biningo/assembly-play/blob/8086/basic.asm</a></p>
<p>​</p>
<h2 id="psw寄存器">PSW寄存器</h2>
<h2 id="8086中断">8086中断</h2>
<p><code>8086</code> CPU将中断表建立在内存的<code>00000~003FF</code>中，发生总断时提供一个中断号然后到表中查找对应的中断表项，找到中断程序（中断程序也可以自己写，只需要放入对应的内存，并且设置中断向量即可，中断向量查找过程由硬件完成）的入口地址，将当前程序的<code>CS:IP</code>压入栈，然后将<code>CS:IP</code>指向入口地址就执行了中断程序，中断程序执行完毕之后就继续回到当前程序中执行</p>
<p>如果我们要自己添加中断，则只需要在终端表指定的地址中存入中断程序的<code>CS:IP</code>连个值，然后将中断程序放入对应的位置即可</p>
<p>我们可以通过<code>int</code>指令触发 <strong>软件中断</strong></p>
<pre><code class="language-assembly" data-lang="assembly">int 0 ;0号中断
int 02H; 2号中断
</code></pre><p>中断表项大小为2字(32位)，前1字存放IP，后一字存放CS，可以如下设置中断向量表</p>
<pre><code class="language-assembly" data-lang="assembly">;下面设置第一个表项,最终地址为 0:0200H
mov word ptr 0:[0*4],200H
mov word ptr 0:[0*4+2],0

;设置第3个表项 依次类推
mov word ptr 0:[2*4],300H
mov word ptr 0:[2*4+2],0
</code></pre><p>发生中断时，有如下几个步骤：</p>
<ul>
<li>CS、IP、PSW入栈</li>
<li>根据中断号查找中断向量，找到中断程序的<code>CS:IP</code></li>
<li>设置寄存器<code>CS:IP</code>，这样就跳到中断程序入口地址了</li>
</ul>
<p>如果要给中断程序传值则可以在相应的寄存器中设置值，然后再调用中断程序，中断程序会到指定的寄存器中读取值</p>
<p>​</p>
<h2 id="参考">参考</h2>
<p>CPU分类</p>
<ul>
<li><a href="https://www.zhihu.com/question/20209369">https://www.zhihu.com/question/20209369</a></li>
<li><a href="https://www.zhihu.com/question/32669957">https://www.zhihu.com/question/32669957</a></li>
</ul>
<p>intel和AMD的关系</p>
<ul>
<li><a href="https://www.zhihu.com/question/322942082/answer/693302774">https://www.zhihu.com/question/322942082/answer/693302774</a></li>
<li><a href="https://www.zhihu.com/question/63627218">https://www.zhihu.com/question/63627218</a></li>
<li><a href="https://www.cnblogs.com/bdqns1t22/p/3909053.html">https://www.cnblogs.com/bdqns1t22/p/3909053.html</a></li>
</ul>
<p>RISC和CISC</p>
<ul>
<li><a href="http://www.vsdiffer.com/risc-vs-cisc.html">http://www.vsdiffer.com/risc-vs-cisc.html</a></li>
<li><a href="https://blog.csdn.net/xuesen_lin/article/details/6151120">https://blog.csdn.net/xuesen_lin/article/details/6151120</a></li>
</ul>
<p>8086寄存器</p>
<ul>
<li>《汇编语言》(王爽)</li>
<li><a href="https://juejin.cn/post/6844903866153041928#heading-15">https://juejin.cn/post/6844903866153041928#heading-15</a></li>
</ul>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2021-02-02</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/%E5%9F%BA%E7%A1%80/">基础</a>,&nbsp;<a href="/tags/%E6%B1%87%E7%BC%96/">汇编</a>,&nbsp;<a href="/tags/cpu/">CPU</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/2021/02/01/%E4%BF%A1%E6%81%AF%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%A1%A8%E7%A4%BA/" class="prev" rel="prev" title="信息的编码和表示"><i class="fas fa-angle-left fa-fw"></i>信息的编码和表示</a>
            <a href="/2021/02/04/%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84linux%E7%BB%88%E7%AB%AF%E7%8E%AF%E5%A2%83/" class="next" rel="next" title="打造自己的终端环境">打造自己的终端环境<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="gitalk" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://github.com/gitalk/gitalk"></a>Gitalk</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.80.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://icepan.cloud" target="_blank">lyer</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/gitalk/gitalk.min.css"><script type="text/javascript" src="/lib/gitalk/gitalk.min.js"></script><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{"gitalk":{"admin":["biningo"],"clientID":"c8f473d59880800a7453","clientSecret":"7aa3dd0bcf966dee0a057e06eaf205caeb86b8e0","id":"2021-02-02T00:00:00Z","owner":"biningo","repo":"hugo-blog-gittalk","title":"8086CPU和8086汇编"}}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
