<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>lyer's blog</title><link>/</link><description>lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Wed, 05 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>基于Redis分布式锁实现思路</title><link>/2021/05/05/%E5%9F%BA%E4%BA%8Eredis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</link><pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/05/%E5%9F%BA%E4%BA%8Eredis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</guid><description>为什么需要分布式锁 单机应用中(也就是一台机器中)的锁用于控制当前程序多个线程并发而引发的资源争夺问题，但是当应用场景扩展到了分布式环境就不一样了，这样的锁就没用了。因为每台机器都是独立的，如果还是之前的锁的话只能保证本机器不会引发资源竞争问题，分布式环境下相当于每台机器都有一个自己独立的锁，所以无法避免资源竞争问题
这个时候就需要将这把锁保存到第三方中 （比如Redis），多台机器同时到Redis中取抢锁，这就可以保证分布式环境下争抢的是同一把锁
​
Redis分布式锁实现思路 首先，Redis里面并没有锁的概念。所谓的锁其实就是Redis里的一个key，加锁就是设置这个key，释放锁就是删除这个key
一个进程如果在请求加锁的过程中发现这个key已经存在了则表示加锁失败，这个锁已经被别人持有了。如果发现这个key不存在则表示这个锁没有被人持有
Redis中可以借助如下命令来实现判断如果没有锁再加锁操作:
#此命令表示如果key不存才会设置key并且返回1 如果是普通的set则会覆盖 setnx lock 1 单纯的这样实现分布式锁貌似太简单了，并且有个问题: 死锁
也就是说如果一台机器设置了锁，在执行过程中宕机了或出错了，那么这把锁将永远得不到释放，其他机器进程就永远无法获取到锁，引发死锁问题
于是我们可以借助Redis的key过期功能来给锁设置一个过期时间，这样就不用怕锁永远得不到释放了。同时需要注意设置key以及对应的过期时间这一系列动作应该是原子的，否则在设置key时还没来得及设置过期时间这台机器又宕机了还是会引发死锁问题。
综上，我们使用Redis提供的set命令以及参数来实现
#如果key不存在则设置lock并且过期时间为10s (nx表示不存在才会设置 存在则失败返回0) set lock 1 ex 10 nx 但是这样还会引发一个锁被错误释放问题
想象一下下面的场景:
A加锁执行，但是在莫个操作上面阻塞很久，此时锁过期了被自动释放 B获得锁继续执行 在B执行过程中A从阻塞中恢复了，并且A执行完毕了 于是A再次释放了锁（注意此时A释放的是B设置的锁）但是此时B还在执行中 此时C过来了，于是C就抢到锁了 这样就引发了一个错误: 在B加锁执行过程中，B的锁被错误的释放了
为了解决锁被错误释放的问题，我们需要给锁设置一个唯一标识，这个锁标识了是哪个进程加的锁，并且只有加锁的进程本身才能释放这把锁
set lock &amp;lt;uuid&amp;gt; ex 10 nx 实现思路就是线程在释放锁的时候获取一下key对应的value也就是锁的标识，判断一下是否是自己的那把锁。
如果不是自己的说明自己的锁已经超时被自动释放了则不会再次释放别人的锁，如果是自己的则进行释放
完整代码:
//redis分布式锁的实现 type Lock struct { RedisClient *redis.Client Key string UUID string Expire time.Duration } func NewLock(key string, expire time.Duration) *Lock { uuid, err := exec.</description></item><item><title>C的enum枚举</title><link>/2021/05/04/c%E7%9A%84enum%E6%9E%9A%E4%B8%BE/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/04/c%E7%9A%84enum%E6%9E%9A%E4%B8%BE/</guid><description><![CDATA[enum枚举 如果没有枚举的话，我们其实也可以用宏定义来实现，只是代码不够优雅
#include &lt;stdio.h&gt;enum DAY{ MON,THU,WED }; int main(int argc, char const *argv[]) { enum DAY day=THU; printf(&#34;%d\n&#34;,day); //1  return 0; } ]]></description></item><item><title>C的函数指针和回调函数</title><link>/2021/05/04/c%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/04/c%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</guid><description><![CDATA[回调函数 下面将四则运算法则传入函数中进行回调
int sum(int i1,int i2){ return i1+i2; } int sub(int i1,int i2){ return i1-i2; } int mul(int i1,int i2){ return i1*i2; } int div(int i1,int i2){ return i1/i2; } void func(int i1,int i2,int (*operate)(int,int)){ printf(&#34;i1:%d i2:%d = %d\n&#34;,i1,i2,operate(i1,i2)); } int main(int argc, char const *argv[]) { func(8,4,sum); func(8,4,sub); func(8,4,mul); func(8,4,div); return 0; } ​
函数指针用于结构体 函数指针可以用于结构体，实现类似于了类方法的效果
typedef struct Stu { char *name; void (*say)(char *msg); }Stu; void say(char *name){ printf(&#34;hello,%s\n&#34;,name); } int main(int argc, char const *argv[]) { Stu stu; stu.]]></description></item><item><title>malloc和calloc的区别</title><link>/2021/05/04/malloc%E5%92%8Ccalloc%E5%8C%BA%E5%88%AB/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/04/malloc%E5%92%8Ccalloc%E5%8C%BA%E5%88%AB/</guid><description><![CDATA[malloc和calloc的区别 malloc分配的内存不会进行初始化，有可能内存里还包含其他脏值。而calloc分配的内存会将内存值都初始化为0，并且calloc分配数组类型的内存更加方便，传入类型大小以及分配的个数即可
malloc案例
//malloc #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char const *argv[]) { char *p=NULL; p = (char*)malloc(sizeof(50)); if(p==NULL){ perror(&#34;分配失败&#34;); exit(EXIT_FAILURE); } for(int i=0;i&lt;50;i++){ printf(&#34;%d\n&#34;,*p++); //有可能会有非0值 也就是脏值  } return 0; } calloc案例
//calloc #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char const *argv[]) { char *p=NULL; p = (char*)calloc(50,1); //分配大小为1byte的50个连续的位置  if(p==NULL){ perror(&#34;分配失败&#34;); exit(EXIT_FAILURE); } for(int i=0;i&lt;50;i++){ printf(&#34;%d\n&#34;,*p++); //都是0  } return 0; } ]]></description></item><item><title>C的extern关键字</title><link>/2021/05/01/c%E7%9A%84extern%E5%85%B3%E9%94%AE%E5%AD%97/</link><pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/01/c%E7%9A%84extern%E5%85%B3%E9%94%AE%E5%AD%97/</guid><description><![CDATA[extern关键字 extern关键字的作用就是告诉编译器此值在其它文件中定义了，这里只是作个声明
//sum.c //表示a b的值由外部定义了 extern int a; extern int b; int sum(){ return a+b; } //main.c #include &lt;stdio.h&gt;extern int sum(); //表示sum是外部定义的 因为这里没有.h头文件 int a = 10; int b = 20; int main(int argc, char const *argv[]) { int c = sum(); printf(&#34;%d\n&#34;, c); //30  return 0; } 再看一个案例
//a.c char a = &#39;A&#39;; //main.c int main(){ extern char a; //引用a.c中定义的全局变量  printf(&#34;%c&#34;, a); } ​
static关键字 此关键字修饰的全局变量表示禁止被外部的extern所引用，表示这个变量的作用域仅仅在此文件内
static int age=19; 比如我在上面的a前加一个static那么main中就无法引用了，就会报错]]></description></item><item><title>C的柔性数组</title><link>/2021/05/01/c%E7%9A%84%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84/</link><pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/01/c%E7%9A%84%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84/</guid><description><![CDATA[什么是柔性数组  结构中最后一个元素允许是未知大小的数组，这个数组就是柔性数组
 但结构中的柔性数组前面必须至少一个其他成员,柔性数组成员允许结构中包含一个大小可变的数组，sizeof返回的这种结构大小不包括柔性数组的内存。包含柔数组成员的结构体用malloc函数进行内存的动态分配,且分配的内存应该大于结构的大小以适应柔性数组的预期大小
​
为什么需要柔性数组 C中的结构体都是固定大小的，但是有些时候我们需要一个可变大小的结构体，比如有时候需要在结构体中存放一个长度动态的字符串
typedef struct mystr { int len; //记录字符串长度  char *data;//底层的char数组指针 }mystr; 我们需要为data malloc一段内存，然后通过这个指针访问这段内存。
首先我们按照常规的做法，不做任何处理，直接malloc，如下
typedef struct mystr { int len; char* data; }mystr; int main(int argc, char const *argv[]) { char* c = &#34;hello,world&#34;; //分别分配内存  mystr* s = (mystr*)malloc(sizeof(mystr)); s-&gt;data = (char*)malloc(strlen(c)+1); //+1是为\0分配的 strlen不会将\0计算进来  strcpy(s-&gt;data,c); s-&gt;len = strlen(s-&gt;data); printf(&#34;len:%d data:%s\n&#34;,s-&gt;len,s-&gt;data); //11 hello,world  //分别释放空间  free(s-&gt;data); free(s); return 0; } 可以看到上面的操作比较麻烦，结构体和内部的data指针分配内存和释放内存操作都是分开的，data数据区和结构体不是连续的两块内存，这样会带来两个问题:]]></description></item><item><title>malloc实现原理</title><link>/2021/05/01/malloc%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link><pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/01/malloc%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid><description>TODO
参考 malloc和free的实现原理解析</description></item><item><title>git原理</title><link>/2021/04/30/git%E5%8E%9F%E7%90%86/</link><pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/30/git%E5%8E%9F%E7%90%86/</guid><description>git三大对象 git三大对象分别为:
blob tree commit 下面来讲述这些对象的细节:
blob 记录了文件的实际内容，每次add都会为每个文件生成一个blob，暂存区有个index指针会指向最新add到暂存区的几个blob 每次进行commit时都会生成两个对象: tree和commit
tree 记录了index指针指向的几个blob的hash值还有对应的文件信息和文件权限
commit记录了此次commit的作者信息和对应的tree节点，同时还会记录上一个commits
​
参考 这才是真正的Git——Git内部原理
三道 google 风格 git 面试题及其解答</description></item><item><title>git三大区域</title><link>/2021/04/29/git%E4%B8%89%E5%A4%A7%E5%8C%BA%E5%9F%9F/</link><pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/29/git%E4%B8%89%E5%A4%A7%E5%8C%BA%E5%9F%9F/</guid><description><![CDATA[git三大区域 工作区
工作区就是我们的本地目录
暂存区
暂存区用于暂时存放我们工作区域的更改，比如我们工作区域修改了一个文件，此时就可以先放入暂存区，然后我继续修改这个文件&hellip;&hellip;
改完之后我突然觉得文件这样修改不是很好，还是原来的比较好，想要恢复回原来的样子，此时暂存区就发挥作用了，我们可以将暂存区域的文件覆盖回工作区域，这样就又回到上次暂存的样子了，恢复之后此时暂存区的内容又和工作区域一致了
git add a.txt git restore a.txt #将上次暂存的文件覆盖到工作区 git restore --staged a.txt #取消暂存 也就是清空暂存区 本地仓库
如果确保此次修改就是最终版本，那么我们可以讲暂存区域中的内容提交到本地仓库，此时三大区域就一致了，一次提交就相当于一次版本的发布，以后可以回退到此版本
所以在提交之前需要确保暂存区的内容就是确定了的不会再修改了的
git commit a.txt -m &#34;new a&#34; git reset --hard HEAD^ #回退之后 三大区域也是一致的 git reset a112c #也可以指定特定的版本号 ​]]></description></item><item><title>git优雅的提交</title><link>/2021/04/29/git%E4%BC%98%E9%9B%85%E7%9A%84%E6%8F%90%E4%BA%A4/</link><pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/29/git%E4%BC%98%E9%9B%85%E7%9A%84%E6%8F%90%E4%BA%A4/</guid><description><![CDATA[git commit命令 git commit #进入vi界面编辑 git commit -m &#34;message&#34; #直接输入剪短信息 git commit --amend -m &#34;new a&#34; #修改最近一次的commit信息 ​
commit规范 &lt;type&gt;[optional scope]: &lt;description&gt; &lt;BLANK LINE&gt; [optional body] &lt;BLANK LINE&gt; [optional footer(s)]  标题行: 必填, 描述主要修改的type类型和desc简短描述 主题内容: 描述为什么修改, 做了什么样的修改, 以及开发的思路等详细注释，这是可选的 页脚注释: 放 Breaking Changes 或 Closed Issues 这也是可选的  type 提交类型
   type desc     feat 新特性   fix 修复bug   refactor 代码重构   docs 文档修改   style 代码格式修改   test 测试相关，增加测试用例，修改测试用例   chore 杂项，其它修改，比如依赖管理、CICD等，当然还可以指出具体的比如ci: build   pref 代码优化，各种优化等   sync 同步主线分支   merge/rebase 合并分支    scope 影响范围]]></description></item></channel></rss>