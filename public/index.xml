<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>lyer's blog</title><link>/</link><description>lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Wed, 03 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>基金</title><link>/2021/03/03/%E5%9F%BA%E9%87%91/</link><pubDate>Wed, 03 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/03/03/%E5%9F%BA%E9%87%91/</guid><description>基金分类 (分险依次降低)
股票型 混合型 债权型 货币型 A类基金：买入有手续费 长期投资 卖出需要手续费
C类基金：买入没有手续费 短期投资 卖出需要手续费
专业术语 https://zhuanlan.zhihu.com/p/348003436
​
基金交易时间 交易时间 净值确认日 交易确认日 盈亏查看日 周一15点前 周一 周二 周三 周一15点后—周二15点前 周二 周三 周四 周二15点后—周三15点前 周三 周四 周五 周三15点后—周四15点前 周四 周五 下周一 周四15点后—周五15点前 周五 下周一 下周二 周五15点、周六、周日 下周一 下周二 下周三 工作日时间: 9:30~11:30 13:00~15:00(建议交易在后面的时间段，这样最接近当然的价格) 周日晚上~周四15:00之前申购基金的最好时间 每次买卖一定要在当日下午15: 00前操作(最好是在14：00左右这样最接近当然的价格)，超过15:00就不要操作了，因为超过15:00就是次日的价格了 ​</description></item><item><title>Base64编码</title><link>/2021/03/02/base64%E7%BC%96%E7%A0%81/</link><pubDate>Tue, 02 Mar 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/03/02/base64%E7%BC%96%E7%A0%81/</guid><description>什么是Base64编码 将二进制数据转化为64个可打印ASCII码的一种编码方式，这64个可打印字符分别为:
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/= 注意，最后一个=不算，=当做Base64编码的结尾标志
总结：基于 64 个可打印字符来表示二进制数据的表示方法
​
Base64编码原理 将待转换的字符串每3个字节分为一组，每个字节占 8 个二进制位，那么共有24个二进制位
将第（1）步得到的每 24 个二进制位分为每 6 个一组（因为2^6=64），则每 3 个字节可分为 4 组
在每组前面添加两个 0 ，补齐1字节，每组由 6 个二进制位变为 8 个二进制位，总共 32 个二进制位，即四个字节 （3字节变4字节，所以经过Base64编码的都会变大）
6个二进制位转化为十进制然后检索下表，根据 Base64编码对照表（见下表）获得对应的值
​
为什么么需要Base64编码 方便网络传输 Base64的那64个字符只包含最基础的字符，所以在各种环境进行传输的时候，极大地减少了出现莫名其妙的问题的概率 简单的隐藏可见内容 （Base64只是一种编码方式，不能用来加密信息） 将二进制数据转化为可打印字符 ​
Base64优缺点 缺点:
Base64会增加字节数 Base64编码不是加密算法 优点:
Base64能简单隐藏内容 Base64算法简单可逆，不会消耗太多CPU，不影响效率 Base64能将所有数据转化为可打印数据 减少网络传输出现的编解码错误 ​
Base64的使用场景 网上留言自己的联系方式等私密信息，可以使用Base64加密一下，这样就不会直接泄露自己的信息，只有真正需要的人才会拿去解密，可以过滤一部分人 包含一些特殊字符的字符串等可以先用Base64编码一下防止被转义 http请求，在解析参数时是根据?</description></item><item><title>DNS协议</title><link>/2021/02/26/dns%E5%8D%8F%E8%AE%AE/</link><pubDate>Fri, 26 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/26/dns%E5%8D%8F%E8%AE%AE/</guid><description>DNS作用 解析域名为IP (网络上只能通过IP通讯) 负载均衡 (一个域名绑定多个IP,采用轮询方式访问多个IP) 灵活配置IP (当要更换IP时直接换IP,依旧不影响原来域名的访问) ​
DNS记录类型 下面列出常见的记录类型
类型 解释 A IP地址记录Address 记录域名对应的IP AAAA IPV6的地址记录 NS DNS服务器记录（Name Server），记录上一级DNS服务器地址，该记录只能设置为域名，不能设置为IP地址 CNAME 规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转 SRV 用于服务发现和负载均衡 ​
DNS查询过程 ​
本地接受到DNS查询返回的报文之后就会调用操作系统的DNS报文解析程序glibc/musl来解析报文获取IP地址，其配置文件为/etc/resolv.conf
本地还有/etc/hosts文件也可以记录IP和域名的映射关系，查询DNS服务器之前会先查询这个文件以及本地DNS缓存
​
dig命令 该命令是dns查询工具，类似的工具还有nslookup
dig cname www.baidu.com #查询www.baidu.com的CNAME跳转到那个URL dig ns baidu.com #查询哪个DNS服务器记录了这个域名解析地址 dig baidu.com #查询baidu.com的IP地址(A记录) dig +shore baidu.com #返回简短信息 dig +trace +additional baidu.</description></item><item><title>Linux常用命令总结</title><link>/2021/02/23/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</link><pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/23/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</guid><description><![CDATA[持续跟新&hellip;..
 进程相关 进程的信息都在/proc下
ps ps 显示系统进程
ps -ef ps -aux ps -ef | grep sshd jobs fg bg &amp; nohub &amp; jobs fg bg nohub
./exe &amp; #后台运行 ./exe &gt; log.txt 2&gt;&amp;1 &amp; #0:标准输入 1:标准输出 2:标准错误 2&gt;&amp;1是将标准出错重定向到标准输出 最终结果就是`标准输出`和`错误`都被重定向到`log.txt`中 etcd &gt; /dev/null 2&gt;&amp;1 &amp; #后台运行 同时输出日志重定向到垃圾桶 nohup etcd &gt; /dev/null 2&gt;&amp;1 &amp; #以守护进程方式运行 不会随着终端退出而退出 jobs #查看后台运行中的进程 #ctrl+z暂停任务 ctrl+c终止任务 fg 1 #将后台任务放到前台执行 bg 1 #将一个暂停的任务放在后台执行 kill kill killall
kill -9 1111 #强制终止 killall 1111 #杀死进程 以及所有子进程 pstree pstree 显示进程树]]></description></item><item><title>vim使用教程</title><link>/2021/02/21/vim%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</link><pubDate>Sun, 21 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/21/vim%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</guid><description>光标移动(命令模式)
n+空格 #在当前行中移动n个字符 n+Enter #移动到距离当前行后n行 H/M/L #移动到屏幕第一行/中间行/最后一行 gg/G/nG #移动到当前文件第一行/最后一行/第n行 w/nw #向前 移动1个单词/移动n个单词 b/nb #向后 移动1个单词/移动n个单词 文本编辑删除复制粘贴(命令模式)
a/A/i #在 光标后/行末/光标前 插入文本 o/O(字母O) #在光标下/上方新开一行 x/X #命令模式下删除光标后/前的单个字符 r/R #替换字符/复写模式,连续替换 d0/d$ #删除到 行首/行尾 dgg/dG #删除到 文件头/文件尾 dd/ndd #删除该行/删除该行下的n行 yy/nyy #复制该行/n行 p/P #当前行下/上面粘贴 u/ctrl+r #撤销上次操作/撤销反悔,重做上次撤销 文档检索
/search_text #在文档后面的部分搜索 ?search_text #在文档前面的部分搜索 n/N #往前/后移动检索到的关键字 :noh #取消检索的高亮 :%s/abc/aaa #检索第一个 “abc” 字符串并将其替换成“aaa” :%s/abc/aaa/g #检索并将所有的“abc”,替换为“aaa” :%s/original/replacement/gc #替换前先询问 可视模式
v #逐字可视模式 V #逐行可视模式 保存文件
:w new_file #另存为 不会退出 ZZ # :wq ZQ # :q!</description></item><item><title>MySql事务</title><link>/2021/02/19/mysql%E4%BA%8B%E5%8A%A1/</link><pubDate>Fri, 19 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/19/mysql%E4%BA%8B%E5%8A%A1/</guid><description>更新中&amp;hellip;
事务四大特性ACID 原子性 Atomicity
事务是数据库的逻辑工作单位，不可分割，事务中包含的各操作要么都做，要么都不做
一致性 Consistency
同一个事务中所有操作要么全部成功，要么全部失败
隔离性 Isolation
每个事务都是隔离的，互相不影响，一共有4个隔离级别
持久性 Durability
事务一旦提交，它对数据库中的数据的改变就应该是永久性的，不能回滚
​
四大隔离级别 1、读未提交 Read Uncommitted
一个事务还没提交时，它做的变更对他事务可见
2、读已提交 Read Committed Oracle默认的隔离级别
一个事务只有提交时候它做的变化才对其他事务可见，该级别会造成 在事务中两次读取数据不一致的情况
3、可重复读 Repeatable Read MySql、Innodb默认的隔离级别
一个事务开始之后，其所看见的数据就是事务开始时候的数据，相当于给数据在事务开始时拍一个快照，在事务执行过程中看见的都是这个快照，即使是其他事务做了变更提交了对此事务也不可见，解决了不可重复读、幻读问题
4、串行化 事务必须串行化执行，一个事务只有等另外一个事务结束之后才可以开始，效率最低不支持并发，但是解决了事务隔离性的所有问题
​
事务并发读写问题 1、脏读 事务读取到了其他事务还没提交的修改
A事务执行过程中，B事务做出的变化还没提交修改就被A事务读取到了，但是B事务的修改发生了回滚，那么A事务就读取到了脏数据
时间线 存款事务 取款事务 1 开始事务 2 开始事务 3 查询余额500 4 取款400，余额更改为500-400=100 5 查询余额100（脏读） 6 取款操作发生错误，事务失败，执行回滚操作 rollback （使用commit或者rollback后，事务就结束了） 7 存入500，更改余额为500+100=600 8 提交事务 9 账户出错，按照正确的逻辑此时余额应该为 500+500=1000，而此时余额为600 2、不可重复读 事务读取到了其他事务已经提交的修改，导致同一个事务两次查询结果不一样</description></item><item><title>MySql约束</title><link>/2021/02/19/mysql%E7%BA%A6%E6%9D%9F/</link><pubDate>Fri, 19 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/19/mysql%E7%BA%A6%E6%9D%9F/</guid><description><![CDATA[约束分类 约束就是给字段设置一定的规则，约束这个字段 主要有如下几类约束
 主键约束 外键约束 非空约束 唯一约束 默认值约束 检查约束  ​
主键约束 主键约束是非空的，最好使用 AUTO_INCREMENT来自动增加防止重复，并且能用int就不要用 bigint ，因为这和索引有关系，主键数据越小越好 如果一张表没有设置主键，那么Mysql就会拿一个非空约束字段当做主键，如果都没有则会自己生成一个RowID的列作主键
CREATE TABLE tb( id int PRIMARY KEY AUTO_INCREMENT ) CREATE TABLE tb( id int AUTO_INCREMENT, name varchar(20), PRIMARY KEY pk(id) ) #添加主键约束 ALTER TABLE 表名 ADD CONSTRAINT 约束名 PRIMARY KEY(列名); #删除主键约束 ALTER TABLE 表名 DROP PRIMARY KEY 约束名; ​
外键约束 外键是指引用另一个表中的一列或多列，被引用的列应该具有主键约束或唯一约束
外键约束可以设置联级:
 联级删除: 外键表中被引用的记录删除之后则连同所有拥有这个外键的记录都删除 联级更新: 外键表中被引用的记录更新之后则连同所有拥有这个外键的记录都更新  如果不设置则不允许删除还被引用的记录
CREATE TABLE IF NOT EXISTS category ( id INT PRIMARY KEY AUTO_INCREMENT, title VARCHAR(50) NOT NULL, UNIQUE uq_title (title) ); CREATE TABLE article ( id INT AUTO_INCREMENT, title VARCHAR(100) NOT NULL, created_at DATETIME NOT NULL, updated_at DATETIME NOT NULL, deleted_at DATETIME DEFAULT NULL, author VARCHAR(20) NOT NULL, status ENUM (&#39;published&#39;,&#39;auditing&#39;,&#39;draft&#39;,&#39;deleted&#39;) NOT NULL, cid INT NOT NULL, PRIMARY KEY pk_id (id), #联级删除 category记录删除了 所有引用该记录的article记录也一并删除  #如果没设置此联级策略则不允许删除还被引用的category记录  FOREIGN KEY fk_cid (cid) REFERENCES category (id) ON DELETE CASCADE, UNIQUE uq_title (title) COMMENT &#39;会自动创建唯一索引&#39; ); #添加外键 ALTER TABLE 表名 ADD CONSTRAINT 约束名 FOREIGN KEY (外键字段名) REFERENCES 外键表名(列名); #删除外键 ALTER TABLE 表名 DROP FOREIGN KEY 外键名; ​]]></description></item><item><title>堆</title><link>/2021/02/18/%E5%A0%86/</link><pubDate>Thu, 18 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/18/%E5%A0%86/</guid><description>TODO</description></item><item><title>快速排序</title><link>/2021/02/18/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link><pubDate>Thu, 18 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/18/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid><description>快排思想 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列
就是需要确定一个 pivot支点，然后将小于pivot的放到左边，大于pivot的放到右边，此时pivot就已经排好序了，然后再分别对两别进行递归排序
所以快排主要需要解决下面两个问题:
pivot的选择 如何把元素放到左边和右边，也就是如何确定pivot的位置 ​
复杂度分析 最优时间复杂度: O(nlogn) 最优空间复杂度: O(logn)
pivot每次都平分，计算时间复杂度过程和 归并排序一样计算
空间复杂度主要是递归栈的空间，看递归树的高度，比如50,10,90,30, 70,40,80,60,20 这个序列，递归深度如下，这是一颗平衡二叉树，高度是数组个数的 logn倍
最差时间复杂度: O(n^2) 最差空间复杂度: O(n)
pivot每次取最大最小值，退化为 冒泡排序 冒泡排序的时间复杂度：
T[n] = n * (n-1) = n^2 + n = O(n^2) 空间复杂度就是树的高度，单边树的高度就是元素的个数，所以空间复杂度为O(n)
​
pivot支点的选择 支点只要能将两边平均分就是最好的支点，主要有如下几个选法:
选第一个/最后一个 选中间一个 随机选一个 三数取中法: 选 开头、结尾、中间 的数中大小排中间的数 为了便于算法实现，需要取中间某个Pivot时，可以通过交换元素，转换成取第一个（或最后一个）
//随机 pivot := rand.Intn(end+1-start) + start //三数取中 func getMiddle(arr []int, start, end int) int { mid := start + (end-start)/2 if arr[start] &amp;gt; arr[mid] { mid, start = start, mid } if arr[mid] &amp;gt; arr[end] { mid, end = end, mid } return mid } ​</description></item><item><title>十大排序算法</title><link>/2021/02/17/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link><pubDate>Wed, 17 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/17/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid><description><![CDATA[更新中&hellip;..
 冒泡排序  稳定排序 最好时间复杂度: O(n) 基本有序状态，进行1次冒泡 最坏时间复杂度: O(n^2) 逆序状态，需要进行n次冒泡 平均时间复杂度: O(n^2) 空间复杂度: O(1)  func BubbleSort(arr []int) { flag := true for i := 0; i &lt; len(arr); i++ { for j := 0; j &lt; len(arr)-i-1; j++ { if arr[j] &gt; arr[j+1] { flag = false arr[j], arr[j+1] = arr[j+1], arr[j] } } if flag { break } } } ​
选择排序  不稳定排序 比如 5 8 5 2 9 两个相同的5会发生位置交换 最好时间复杂度: O(n^2) 最坏时间复杂度: O(n^2) 平均时间复杂度: O(n^2) 空间复杂度: O(1)  每次选择剩余排序区间中最小(大)的元素放入排序好的区间的最后一个位置中]]></description></item></channel></rss>