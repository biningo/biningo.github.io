<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>lyer's blog</title><link>/</link><description>lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Sun, 09 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>MySql备份与恢复</title><link>/2021/05/09/mysql%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</link><pubDate>Sun, 09 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/09/mysql%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</guid><description><![CDATA[mysqldump备份与恢复 备份所有数据库--all-databases
#备份所有数据库 mysqldump -uroot -p --all-databases &gt; ./all.sql 备份指定的数据库
#备份 lyer test 库 mysqldump -uroot -p lyer --databases lyer test &gt; ./db.sql 备份指定数据库中的表，恢复时必须use到指定的数据库下
#备份test库中的a b c 表 mysqldump -uroot -p test a b c &gt; ./db.sql 恢复数据
mysql&gt; source /home/lyer/tmp/temp/db.sql ​
MySql备份脚本 #!/bin/bash # ------------------------------------------------------------------------------- # FileName: mysql_backup.sh  # Describe: Used for database backup # Revision: 1.0 # Date: 2020/08/11 # Author: wang # 设置mysql的登录用户名和密码(根据实际情况填写) mysql_user = &#34;root&#34; mysql_password = &#34;yourpassword&#34; mysql_host = &#34;localhost&#34; mysql_port = &#34;3306&#34; backup_dir = /data/mysql_backup dt=date +&#39;%Y%m%d_%H%M&#39; echo &#34;Backup Begin Date:&#34; $(date +&#34;%Y-%m-%d %H:%M:%S&#34;) # 备份全部数据库 mysqldump -h$mysql_host -P$mysql_port -u$mysql_user -p$mysql_password -R -E --all-databases --single-transaction &gt; $backup_dir/mysql_backup_$dt.]]></description></item><item><title>MySql运维</title><link>/2021/05/09/mysql%E8%BF%90%E7%BB%B4/</link><pubDate>Sun, 09 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/09/mysql%E8%BF%90%E7%BB%B4/</guid><description><![CDATA[MySql数据目录初始化 第一次启动MySql的时候需要进行初始化，也就是初始化数据存放的目录（注意这个目录必须为空，或则不存在）这个目录路径可以在配置文件里面配置
[mysqld] port=3306 datadir=/home/lyer/tmp/data 默认的数据存放路径是:
$MYSQL_HOME/data MySql服务器启动会读取配置文件my.cnf，配置文件查找顺序为:
/etc/my.cnf /etc/mysql/my.cnf $MYSQL_HOME/my.cnf --default-extra-file #命令行自定配置文件路径 ~/.my.cnf 服务器会依次查找这些路径去读取并且合并配置
下面是数据库初始化命令
mysqld --initialize #初始化 会打印初始的root密码在终端 第一次登入需要密码 mysqld --initialize-insecure #初始化并且设置root密码为空 也就是初次不需要密码 初始化之后我们需要登入到数据库，并且需要修改root密码为自定义的密码
mysql -uroot -p #没有密码则回车即可 有初始密码则需要输入 alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;55555&#39;; 如果觉得每次输入用户密码指定host麻烦的话则可以在my.conf里面配置客户端
[client] host=127.0.0.1 user=root password=55555 这样的话直接输入mysql就会读取客户端配置，这样就不需要输入密码了
​
MySql服务启动、停止 一般通过$MYSQL_HOME/support-files/mysql.server服务启动脚本启动，此脚本还会启动一个监控进程mysqld-safe，此进程会监控mysql服务的运行状态，如果出错了则会将错误日志记录起来xxx.err，还会帮助mysql服务重启
$MYSQL_HOME/support-files/mysql.server #不带参数执行可以查看Useage mysql.server start #启动 (第一次启动服务器需要首先初始化数据库) mysql.server status #查看mysql服务状态 mysql.server stop ​
用户管理 和用户相关的信息都保存在mysql.user表中，密码都是加密存储的
select host,user from user; User列表示用户名，Host列表示允许连接的客户端主机地址，为localhost则表示只允许本地连接
创建一个用户
create user lyer identified by &#39;66666&#39;; --不指定host的话默认全部可以连 create user &#39;lyer&#39;@&#39;%&#39; identified by &#39;55555&#39;; --%表示允许全部IP连接 create user &#39;lyer&#39;@&#39;112.]]></description></item><item><title>基于Redis分布式锁实现思路</title><link>/2021/05/05/%E5%9F%BA%E4%BA%8Eredis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</link><pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/05/%E5%9F%BA%E4%BA%8Eredis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</guid><description>为什么需要分布式锁 单机应用中(也就是一台机器中)的锁用于控制当前程序多个线程并发而引发的资源争夺问题，但是当应用场景扩展到了分布式环境就不一样了，这样的锁就没用了。因为每台机器都是独立的，如果还是之前的锁的话只能保证本机器不会引发资源竞争问题，分布式环境下相当于每台机器都有一个自己独立的锁，所以无法避免资源竞争问题
这个时候就需要将这把锁保存到第三方中 （比如Redis），多台机器同时到Redis中取抢锁，这就可以保证分布式环境下争抢的是同一把锁
​
Redis分布式锁实现思路 首先，Redis里面并没有锁的概念。所谓的锁其实就是Redis里的一个key，加锁就是设置这个key，释放锁就是删除这个key
一个进程如果在请求加锁的过程中发现这个key已经存在了则表示加锁失败，这个锁已经被别人持有了。如果发现这个key不存在则表示这个锁没有被人持有
Redis中可以借助如下命令来实现判断如果没有锁再加锁操作:
#此命令表示如果key不存才会设置key并且返回1 如果是普通的set则会覆盖 setnx lock 1 单纯的这样实现分布式锁貌似太简单了，并且有个问题: 死锁
也就是说如果一台机器设置了锁，在执行过程中宕机了或出错了，那么这把锁将永远得不到释放，其他机器进程就永远无法获取到锁，引发死锁问题
于是我们可以借助Redis的key过期功能来给锁设置一个过期时间，这样就不用怕锁永远得不到释放了。同时需要注意设置key以及对应的过期时间这一系列动作应该是原子的，否则在设置key时还没来得及设置过期时间这台机器又宕机了还是会引发死锁问题。
综上，我们使用Redis提供的set命令以及参数来实现
#如果key不存在则设置lock并且过期时间为10s (nx表示不存在才会设置 存在则失败返回0) set lock 1 ex 10 nx 但是这样还会引发一个锁被错误释放问题
想象一下下面的场景:
A加锁执行，但是在莫个操作上面阻塞很久，此时锁过期了被自动释放 B获得锁继续执行 在B执行过程中A从阻塞中恢复了，并且A执行完毕了 于是A再次释放了锁（注意此时A释放的是B设置的锁）但是此时B还在执行中 此时C过来了，于是C就抢到锁了 这样就引发了一个错误: 在B加锁执行过程中，B的锁被错误的释放了
为了解决锁被错误释放的问题，我们需要给锁设置一个唯一标识，这个锁标识了是哪个进程加的锁，并且只有加锁的进程本身才能释放这把锁
set lock &amp;lt;uuid&amp;gt; ex 10 nx 实现思路就是线程在释放锁的时候获取一下key对应的value也就是锁的标识，判断一下是否是自己的那把锁。
如果不是自己的说明自己的锁已经超时被自动释放了则不会再次释放别人的锁，如果是自己的则进行释放
完整代码:
//redis分布式锁的实现 type Lock struct { RedisClient *redis.Client Key string UUID string Expire time.Duration } func NewLock(key string, expire time.Duration) *Lock { uuid, err := exec.</description></item><item><title>C的enum枚举</title><link>/2021/05/04/c%E7%9A%84enum%E6%9E%9A%E4%B8%BE/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/04/c%E7%9A%84enum%E6%9E%9A%E4%B8%BE/</guid><description><![CDATA[enum枚举 如果没有枚举的话，我们其实也可以用宏定义来实现，只是代码不够优雅
#include &lt;stdio.h&gt;enum DAY{ MON,THU,WED }; int main(int argc, char const *argv[]) { enum DAY day=THU; printf(&#34;%d\n&#34;,day); //1  return 0; } ]]></description></item><item><title>C的函数指针和回调函数</title><link>/2021/05/04/c%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/04/c%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</guid><description><![CDATA[函数指针和指针函数  指针函数 返回指针的函数  char * sayHello(){ char *msg = (char*)malloc(sizeof(13)); msg = &#34;hello,world\n&#34;; return msg; } int main(int argc, char const *argv[]) { char *msg; msg = sayHello(); printf(&#34;%s\n&#34;,msg); }  函数指针 保存函数入口地址的指针，可用于直接设置CPU的PC，直接跳转到目标函数代码指向  void echo(char *msg) { printf(&#34;%s\n&#34;, msg); } int main(int argc, char const *argv[]) { //void:返回值 (*func):函数指针写法 (char *msg):形参  void (*func)(char *msg); //可以直接赋予一个函数的地址 或则void*地址都可  //赋予一段汇编代码地址起始处也可  func = &amp;echo; func(&#34;hello,world&#34;); //直接跳转到地址入口执行 } ​]]></description></item><item><title>malloc和calloc的区别</title><link>/2021/05/04/malloc%E5%92%8Ccalloc%E5%8C%BA%E5%88%AB/</link><pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/04/malloc%E5%92%8Ccalloc%E5%8C%BA%E5%88%AB/</guid><description><![CDATA[malloc和calloc的区别 malloc分配的内存不会进行初始化，有可能内存里还包含其他脏值。而calloc分配的内存会将内存值都初始化为0，并且calloc分配数组类型的内存更加方便，传入类型大小以及分配的个数即可
malloc案例
//malloc #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char const *argv[]) { char *p=NULL; p = (char*)malloc(sizeof(50)); if(p==NULL){ perror(&#34;分配失败&#34;); exit(EXIT_FAILURE); } for(int i=0;i&lt;50;i++){ printf(&#34;%d\n&#34;,*p++); //有可能会有非0值 也就是脏值  } return 0; } calloc案例
//calloc #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main(int argc, char const *argv[]) { char *p=NULL; p = (char*)calloc(50,1); //分配大小为1byte的50个连续的位置  if(p==NULL){ perror(&#34;分配失败&#34;); exit(EXIT_FAILURE); } for(int i=0;i&lt;50;i++){ printf(&#34;%d\n&#34;,*p++); //都是0  } return 0; } ]]></description></item><item><title>C的extern关键字</title><link>/2021/05/01/c%E7%9A%84extern%E5%85%B3%E9%94%AE%E5%AD%97/</link><pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/01/c%E7%9A%84extern%E5%85%B3%E9%94%AE%E5%AD%97/</guid><description><![CDATA[extern关键字 extern关键字的作用就是告诉编译器此值在其它文件中定义了，这里只是作个声明
//sum.c //表示a b的值由外部定义了 extern int a; extern int b; int sum(){ return a+b; } //main.c #include &lt;stdio.h&gt;extern int sum(); //表示sum是外部定义的 因为这里没有.h头文件 int a = 10; int b = 20; int main(int argc, char const *argv[]) { int c = sum(); printf(&#34;%d\n&#34;, c); //30  return 0; } 再看一个案例
//a.c char a = &#39;A&#39;; //main.c int main(){ extern char a; //引用a.c中定义的全局变量  printf(&#34;%c&#34;, a); } ​
static关键字 此关键字修饰的全局变量表示禁止被外部的extern所引用，表示这个变量的作用域仅仅在此文件内
static int age=19; 比如我在上面的a前加一个static那么main中就无法引用了，就会报错]]></description></item><item><title>C的柔性数组</title><link>/2021/05/01/c%E7%9A%84%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84/</link><pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/01/c%E7%9A%84%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84/</guid><description><![CDATA[什么是柔性数组  结构中最后一个元素允许是未知大小的数组，这个数组就是柔性数组
 但结构中的柔性数组前面必须至少一个其他成员,柔性数组成员允许结构中包含一个大小可变的数组，sizeof返回的这种结构大小不包括柔性数组的内存。包含柔数组成员的结构体用malloc函数进行内存的动态分配,且分配的内存应该大于结构的大小以适应柔性数组的预期大小
​
为什么需要柔性数组 C中的结构体都是固定大小的，但是有些时候我们需要一个可变大小的结构体，比如有时候需要在结构体中存放一个长度动态的字符串
typedef struct mystr { int len; //记录字符串长度  char *data;//底层的char数组指针 }mystr; 我们需要为data malloc一段内存，然后通过这个指针访问这段内存。
首先我们按照常规的做法，不做任何处理，直接malloc，如下
typedef struct mystr { int len; char* data; }mystr; int main(int argc, char const *argv[]) { char* c = &#34;hello,world&#34;; //分别分配内存  mystr* s = (mystr*)malloc(sizeof(mystr)); s-&gt;data = (char*)malloc(strlen(c)+1); //+1是为\0分配的 strlen不会将\0计算进来  strcpy(s-&gt;data,c); s-&gt;len = strlen(s-&gt;data); printf(&#34;len:%d data:%s\n&#34;,s-&gt;len,s-&gt;data); //11 hello,world  //分别释放空间  free(s-&gt;data); free(s); return 0; } 可以看到上面的操作比较麻烦，结构体和内部的data指针分配内存和释放内存操作都是分开的，data数据区和结构体不是连续的两块内存，这样会带来两个问题:]]></description></item><item><title>malloc实现原理</title><link>/2021/05/01/malloc%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link><pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/05/01/malloc%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid><description>TODO
参考 malloc和free的实现原理解析</description></item><item><title>git原理</title><link>/2021/04/30/git%E5%8E%9F%E7%90%86/</link><pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/04/30/git%E5%8E%9F%E7%90%86/</guid><description>git三大对象 git三大对象分别为:
blob tree commit 下面来讲述这些对象的细节:
blob 记录了文件的实际内容，每次add都会为每个文件生成一个blob，暂存区有个index指针会指向最新add到暂存区的几个blob 每次进行commit时都会生成两个对象: tree和commit
tree 记录了index指针指向的几个blob的hash值还有对应的文件信息和文件权限
commit记录了此次commit的作者信息和对应的tree节点，同时还会记录上一个commits
​
参考 这才是真正的Git——Git内部原理
三道 google 风格 git 面试题及其解答</description></item></channel></rss>