<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - lyer's blog</title><link>/posts/</link><description>所有文章 | lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Fri, 26 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="/posts/" rel="self" type="application/rss+xml"/><item><title>DNS协议</title><link>/2021/02/26/dns%E5%8D%8F%E8%AE%AE/</link><pubDate>Fri, 26 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/26/dns%E5%8D%8F%E8%AE%AE/</guid><description>DNS作用 解析域名为IP (网络上只能通过IP通讯) 负载均衡 (一个域名绑定多个IP,采用轮询方式访问多个IP) 灵活配置IP (当要更换IP时直接换IP,依旧不影响原来域名的访问) ​
DNS记录类型 下面列出常见的记录类型
类型 解释 A IP地址记录Address 记录域名对应的IP AAAA IPV6的地址记录 NS DNS服务器记录（Name Server），记录上一级DNS服务器地址，该记录只能设置为域名，不能设置为IP地址 CNAME 规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转 ​
DNS查询过程 ​
dig命令 该命令是dns查询工具，类似的工具还有nslookup
dig cname www.baidu.com #查询www.baidu.com的CNAME跳转到那个URL dig ns baidu.com #查询哪个DNS服务器记录了这个域名解析地址 dig baidu.com #查询baidu.com的IP地址(A记录) dig +shore baidu.com #返回简短信息 dig +trace +additional baidu.com #返回复杂的追踪信息 dig @8.8.8.8 baidu.com #指定DNS服务器去查询 dig @8.</description></item><item><title>Linux常用命令总结</title><link>/2021/02/23/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</link><pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/23/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</guid><description><![CDATA[持续跟新&hellip;..
 进程相关 进程的信息都在/proc下
ps 显示系统进程
ps -ef ps -aux ps -ef | grep sshd &amp; jobs fg bg nohub
./exe &amp; #后台运行 ./exe &gt; log.txt 2&gt;&amp;1 &amp; #0:标准输入 1:标准输出 2:标准错误 2&gt;&amp;1是将标准出错重定向到标准输出 最终结果就是`标准输出`和`错误`都被重定向到`log.txt`中 etcd &gt; /dev/null 2&gt;&amp;1 &amp; #后台运行 同时输出日志重定向到垃圾桶 nohup etcd &gt; /dev/null 2&gt;&amp;1 &amp; #以守护进程方式运行 不会随着终端退出而退出 jobs #查看后台运行中的进程 #ctrl+z暂停任务 ctrl+c终止任务 fg 1 #将后台任务放到前台执行 bg 1 #将一个暂停的任务放在后台执行 kill killall
kill -9 1111 #强制终止 killall 1111 #杀死进程 以及所有子进程 pstree 显示进程树]]></description></item><item><title>vim使用教程</title><link>/2021/02/21/vim%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</link><pubDate>Sun, 21 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/21/vim%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</guid><description>光标移动(命令模式)
n+空格 #在当前行中移动n个字符 n+Enter #移动到距离当前行后n行 H/M/L #移动到屏幕第一行/中间行/最后一行 gg/G/nG #移动到当前文件第一行/最后一行/第n行 w/nw #向前 移动1个单词/移动n个单词 b/nb #向后 移动1个单词/移动n个单词 文本编辑删除复制粘贴(命令模式)
a/A/i #在 光标后/行末/光标前 插入文本 o/O(字母O) #在光标下/上方新开一行 x/X #命令模式下删除光标后/前的单个字符 r/R #替换字符/复写模式,连续替换 d0/d$ #删除到 行首/行尾 dgg/dG #删除到 文件头/文件尾 dd/ndd #删除该行/删除该行下的n行 yy/nyy #复制该行/n行 p/P #当前行下/上面粘贴 u/ctrl+r #撤销上次操作/撤销反悔,重做上次撤销 文档检索
/search_text #在文档后面的部分搜索 ?search_text #在文档前面的部分搜索 n/N #往前/后移动检索到的关键字 :noh #取消检索的高亮 :%s/abc/aaa #检索第一个 “abc” 字符串并将其替换成“aaa” :%s/abc/aaa/g #检索并将所有的“abc”,替换为“aaa” :%s/original/replacement/gc #替换前先询问 可视模式
v #逐字可视模式 V #逐行可视模式 保存文件
:w new_file #另存为 不会退出 ZZ # :wq ZQ # :q!</description></item><item><title>MySql事务</title><link>/2021/02/19/mysql%E4%BA%8B%E5%8A%A1/</link><pubDate>Fri, 19 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/19/mysql%E4%BA%8B%E5%8A%A1/</guid><description>更新中&amp;hellip;
事务四大特性ACID 原子性 Atomicity
事务是数据库的逻辑工作单位，不可分割，事务中包含的各操作要么都做，要么都不做
一致性 Consistency
同一个事务中所有操作要么全部成功，要么全部失败
隔离性 Isolation
每个事务都是隔离的，互相不影响，一共有4个隔离级别
持久性 Durability
事务一旦提交，它对数据库中的数据的改变就应该是永久性的，不能回滚
​
四大隔离级别 1、读未提交 Read Uncommitted
一个事务还没提交时，它做的变更对他事务可见
2、读已提交 Read Committed Oracle默认的隔离级别
一个事务只有提交时候它做的变化才对其他事务可见，该级别会造成 在事务中两次读取数据不一致的情况
3、可重复读 Repeatable Read MySql、Innodb默认的隔离级别
一个事务开始之后，其所看见的数据就是事务开始时候的数据，相当于给数据在事务开始时拍一个快照，在事务执行过程中看见的都是这个快照，即使是其他事务做了变更提交了对此事务也不可见，解决了不可重复读、幻读问题
4、串行化 事务必须串行化执行，一个事务只有等另外一个事务结束之后才可以开始，效率最低不支持并发，但是解决了事务隔离性的所有问题
​
事务并发读写问题 1、脏读 事务读取到了其他事务还没提交的修改
A事务执行过程中，B事务做出的变化还没提交修改就被A事务读取到了，但是B事务的修改发生了回滚，那么A事务就读取到了脏数据
时间线 存款事务 取款事务 1 开始事务 2 开始事务 3 查询余额500 4 取款400，余额更改为500-400=100 5 查询余额100（脏读） 6 取款操作发生错误，事务失败，执行回滚操作 rollback （使用commit或者rollback后，事务就结束了） 7 存入500，更改余额为500+100=600 8 提交事务 9 账户出错，按照正确的逻辑此时余额应该为 500+500=1000，而此时余额为600 2、不可重复读 事务读取到了其他事务已经提交的修改，导致同一个事务两次查询结果不一样</description></item><item><title>MySql约束</title><link>/2021/02/19/mysql%E7%BA%A6%E6%9D%9F/</link><pubDate>Fri, 19 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/19/mysql%E7%BA%A6%E6%9D%9F/</guid><description><![CDATA[约束分类 约束就是给字段设置一定的规则，约束这个字段 主要有如下几类约束
 主键约束 外键约束 非空约束 唯一约束 默认值约束 检查约束  ​
主键约束 主键约束是非空的，最好使用 AUTO_INCREMENT来自动增加防止重复，并且能用int就不要用 bigint ，因为这和索引有关系，主键数据越小越好 如果一张表没有设置主键，那么Mysql就会拿一个非空约束字段当做主键，如果都没有则会自己生成一个RowID的列作主键
CREATE TABLE tb( id int PRIMARY KEY AUTO_INCREMENT ) CREATE TABLE tb( id int AUTO_INCREMENT, name varchar(20), PRIMARY KEY pk(id) ) #添加主键约束 ALTER TABLE 表名 ADD CONSTRAINT 约束名 PRIMARY KEY(列名); #删除主键约束 ALTER TABLE 表名 DROP PRIMARY KEY 约束名; ​
外键约束 外键是指引用另一个表中的一列或多列，被引用的列应该具有主键约束或唯一约束
外键约束可以设置联级:
 联级删除: 外键表中被引用的记录删除之后则连同所有拥有这个外键的记录都删除 联级更新: 外键表中被引用的记录更新之后则连同所有拥有这个外键的记录都更新  如果不设置则不允许删除还被引用的记录
CREATE TABLE IF NOT EXISTS category ( id INT PRIMARY KEY AUTO_INCREMENT, title VARCHAR(50) NOT NULL, UNIQUE uq_title (title) ); CREATE TABLE article ( id INT AUTO_INCREMENT, title VARCHAR(100) NOT NULL, created_at DATETIME NOT NULL, updated_at DATETIME NOT NULL, deleted_at DATETIME DEFAULT NULL, author VARCHAR(20) NOT NULL, status ENUM (&#39;published&#39;,&#39;auditing&#39;,&#39;draft&#39;,&#39;deleted&#39;) NOT NULL, cid INT NOT NULL, PRIMARY KEY pk_id (id), #联级删除 category记录删除了 所有引用该记录的article记录也一并删除  #如果没设置此联级策略则不允许删除还被引用的category记录  FOREIGN KEY fk_cid (cid) REFERENCES category (id) ON DELETE CASCADE, UNIQUE uq_title (title) COMMENT &#39;会自动创建唯一索引&#39; ); #添加外键 ALTER TABLE 表名 ADD CONSTRAINT 约束名 FOREIGN KEY (外键字段名) REFERENCES 外键表名(列名); #删除外键 ALTER TABLE 表名 DROP FOREIGN KEY 外键名; ​]]></description></item><item><title>堆</title><link>/2021/02/18/%E5%A0%86/</link><pubDate>Thu, 18 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/18/%E5%A0%86/</guid><description>TODO</description></item><item><title>快速排序</title><link>/2021/02/18/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link><pubDate>Thu, 18 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/18/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid><description>快排思想 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列
就是需要确定一个 pivot支点，然后将小于pivot的放到左边，大于pivot的放到右边，此时pivot就已经排好序了，然后再分别对两别进行递归排序
所以快排主要需要解决下面两个问题:
pivot的选择 如何把元素放到左边和右边，也就是如何确定pivot的位置 ​
复杂度分析 最优时间复杂度: O(nlogn) 最优空间复杂度: O(logn)
pivot每次都平分，计算时间复杂度过程和 归并排序一样计算
空间复杂度主要是递归栈的空间，看递归树的高度，比如50,10,90,30, 70,40,80,60,20 这个序列，递归深度如下，这是一颗平衡二叉树，高度是数组个数的 logn倍
最差时间复杂度: O(n^2) 最差空间复杂度: O(n)
pivot每次取最大最小值，退化为 冒泡排序 冒泡排序的时间复杂度：
T[n] = n * (n-1) = n^2 + n = O(n^2) 空间复杂度就是树的高度，单边树的高度就是元素的个数，所以空间复杂度为O(n)
​
pivot支点的选择 支点只要能将两边平均分就是最好的支点，主要有如下几个选法:
选第一个/最后一个 选中间一个 随机选一个 三数取中法: 选 开头、结尾、中间 的数中大小排中间的数 为了便于算法实现，需要取中间某个Pivot时，可以通过交换元素，转换成取第一个（或最后一个）
//随机 pivot := rand.Intn(end+1-start) + start //三数取中 func getMiddle(arr []int, start, end int) int { mid := start + (end-start)/2 if arr[start] &amp;gt; arr[mid] { mid, start = start, mid } if arr[mid] &amp;gt; arr[end] { mid, end = end, mid } return mid } ​</description></item><item><title>十大排序算法</title><link>/2021/02/17/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link><pubDate>Wed, 17 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/17/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid><description><![CDATA[更新中&hellip;..
 冒泡排序  稳定排序 最好时间复杂度: O(n) 基本有序状态，进行1次冒泡 最坏时间复杂度: O(n^2) 逆序状态，需要进行n次冒泡 平均时间复杂度: O(n^2) 空间复杂度: O(1)  func BubbleSort(arr []int) { flag := true for i := 0; i &lt; len(arr); i++ { for j := 0; j &lt; len(arr)-i-1; j++ { if arr[j] &gt; arr[j+1] { flag = false arr[j], arr[j+1] = arr[j+1], arr[j] } } if flag { break } } } ​
选择排序  不稳定排序 比如 5 8 5 2 9 两个相同的5会发生位置交换 最好时间复杂度: O(n^2) 最坏时间复杂度: O(n^2) 平均时间复杂度: O(n^2) 空间复杂度: O(1)  每次选择剩余排序区间中最小(大)的元素放入排序好的区间的最后一个位置中]]></description></item><item><title>装饰者模式</title><link>/2021/02/17/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Wed, 17 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/17/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description><![CDATA[跟新中&hellip;.
 装饰者模式 Decorator Pattern 装饰者模式，动态的透明的增加一些另外的功能而不需要改变原来的代码，拥有更好的灵活性和可扩展性
从名字中也可以看出，装饰者模式就是给一个对象加上一层装饰，穿上一件衣服，装饰者在我解除的技术里面在函数式语言中的应用比较广泛，就是在装饰函数里传入一个目标函数，装饰函数同样返回一个目标函数，但是返回的函数是进过装饰了的
​
在Java中的应用和实现 实现案例 下面先来看一个 Shape 自己实现的案例:
Shape顶层接口:
public interface Shape { String display(); } Circle和Rectangle具体实现
public class Circle implements Shape{ private String name; public Circle(){ this.name = &#34;Circle&#34;; } public String display() { return this.name; } } ------------------------------------------------ public class Rectangle implements Shape { private String name; public Rectangle() { this.name = &#34;Rectangle&#34;; } public String display() { return this.name; } } 所有装饰器的顶层抽象对象，这里通过构造方法和set方法可以传入被装饰对象]]></description></item><item><title>MySql字符集</title><link>/2021/02/16/mysql%E5%AD%97%E7%AC%A6%E9%9B%86/</link><pubDate>Tue, 16 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/16/mysql%E5%AD%97%E7%AC%A6%E9%9B%86/</guid><description><![CDATA[MySql字符集 MySql支持很多字符集，可以使用如下命令查看MySql支持的字符集:
SHOW CHARACTER SET SHOW CHARSET SHOW CHARACTER SET LIKE &#39;utf8%&#39; 其中Default collation 表示默认的 比较规则 MAXlen表示最大长度
下面是几个重要的字符集的最大长度:
   字符集名称 Maxlen     ascii 1   gbk 2   utf8 3   utf8mb4 4    ​
utf8和utf8mb4 utf8是utf8mb3的别名，只支持最大长度是3byte，属于 阉割版 的UTF8字符集
utf8mb4 是完整的UTF8字符集，最大支持4byte，包含所有UTF8字符集
所以如果文本里面有特殊符号或则表情符号，比如存博客等就需要修改表的字符集为utf8mb4
​
字符集比较规则 字符集比较规则用于字符集比较，比如a、A两个比较，是按照二进制大小来比较还是忽略大小写进行比较
可以使用如下命令显示支持的比较规则
SHOW COLLATION #显示所有比较规则 SHOW COLLATION LIKE &#39;%utf8%&#39; utf8默认的比较规则就是utf8_general_ci
utf8mb4默认是utf8mb4_0900_ai_ci
 以ci结尾的比较规则都是忽略大小写的
 ​
字符集和比较规则应用范围 分别有3个应用范围:]]></description></item></channel></rss>