<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - lyer's blog</title><link>/posts/</link><description>所有文章 | lyer's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>icepan@aliyun.com (lyer)</managingEditor><webMaster>icepan@aliyun.com (lyer)</webMaster><lastBuildDate>Thu, 18 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="/posts/" rel="self" type="application/rss+xml"/><item><title>堆</title><link>/2021/02/18/%E5%A0%86/</link><pubDate>Thu, 18 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/18/%E5%A0%86/</guid><description>TODO</description></item><item><title>快速排序</title><link>/2021/02/18/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link><pubDate>Thu, 18 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/18/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid><description>TODO</description></item><item><title>十大排序算法</title><link>/2021/02/17/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link><pubDate>Wed, 17 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/17/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid><description><![CDATA[更新中&hellip;..
 冒泡排序  稳定排序 最好时间复杂度: O(n) 基本有序状态，进行1次冒泡 最坏时间复杂度: O(n^2) 逆序状态，需要进行n次冒泡 平均时间复杂度: O(n^2) 空间复杂度: O(1)  func BubbleSort(arr []int) { flag := true for i := 0; i &lt; len(arr); i++ { for j := 0; j &lt; len(arr)-i-1; j++ { if arr[j] &gt; arr[j+1] { flag = false arr[j], arr[j+1] = arr[j+1], arr[j] } } if flag { break } } } ​
选择排序  不稳定排序 比如 5 8 5 2 9 两个相同的5会发生位置交换 最好时间复杂度: O(n^2) 最坏时间复杂度: O(n^2) 平均时间复杂度: O(n^2) 空间复杂度: O(1)  每次选择剩余排序区间中最小(大)的元素放入排序好的区间的最后一个位置中]]></description></item><item><title>装饰者模式</title><link>/2021/02/17/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Wed, 17 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/17/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description><![CDATA[跟新中&hellip;.
 装饰者模式 Decorator Pattern 装饰者模式，动态的透明的增加一些另外的功能而不需要改变原来的代码，拥有更好的灵活性和可扩展性
从名字中也可以看出，装饰者模式就是给一个对象加上一层装饰，穿上一件衣服，装饰者在我解除的技术里面在函数式语言中的应用比较广泛，就是在装饰函数里传入一个目标函数，装饰函数同样返回一个目标函数，但是返回的函数是进过装饰了的
​
在Java中的应用和实现 实现案例 下面先来看一个 Shape 自己实现的案例:
Shape顶层接口:
public interface Shape { String display(); } Circle和Rectangle具体实现
public class Circle implements Shape{ private String name; public Circle(){ this.name = &#34;Circle&#34;; } public String display() { return this.name; } } ------------------------------------------------ public class Rectangle implements Shape { private String name; public Rectangle() { this.name = &#34;Rectangle&#34;; } public String display() { return this.name; } } 所有装饰器的顶层抽象对象，这里通过构造方法和set方法可以传入被装饰对象]]></description></item><item><title>MySql字符集</title><link>/2021/02/16/mysql%E5%AD%97%E7%AC%A6%E9%9B%86/</link><pubDate>Tue, 16 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/16/mysql%E5%AD%97%E7%AC%A6%E9%9B%86/</guid><description><![CDATA[MySql字符集 MySql支持很多字符集，可以使用如下命令查看MySql支持的字符集:
SHOW CHARACTER SET SHOW CHARSET SHOW CHARACTER SET LIKE &#39;utf8%&#39; 其中Default collation 表示默认的 比较规则 MAXlen表示最大长度
下面是几个重要的字符集的最大长度:
   字符集名称 Maxlen     ascii 1   gbk 2   utf8 3   utf8mb4 4    ​
utf8和utf8mb4 utf8是utf8mb3的别名，只支持最大长度是3byte，属于 阉割版 的UTF8字符集
utf8mb4 是完整的UTF8字符集，最大支持4byte，包含所有UTF8字符集
所以如果文本里面有特殊符号或则表情符号，比如存博客等就需要修改表的字符集为utf8mb4
​
字符集比较规则 字符集比较规则用于字符集比较，比如a、A两个比较，是按照二进制大小来比较还是忽略大小写进行比较
可以使用如下命令显示支持的比较规则
SHOW COLLATION #显示所有比较规则 SHOW COLLATION LIKE &#39;%utf8%&#39; utf8默认的比较规则就是utf8_general_ci
utf8mb4默认是utf8mb4_0900_ai_ci
 以ci结尾的比较规则都是忽略大小写的
 ​
字符集和比较规则应用范围 分别有3个应用范围:]]></description></item><item><title>MySql配置文件</title><link>/2021/02/16/mysql%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F/</link><pubDate>Tue, 16 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/16/mysql%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F/</guid><description><![CDATA[更新中&hellip;&hellip;
 配置文件 MySql配置文件的作用就是给mysqld服务器进程提供启动参数，设置一些变量，也可以通过命令行方式设置参数，但是这样太麻烦了而且不是永久的，所以一般都将这些参数写在配置文件中，mysqld进程启动的时候会按照如下方式去寻找配置文件:
$ mysql --help | grep my.cnf /etc/my.cnf /etc/mysql/my.cnf ~/.my.cnf  /etc/my.cnf /etc/mysql/my.cnf $MYSQL_HOME/my.cnf ~/.my.cnf  可以指定配置文件路径:
$ mysqld --defaults-file=/etc/my.cnf #只读取这一个配置文件 $ mysqld --defaults-extra-file=/my.cnf #添加额外的配置文件路径加入默认的搜索路径，也就是说其他路径包括这个也会被搜索到 另外注意：命令行参数优先级高于配置文件，搜索路径前面的配置高于后面的，并且有些命令行参数是只属于命令行的，不属于配置文件，配置文件都可以用命令行替代
配置文件分为如下几组:
[server] ... [mysqld] ... [mysqld_safe] [client] [mysql] [mysqladmin] ​
[mysqld]配置 TODO
[server]配置 TODO
[client]配置 TODO
[mysql]配置 TODO
[mysqld_safe]配置 TODO
[mysqladmin]配置 TODO
系统变量 1、系统变量的查看 系统变量一般通过SHOW VARIABLES LIKE xxx来查看，下面展示常用的系统变量
SHOW VARIABLES LIKE &#39;default_storage_engine&#39; #默认使用的搜索引擎 在配置文件的变量可以用-线链接，而这些变量保存在数据库中则是以_链接
2、系统变量作用范围 系统变量有作用的范围之分，有下面几个范围:
 GLOBAL 全局所有用户 SESSION 特指当前一个用户，一般客户端可以通过连接字符串添加参数来设置这些变量比如设置 时区、字符集 等，这属于单个连接的客户端  查询的时候可以指定范围，不指定则默认是SESSION]]></description></item><item><title>SQL总结</title><link>/2021/02/16/sql%E6%80%BB%E7%BB%93/</link><pubDate>Tue, 16 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/16/sql%E6%80%BB%E7%BB%93/</guid><description><![CDATA[更新中&hellip;&hellip;
 表操作 建表
CREATE TABLE test ( ) ENGINE = InnoDB #设置表的存储引擎  DEFAULT CHARSET = utf8 #设置表的字符集、  COLLATE=utf8_bin #设置字符集比较规则 drop table if exists category,article,tag,article_tag; CREATE TABLE IF NOT EXISTS category ( id INT PRIMARY KEY AUTO_INCREMENT, title VARCHAR(50) NOT NULL, UNIQUE uq_title (title) ) ENGINE = InnoDB CHARACTER SET = utf8; CREATE TABLE article ( id INT AUTO_INCREMENT, title VARCHAR(100) NOT NULL, created_at DATETIME NOT NULL, updated_at DATETIME NOT NULL, deleted_at DATETIME DEFAULT NULL, author VARCHAR(20) NOT NULL, status ENUM (&#39;published&#39;,&#39;auditing&#39;,&#39;draft&#39;,&#39;deleted&#39;) NOT NULL, cid INT NOT NULL, PRIMARY KEY pk_id (id), FOREIGN KEY fk_cid (cid) REFERENCES category (id) ON DELETE CASCADE, UNIQUE uq_title (title) COMMENT &#39;会自动创建唯一索引&#39; ) ENGINE = InnoDB CHARACTER SET = utf8mb4; CREATE TABLE tag ( id INT PRIMARY KEY AUTO_INCREMENT, title varchar(20) NOT NULL, UNIQUE uq_title (title) ); CREATE TABLE article_tag ( id INT PRIMARY KEY AUTO_INCREMENT, tid INT NOT NULL, aid INT NOT NULL, FOREIGN KEY fk_tid (tid) REFERENCES tag (id), FOREIGN KEY fk_aid (aid) REFERENCES article (id), UNIQUE uq_tid_aid (tid, aid) ); 展示建表语句]]></description></item><item><title>Go优雅的处理error</title><link>/2021/02/15/go%E4%BC%98%E9%9B%85%E7%9A%84%E5%A4%84%E7%90%86error/</link><pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/15/go%E4%BC%98%E9%9B%85%E7%9A%84%E5%A4%84%E7%90%86error/</guid><description>大道至简的error go的错误处理就只有一个errors包和一个error接口，这个接口只包哈一个Error方法，该方法返回一个string，这个包的代码很少，只有两个文件：
errors.go wrap.go go的error也就是通过创建一个 错误提示的字符串 的方式，然后通过返回值来返回这个错误，基本每个函数的返回值都标配一个error对象以及函数本身的返回值：
函数本身返回值 error对象 最简单的创建错误的方式就是通过errors.New来创建：
func f() error{ return errors.New(&amp;#34;error&amp;#34;) } 下面来看下errors.go的源码，不过10行左右
func New(text string) error { return &amp;amp;errorString{text} } // errorString is a trivial implementation of error. //实现了error接口 type errorString struct { s string } //获取错误字符串的方法 func (e *errorString) Error() string { return e.s } 综上来看，我们只需要实现error接口即可自定义错误（很多包都有自定义错误，可以参考他们的实现）：
type ZeroDivisionError struct { msg string code int } func (e ZeroDivisionError) Error() string { return fmt.</description></item><item><title>Go测试总结</title><link>/2021/02/15/go%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/15/go%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93/</guid><description>go中的测试 go的测试是是以 xxx_test.go结尾的，前面的名字和对应的测试文件名字一样，后面加个test，运行测试命令之后就会扫描所有测试文件进行测试
xxx_test.go测试文件中主要有如下几个部分:
类型 格式 作用 单元测试 函数名前缀为Test 测试程序的一些逻辑行为是否正确 基准测试 函数名前缀为Benchmark 测试函数的性能 示例代码 函数名前缀为Example 为文档提供示例文档 ​
单元测试 $ go test -v #扫描当前包下所有的测试文件进行测试 并且输出详细信息 $ go test -v -test.run A #测试包含 A 字母的单元测试函数 [只能运行单元测试] 单元测试函数必须以 t *testing为参数，t主要用于报告测试结果是否正确以及日志记录，主要有如下几个方法:
Error Log 最常用
//标记失败 func (c *T) Fail() //标记失败，但继续执行当前测试函数 func (c *T) FailNow() //标记失败，停止下面的执行 func (c *T) Failed() bool //日志信息 go test如果测试成功的话，不会打印这部分内容，加上 -v则测试成功也会显示 func (c *T) Log(args .</description></item><item><title>Go随机数用法</title><link>/2021/02/15/go%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%A8%E6%B3%95/</link><pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate><author>作者</author><guid>/2021/02/15/go%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%A8%E6%B3%95/</guid><description><![CDATA[基本用法 go随机数在math/rand包下，go的随机数需要先给他一个Seed，Seed如果一样的话或则不设置的话每次生成的都是 伪随机数 ，多次执行生成的都是一样的随机数序列，所以必须设定Seed而且还是以 时间戳 的方式来设置，如下生成 [0,10)之间的随机整数：
rand.Seed(time.Now().UnixNano()) r:=rand.Intn(10) //[0,10) 返回int类型 r=rand.Int63n(10) //返回int64 .... 如果要生成指定范围的随机整数，如下生成[min,max)之间的随机整数：
rand.Seed(time.Now().UnixNano()) max:=10;min:=-10 rand.Intn(max-min)+min) //[-10,10) ​
随机负载均衡实现 我们实战一下，实现一个 随机数负载均衡
type RandomBalance struct { curIndex int hosts []string } func (r *RandomBalance) Add(host string) { r.hosts = append(r.hosts, host) } func (r *RandomBalance) Next() (string, error) { if len(r.hosts) == 0 { return &#34;&#34;, errors.New(&#34;no host&#34;) } rand.Seed(time.Now().UnixNano()) r.curIndex = rand.Intn(len(r.hosts)) return r.hosts[r.curIndex], nil } func main() { rb := RandomBalance{} for i := 1; i &lt; 10; i++ { rb.]]></description></item></channel></rss>